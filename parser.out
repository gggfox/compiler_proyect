Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM np_set_curr_proc ID np_GOTO SEMICOLON programB np_prog_end
Rule 2     programB -> vars programC
Rule 3     programB -> programC
Rule 4     programC -> function programC
Rule 5     programC -> main
Rule 6     vars -> VARS L_BRACE varsB R_BRACE
Rule 7     varsB -> type np_set_curr_datatype COLON varsC SEMICOLON
Rule 8     varsB -> type np_set_curr_datatype COLON varsC SEMICOLON varsB
Rule 9     varsC -> var np_add_var
Rule 10    varsC -> var np_add_var COMMA varsC
Rule 11    function -> FUNCTION func_type ID np_set_curr_proc L_PAR params R_PAR np_set_quad_start vblock np_ENDFunc
Rule 12    main -> MAIN np_set_curr_proc np_GOTO_END L_PAR R_PAR vblock
Rule 13    type -> INT
Rule 14    type -> FLOAT
Rule 15    type -> BOOL
Rule 16    type -> CHAR
Rule 17    type -> STRING
Rule 18    var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
Rule 19    var -> ID
Rule 20    vector -> ID L_BRACKET R_BRACKET
Rule 21    func_type -> VOID
Rule 22    func_type -> type
Rule 23    block -> L_BRACE blockB R_BRACE
Rule 24    blockB -> statement blockB
Rule 25    blockB -> empty
Rule 26    vblock -> L_BRACE vars vblockB R_BRACE
Rule 27    vblock -> block
Rule 28    vblockB -> statement vblockB
Rule 29    vblockB -> empty
Rule 30    params -> type COLON ID np_add_param
Rule 31    params -> type COLON ID np_add_param COMMA params
Rule 32    params -> empty
Rule 33    statement -> assign
Rule 34    statement -> condicional
Rule 35    statement -> read
Rule 36    statement -> write
Rule 37    statement -> loop_cond
Rule 38    statement -> loop_range
Rule 39    statement -> return
Rule 40    statement -> void_func
Rule 41    void_func -> func_call SEMICOLON
Rule 42    assign -> var np_push_operand oper_assign np_push_operator expression np_end SEMICOLON
Rule 43    predef_func -> LENGTH L_PAR vector R_PAR
Rule 44    predef_func -> MIN L_PAR vector R_PAR
Rule 45    predef_func -> MAX L_PAR vector R_PAR
Rule 46    predef_func -> MEAN L_PAR vector R_PAR
Rule 47    predef_func -> MEDIAN L_PAR vector R_PAR
Rule 48    predef_func -> MODE L_PAR vector R_PAR
Rule 49    predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR
Rule 50    predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR
Rule 51    predef_func -> VARIANCE L_PAR vector R_PAR
Rule 52    predef_func -> DOT L_PAR vector COMMA vector R_PAR
Rule 53    predef_func -> SUM L_PAR vector R_PAR
Rule 54    predef_func -> ABS L_PAR CTE_INT R_PAR
Rule 55    predef_func -> ROOF L_PAR CTE_FLOAT R_PAR
Rule 56    predef_func -> FLOOR L_PAR CTE_FLOAT R_PAR
Rule 57    condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END
Rule 58    cond2 -> np_GOTO_ELSE ELSE block
Rule 59    cond2 -> empty
Rule 60    read -> READ L_PAR read2 R_PAR SEMICOLON
Rule 61    read2 -> var np_read
Rule 62    read2 -> var np_read COMMA read2
Rule 63    write -> WRITE L_PAR writeB R_PAR SEMICOLON
Rule 64    writeB -> expression np_end np_write writeC
Rule 65    writeB -> CTE_STRING np_push_cte_str np_write writeC
Rule 66    writeC -> COMMA writeB
Rule 67    writeC -> empty
Rule 68    loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE
Rule 69    loop_range -> FOR var np_push_operand EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR
Rule 70    return -> RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON
Rule 71    func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB
Rule 72    func_call_arguments -> np_stop exp np_end np_param
Rule 73    func_call_arguments -> np_stop exp np_end np_param COMMA func_call_arguments
Rule 74    func_call_arguments -> empty
Rule 75    expression -> not logic expressionB
Rule 76    expressionB -> OR np_push_operator expression
Rule 77    expressionB -> AND np_push_operator expression
Rule 78    expressionB -> empty
Rule 79    oper_assign -> EQUAL
Rule 80    oper_assign -> MULT_EQ
Rule 81    oper_assign -> DIV_EQ
Rule 82    oper_assign -> PLUS_EQ
Rule 83    oper_assign -> MINUS_EQ
Rule 84    not -> NOT np_push_operator
Rule 85    not -> empty
Rule 86    logic -> exp logic2
Rule 87    logic2 -> LESS np_push_operator exp
Rule 88    logic2 -> GREATER np_push_operator exp
Rule 89    logic2 -> LESS_EQ np_push_operator exp
Rule 90    logic2 -> GREATER_EQ np_push_operator exp
Rule 91    logic2 -> EQUIVALENT np_push_operator exp
Rule 92    logic2 -> DIFFERENT np_push_operator exp
Rule 93    logic2 -> empty
Rule 94    exp -> term exp2
Rule 95    exp2 -> PLUS np_push_operator exp
Rule 96    exp2 -> MINUS np_push_operator exp
Rule 97    exp2 -> empty
Rule 98    term -> factor term2
Rule 99    term2 -> MULT np_push_operator term
Rule 100   term2 -> DIV np_push_operator term
Rule 101   term2 -> REMAINDER np_push_operator term
Rule 102   term2 -> empty
Rule 103   factor -> exponent factorB
Rule 104   factorB -> EXP factor
Rule 105   factorB -> empty
Rule 106   exponent -> L_PAR np_push_operator expression R_PAR np_rpar
Rule 107   exponent -> exponentB
Rule 108   exponentB -> MINUS var_cte
Rule 109   exponentB -> var_cte
Rule 110   var_cte -> var np_push_operand
Rule 111   var_cte -> predef_func
Rule 112   var_cte -> func_call
Rule 113   var_cte -> CTE_INT np_push_cte_int
Rule 114   var_cte -> CTE_FLOAT np_push_cte_float
Rule 115   var_cte -> CTE_CHAR np_push_cte_char
Rule 116   var_cte -> CTE_STRING np_push_cte_str
Rule 117   var_cte -> CTE_BOOL np_push_cte_bool
Rule 118   empty -> <empty>
Rule 119   np_set_curr_proc -> <empty>
Rule 120   np_push_operator -> <empty>
Rule 121   np_push_operand -> <empty>
Rule 122   np_push_cte_int -> <empty>
Rule 123   np_push_cte_float -> <empty>
Rule 124   np_push_cte_char -> <empty>
Rule 125   np_push_cte_str -> <empty>
Rule 126   np_push_cte_bool -> <empty>
Rule 127   np_set_curr_datatype -> <empty>
Rule 128   np_add_datatype -> <empty>
Rule 129   np_add_var -> <empty>
Rule 130   np_set_curr_scope -> <empty>
Rule 131   np_rpar -> <empty>
Rule 132   np_set_return -> <empty>
Rule 133   np_end -> <empty>
Rule 134   np_read -> <empty>
Rule 135   np_write -> <empty>
Rule 136   np_set_VC -> <empty>
Rule 137   np_comp_VC_VF -> <empty>
Rule 138   np_GOTO -> <empty>
Rule 139   np_GOTOF -> <empty>
Rule 140   np_GOTO_ELSE -> <empty>
Rule 141   np_GOTO_END -> <empty>
Rule 142   np_GOTO_WHILE -> <empty>
Rule 143   np_GOTO_FOR -> <empty>
Rule 144   np_CHECKPOINT -> <empty>
Rule 145   np_add_param -> <empty>
Rule 146   np_set_quad_start -> <empty>
Rule 147   np_GOSUB -> <empty>
Rule 148   np_ERA -> <empty>
Rule 149   np_param -> <empty>
Rule 150   np_ENDFunc -> <empty>
Rule 151   np_arr_start -> <empty>
Rule 152   np_arr_end -> <empty>
Rule 153   np_stop -> <empty>
Rule 154   np_prog_end -> <empty>

Terminals, with rules where they appear

ABS                  : 54
AND                  : 77
BOOL                 : 15
CHAR                 : 16
COLON                : 7 8 30 31
COMMA                : 10 31 49 50 52 62 66 73
CTE_BOOL             : 117
CTE_CHAR             : 115
CTE_FLOAT            : 55 56 114
CTE_INT              : 54 113
CTE_STRING           : 65 116
DIFFERENT            : 92
DIV                  : 100
DIV_EQ               : 81
DOT                  : 52
ELSE                 : 58
EQUAL                : 69 79
EQUIVALENT           : 91
EXP                  : 104
FLOAT                : 14
FLOOR                : 56
FOR                  : 69
FUNCTION             : 11
GREATER              : 88
GREATER_EQ           : 90
ID                   : 1 11 18 19 20 30 31 71
IF                   : 57
INT                  : 13
LENGTH               : 43
LESS                 : 87
LESS_EQ              : 89
L_BRACE              : 6 23 26
L_BRACKET            : 18 20
L_PAR                : 11 12 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 60 63 68 70 71 106
MAIN                 : 12
MAX                  : 45
MEAN                 : 46
MEDIAN               : 47
MIN                  : 44
MINUS                : 96 108
MINUS_EQ             : 83
MODE                 : 48
MULT                 : 99
MULT_EQ              : 80
NOT                  : 84
OR                   : 76
PLOT_XY              : 49
PLUS                 : 95
PLUS_EQ              : 82
PROGRAM              : 1
READ                 : 60
REGRESSION           : 50
REMAINDER            : 101
RETURN               : 70
ROOF                 : 55
R_BRACE              : 6 23 26
R_BRACKET            : 18 20
R_PAR                : 11 12 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 60 63 68 70 71 106
SEMICOLON            : 1 7 8 41 42 60 63 70
STRING               : 17
SUM                  : 53
TO                   : 69
VARIANCE             : 51
VARS                 : 6
VOID                 : 21
WHILE                : 68
WRITE                : 63
error                : 

Nonterminals, with rules where they appear

assign               : 33
block                : 27 57 58 68 69
blockB               : 23 24
cond2                : 57
condicional          : 34
empty                : 25 29 32 59 67 74 78 85 93 97 102 105
exp                  : 18 69 69 70 72 73 86 87 88 89 90 91 92 95 96
exp2                 : 94
exponent             : 103
exponentB            : 107
expression           : 42 57 64 68 76 77 106
expressionB          : 75
factor               : 98 104
factorB              : 103
func_call            : 41 112
func_call_arguments  : 71 73
func_type            : 11
function             : 4
logic                : 75
logic2               : 86
loop_cond            : 37
loop_range           : 38
main                 : 5
not                  : 75
np_CHECKPOINT        : 68
np_ENDFunc           : 11
np_ERA               : 71
np_GOSUB             : 71
np_GOTO              : 1
np_GOTOF             : 57 68
np_GOTO_ELSE         : 58
np_GOTO_END          : 12 57
np_GOTO_FOR          : 69
np_GOTO_WHILE        : 68
np_add_datatype      : 
np_add_param         : 30 31
np_add_var           : 9 10
np_arr_end           : 18
np_arr_start         : 18
np_comp_VC_VF        : 69
np_end               : 18 42 57 64 68 69 70 72 73
np_param             : 72 73
np_prog_end          : 1
np_push_cte_bool     : 117
np_push_cte_char     : 115
np_push_cte_float    : 114
np_push_cte_int      : 113
np_push_cte_str      : 65 116
np_push_operand      : 42 69 110
np_push_operator     : 42 69 76 77 84 87 88 89 90 91 92 95 96 99 100 101 106
np_read              : 61 62
np_rpar              : 106
np_set_VC            : 69
np_set_curr_datatype : 7 8
np_set_curr_proc     : 1 11 12
np_set_curr_scope    : 
np_set_quad_start    : 11
np_set_return        : 70
np_stop              : 70 72 73
np_write             : 64 65
oper_assign          : 42
params               : 11 31
predef_func          : 111
program              : 0
programB             : 1
programC             : 2 3 4
read                 : 35
read2                : 60 62
return               : 39
statement            : 24 28
term                 : 94 99 100 101
term2                : 98
type                 : 7 8 22 30 31
var                  : 9 10 42 61 62 69 110
var_cte              : 108 109
vars                 : 2 26
varsB                : 6 8
varsC                : 7 8 10
vblock               : 11 12
vblockB              : 26 28
vector               : 43 44 45 46 47 48 49 49 50 50 51 52 52 53
void_func            : 40
write                : 36
writeB               : 63 66
writeC               : 64 65

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM np_set_curr_proc ID np_GOTO SEMICOLON programB np_prog_end

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . np_set_curr_proc ID np_GOTO SEMICOLON programB np_prog_end
    (119) np_set_curr_proc -> .

    ID              reduce using rule 119 (np_set_curr_proc -> .)

    np_set_curr_proc               shift and go to state 3

state 3

    (1) program -> PROGRAM np_set_curr_proc . ID np_GOTO SEMICOLON programB np_prog_end

    ID              shift and go to state 4


state 4

    (1) program -> PROGRAM np_set_curr_proc ID . np_GOTO SEMICOLON programB np_prog_end
    (138) np_GOTO -> .

    SEMICOLON       reduce using rule 138 (np_GOTO -> .)

    np_GOTO                        shift and go to state 5

state 5

    (1) program -> PROGRAM np_set_curr_proc ID np_GOTO . SEMICOLON programB np_prog_end

    SEMICOLON       shift and go to state 6


state 6

    (1) program -> PROGRAM np_set_curr_proc ID np_GOTO SEMICOLON . programB np_prog_end
    (2) programB -> . vars programC
    (3) programB -> . programC
    (6) vars -> . VARS L_BRACE varsB R_BRACE
    (4) programC -> . function programC
    (5) programC -> . main
    (11) function -> . FUNCTION func_type ID np_set_curr_proc L_PAR params R_PAR np_set_quad_start vblock np_ENDFunc
    (12) main -> . MAIN np_set_curr_proc np_GOTO_END L_PAR R_PAR vblock

    VARS            shift and go to state 10
    FUNCTION        shift and go to state 13
    MAIN            shift and go to state 14

    programB                       shift and go to state 7
    vars                           shift and go to state 8
    programC                       shift and go to state 9
    function                       shift and go to state 11
    main                           shift and go to state 12

state 7

    (1) program -> PROGRAM np_set_curr_proc ID np_GOTO SEMICOLON programB . np_prog_end
    (154) np_prog_end -> .

    $end            reduce using rule 154 (np_prog_end -> .)

    np_prog_end                    shift and go to state 15

state 8

    (2) programB -> vars . programC
    (4) programC -> . function programC
    (5) programC -> . main
    (11) function -> . FUNCTION func_type ID np_set_curr_proc L_PAR params R_PAR np_set_quad_start vblock np_ENDFunc
    (12) main -> . MAIN np_set_curr_proc np_GOTO_END L_PAR R_PAR vblock

    FUNCTION        shift and go to state 13
    MAIN            shift and go to state 14

    programC                       shift and go to state 16
    function                       shift and go to state 11
    main                           shift and go to state 12

state 9

    (3) programB -> programC .

    $end            reduce using rule 3 (programB -> programC .)


state 10

    (6) vars -> VARS . L_BRACE varsB R_BRACE

    L_BRACE         shift and go to state 17


state 11

    (4) programC -> function . programC
    (4) programC -> . function programC
    (5) programC -> . main
    (11) function -> . FUNCTION func_type ID np_set_curr_proc L_PAR params R_PAR np_set_quad_start vblock np_ENDFunc
    (12) main -> . MAIN np_set_curr_proc np_GOTO_END L_PAR R_PAR vblock

    FUNCTION        shift and go to state 13
    MAIN            shift and go to state 14

    function                       shift and go to state 11
    programC                       shift and go to state 18
    main                           shift and go to state 12

state 12

    (5) programC -> main .

    $end            reduce using rule 5 (programC -> main .)


state 13

    (11) function -> FUNCTION . func_type ID np_set_curr_proc L_PAR params R_PAR np_set_quad_start vblock np_ENDFunc
    (21) func_type -> . VOID
    (22) func_type -> . type
    (13) type -> . INT
    (14) type -> . FLOAT
    (15) type -> . BOOL
    (16) type -> . CHAR
    (17) type -> . STRING

    VOID            shift and go to state 20
    INT             shift and go to state 22
    FLOAT           shift and go to state 23
    BOOL            shift and go to state 24
    CHAR            shift and go to state 25
    STRING          shift and go to state 26

    func_type                      shift and go to state 19
    type                           shift and go to state 21

state 14

    (12) main -> MAIN . np_set_curr_proc np_GOTO_END L_PAR R_PAR vblock
    (119) np_set_curr_proc -> .

    L_PAR           reduce using rule 119 (np_set_curr_proc -> .)

    np_set_curr_proc               shift and go to state 27

state 15

    (1) program -> PROGRAM np_set_curr_proc ID np_GOTO SEMICOLON programB np_prog_end .

    $end            reduce using rule 1 (program -> PROGRAM np_set_curr_proc ID np_GOTO SEMICOLON programB np_prog_end .)


state 16

    (2) programB -> vars programC .

    $end            reduce using rule 2 (programB -> vars programC .)


state 17

    (6) vars -> VARS L_BRACE . varsB R_BRACE
    (7) varsB -> . type np_set_curr_datatype COLON varsC SEMICOLON
    (8) varsB -> . type np_set_curr_datatype COLON varsC SEMICOLON varsB
    (13) type -> . INT
    (14) type -> . FLOAT
    (15) type -> . BOOL
    (16) type -> . CHAR
    (17) type -> . STRING

    INT             shift and go to state 22
    FLOAT           shift and go to state 23
    BOOL            shift and go to state 24
    CHAR            shift and go to state 25
    STRING          shift and go to state 26

    varsB                          shift and go to state 28
    type                           shift and go to state 29

state 18

    (4) programC -> function programC .

    $end            reduce using rule 4 (programC -> function programC .)


state 19

    (11) function -> FUNCTION func_type . ID np_set_curr_proc L_PAR params R_PAR np_set_quad_start vblock np_ENDFunc

    ID              shift and go to state 30


state 20

    (21) func_type -> VOID .

    ID              reduce using rule 21 (func_type -> VOID .)


state 21

    (22) func_type -> type .

    ID              reduce using rule 22 (func_type -> type .)


state 22

    (13) type -> INT .

    ID              reduce using rule 13 (type -> INT .)
    COLON           reduce using rule 13 (type -> INT .)


state 23

    (14) type -> FLOAT .

    ID              reduce using rule 14 (type -> FLOAT .)
    COLON           reduce using rule 14 (type -> FLOAT .)


state 24

    (15) type -> BOOL .

    ID              reduce using rule 15 (type -> BOOL .)
    COLON           reduce using rule 15 (type -> BOOL .)


state 25

    (16) type -> CHAR .

    ID              reduce using rule 16 (type -> CHAR .)
    COLON           reduce using rule 16 (type -> CHAR .)


state 26

    (17) type -> STRING .

    ID              reduce using rule 17 (type -> STRING .)
    COLON           reduce using rule 17 (type -> STRING .)


state 27

    (12) main -> MAIN np_set_curr_proc . np_GOTO_END L_PAR R_PAR vblock
    (141) np_GOTO_END -> .

    L_PAR           reduce using rule 141 (np_GOTO_END -> .)

    np_GOTO_END                    shift and go to state 31

state 28

    (6) vars -> VARS L_BRACE varsB . R_BRACE

    R_BRACE         shift and go to state 32


state 29

    (7) varsB -> type . np_set_curr_datatype COLON varsC SEMICOLON
    (8) varsB -> type . np_set_curr_datatype COLON varsC SEMICOLON varsB
    (127) np_set_curr_datatype -> .

    COLON           reduce using rule 127 (np_set_curr_datatype -> .)

    np_set_curr_datatype           shift and go to state 33

state 30

    (11) function -> FUNCTION func_type ID . np_set_curr_proc L_PAR params R_PAR np_set_quad_start vblock np_ENDFunc
    (119) np_set_curr_proc -> .

    L_PAR           reduce using rule 119 (np_set_curr_proc -> .)

    np_set_curr_proc               shift and go to state 34

state 31

    (12) main -> MAIN np_set_curr_proc np_GOTO_END . L_PAR R_PAR vblock

    L_PAR           shift and go to state 35


state 32

    (6) vars -> VARS L_BRACE varsB R_BRACE .

    FUNCTION        reduce using rule 6 (vars -> VARS L_BRACE varsB R_BRACE .)
    MAIN            reduce using rule 6 (vars -> VARS L_BRACE varsB R_BRACE .)
    IF              reduce using rule 6 (vars -> VARS L_BRACE varsB R_BRACE .)
    READ            reduce using rule 6 (vars -> VARS L_BRACE varsB R_BRACE .)
    WRITE           reduce using rule 6 (vars -> VARS L_BRACE varsB R_BRACE .)
    WHILE           reduce using rule 6 (vars -> VARS L_BRACE varsB R_BRACE .)
    FOR             reduce using rule 6 (vars -> VARS L_BRACE varsB R_BRACE .)
    RETURN          reduce using rule 6 (vars -> VARS L_BRACE varsB R_BRACE .)
    ID              reduce using rule 6 (vars -> VARS L_BRACE varsB R_BRACE .)
    R_BRACE         reduce using rule 6 (vars -> VARS L_BRACE varsB R_BRACE .)


state 33

    (7) varsB -> type np_set_curr_datatype . COLON varsC SEMICOLON
    (8) varsB -> type np_set_curr_datatype . COLON varsC SEMICOLON varsB

    COLON           shift and go to state 36


state 34

    (11) function -> FUNCTION func_type ID np_set_curr_proc . L_PAR params R_PAR np_set_quad_start vblock np_ENDFunc

    L_PAR           shift and go to state 37


state 35

    (12) main -> MAIN np_set_curr_proc np_GOTO_END L_PAR . R_PAR vblock

    R_PAR           shift and go to state 38


state 36

    (7) varsB -> type np_set_curr_datatype COLON . varsC SEMICOLON
    (8) varsB -> type np_set_curr_datatype COLON . varsC SEMICOLON varsB
    (9) varsC -> . var np_add_var
    (10) varsC -> . var np_add_var COMMA varsC
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID

    ID              shift and go to state 41

    varsC                          shift and go to state 39
    var                            shift and go to state 40

state 37

    (11) function -> FUNCTION func_type ID np_set_curr_proc L_PAR . params R_PAR np_set_quad_start vblock np_ENDFunc
    (30) params -> . type COLON ID np_add_param
    (31) params -> . type COLON ID np_add_param COMMA params
    (32) params -> . empty
    (13) type -> . INT
    (14) type -> . FLOAT
    (15) type -> . BOOL
    (16) type -> . CHAR
    (17) type -> . STRING
    (118) empty -> .

    INT             shift and go to state 22
    FLOAT           shift and go to state 23
    BOOL            shift and go to state 24
    CHAR            shift and go to state 25
    STRING          shift and go to state 26
    R_PAR           reduce using rule 118 (empty -> .)

    params                         shift and go to state 42
    type                           shift and go to state 43
    empty                          shift and go to state 44

state 38

    (12) main -> MAIN np_set_curr_proc np_GOTO_END L_PAR R_PAR . vblock
    (26) vblock -> . L_BRACE vars vblockB R_BRACE
    (27) vblock -> . block
    (23) block -> . L_BRACE blockB R_BRACE

    L_BRACE         shift and go to state 46

    vblock                         shift and go to state 45
    block                          shift and go to state 47

state 39

    (7) varsB -> type np_set_curr_datatype COLON varsC . SEMICOLON
    (8) varsB -> type np_set_curr_datatype COLON varsC . SEMICOLON varsB

    SEMICOLON       shift and go to state 48


state 40

    (9) varsC -> var . np_add_var
    (10) varsC -> var . np_add_var COMMA varsC
    (129) np_add_var -> .

    COMMA           reduce using rule 129 (np_add_var -> .)
    SEMICOLON       reduce using rule 129 (np_add_var -> .)

    np_add_var                     shift and go to state 49

state 41

    (18) var -> ID . L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> ID .

    L_BRACKET       shift and go to state 50
    COMMA           reduce using rule 19 (var -> ID .)
    SEMICOLON       reduce using rule 19 (var -> ID .)
    EQUAL           reduce using rule 19 (var -> ID .)
    R_PAR           reduce using rule 19 (var -> ID .)


state 42

    (11) function -> FUNCTION func_type ID np_set_curr_proc L_PAR params . R_PAR np_set_quad_start vblock np_ENDFunc

    R_PAR           shift and go to state 51


state 43

    (30) params -> type . COLON ID np_add_param
    (31) params -> type . COLON ID np_add_param COMMA params

    COLON           shift and go to state 52


state 44

    (32) params -> empty .

    R_PAR           reduce using rule 32 (params -> empty .)


state 45

    (12) main -> MAIN np_set_curr_proc np_GOTO_END L_PAR R_PAR vblock .

    $end            reduce using rule 12 (main -> MAIN np_set_curr_proc np_GOTO_END L_PAR R_PAR vblock .)


state 46

    (26) vblock -> L_BRACE . vars vblockB R_BRACE
    (23) block -> L_BRACE . blockB R_BRACE
    (6) vars -> . VARS L_BRACE varsB R_BRACE
    (24) blockB -> . statement blockB
    (25) blockB -> . empty
    (33) statement -> . assign
    (34) statement -> . condicional
    (35) statement -> . read
    (36) statement -> . write
    (37) statement -> . loop_cond
    (38) statement -> . loop_range
    (39) statement -> . return
    (40) statement -> . void_func
    (118) empty -> .
    (42) assign -> . var np_push_operand oper_assign np_push_operator expression np_end SEMICOLON
    (57) condicional -> . IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END
    (60) read -> . READ L_PAR read2 R_PAR SEMICOLON
    (63) write -> . WRITE L_PAR writeB R_PAR SEMICOLON
    (68) loop_cond -> . WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE
    (69) loop_range -> . FOR var np_push_operand EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR
    (70) return -> . RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON
    (41) void_func -> . func_call SEMICOLON
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    VARS            shift and go to state 10
    R_BRACE         reduce using rule 118 (empty -> .)
    IF              shift and go to state 66
    READ            shift and go to state 67
    WRITE           shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70
    RETURN          shift and go to state 71
    ID              shift and go to state 73

    vars                           shift and go to state 53
    blockB                         shift and go to state 54
    statement                      shift and go to state 55
    empty                          shift and go to state 56
    assign                         shift and go to state 57
    condicional                    shift and go to state 58
    read                           shift and go to state 59
    write                          shift and go to state 60
    loop_cond                      shift and go to state 61
    loop_range                     shift and go to state 62
    return                         shift and go to state 63
    void_func                      shift and go to state 64
    var                            shift and go to state 65
    func_call                      shift and go to state 72

state 47

    (27) vblock -> block .

    $end            reduce using rule 27 (vblock -> block .)
    FUNCTION        reduce using rule 27 (vblock -> block .)
    MAIN            reduce using rule 27 (vblock -> block .)


state 48

    (7) varsB -> type np_set_curr_datatype COLON varsC SEMICOLON .
    (8) varsB -> type np_set_curr_datatype COLON varsC SEMICOLON . varsB
    (7) varsB -> . type np_set_curr_datatype COLON varsC SEMICOLON
    (8) varsB -> . type np_set_curr_datatype COLON varsC SEMICOLON varsB
    (13) type -> . INT
    (14) type -> . FLOAT
    (15) type -> . BOOL
    (16) type -> . CHAR
    (17) type -> . STRING

    R_BRACE         reduce using rule 7 (varsB -> type np_set_curr_datatype COLON varsC SEMICOLON .)
    INT             shift and go to state 22
    FLOAT           shift and go to state 23
    BOOL            shift and go to state 24
    CHAR            shift and go to state 25
    STRING          shift and go to state 26

    type                           shift and go to state 29
    varsB                          shift and go to state 74

state 49

    (9) varsC -> var np_add_var .
    (10) varsC -> var np_add_var . COMMA varsC

    SEMICOLON       reduce using rule 9 (varsC -> var np_add_var .)
    COMMA           shift and go to state 75


state 50

    (18) var -> ID L_BRACKET . np_arr_start exp np_end np_arr_end R_BRACKET
    (151) np_arr_start -> .

    L_PAR           reduce using rule 151 (np_arr_start -> .)
    MINUS           reduce using rule 151 (np_arr_start -> .)
    CTE_INT         reduce using rule 151 (np_arr_start -> .)
    CTE_FLOAT       reduce using rule 151 (np_arr_start -> .)
    CTE_CHAR        reduce using rule 151 (np_arr_start -> .)
    CTE_STRING      reduce using rule 151 (np_arr_start -> .)
    CTE_BOOL        reduce using rule 151 (np_arr_start -> .)
    ID              reduce using rule 151 (np_arr_start -> .)
    LENGTH          reduce using rule 151 (np_arr_start -> .)
    MIN             reduce using rule 151 (np_arr_start -> .)
    MAX             reduce using rule 151 (np_arr_start -> .)
    MEAN            reduce using rule 151 (np_arr_start -> .)
    MEDIAN          reduce using rule 151 (np_arr_start -> .)
    MODE            reduce using rule 151 (np_arr_start -> .)
    PLOT_XY         reduce using rule 151 (np_arr_start -> .)
    REGRESSION      reduce using rule 151 (np_arr_start -> .)
    VARIANCE        reduce using rule 151 (np_arr_start -> .)
    DOT             reduce using rule 151 (np_arr_start -> .)
    SUM             reduce using rule 151 (np_arr_start -> .)
    ABS             reduce using rule 151 (np_arr_start -> .)
    ROOF            reduce using rule 151 (np_arr_start -> .)
    FLOOR           reduce using rule 151 (np_arr_start -> .)

    np_arr_start                   shift and go to state 76

state 51

    (11) function -> FUNCTION func_type ID np_set_curr_proc L_PAR params R_PAR . np_set_quad_start vblock np_ENDFunc
    (146) np_set_quad_start -> .

    L_BRACE         reduce using rule 146 (np_set_quad_start -> .)

    np_set_quad_start              shift and go to state 77

state 52

    (30) params -> type COLON . ID np_add_param
    (31) params -> type COLON . ID np_add_param COMMA params

    ID              shift and go to state 78


state 53

    (26) vblock -> L_BRACE vars . vblockB R_BRACE
    (28) vblockB -> . statement vblockB
    (29) vblockB -> . empty
    (33) statement -> . assign
    (34) statement -> . condicional
    (35) statement -> . read
    (36) statement -> . write
    (37) statement -> . loop_cond
    (38) statement -> . loop_range
    (39) statement -> . return
    (40) statement -> . void_func
    (118) empty -> .
    (42) assign -> . var np_push_operand oper_assign np_push_operator expression np_end SEMICOLON
    (57) condicional -> . IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END
    (60) read -> . READ L_PAR read2 R_PAR SEMICOLON
    (63) write -> . WRITE L_PAR writeB R_PAR SEMICOLON
    (68) loop_cond -> . WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE
    (69) loop_range -> . FOR var np_push_operand EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR
    (70) return -> . RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON
    (41) void_func -> . func_call SEMICOLON
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    R_BRACE         reduce using rule 118 (empty -> .)
    IF              shift and go to state 66
    READ            shift and go to state 67
    WRITE           shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70
    RETURN          shift and go to state 71
    ID              shift and go to state 73

    vblockB                        shift and go to state 79
    statement                      shift and go to state 80
    empty                          shift and go to state 81
    assign                         shift and go to state 57
    condicional                    shift and go to state 58
    read                           shift and go to state 59
    write                          shift and go to state 60
    loop_cond                      shift and go to state 61
    loop_range                     shift and go to state 62
    return                         shift and go to state 63
    void_func                      shift and go to state 64
    var                            shift and go to state 65
    func_call                      shift and go to state 72

state 54

    (23) block -> L_BRACE blockB . R_BRACE

    R_BRACE         shift and go to state 82


state 55

    (24) blockB -> statement . blockB
    (24) blockB -> . statement blockB
    (25) blockB -> . empty
    (33) statement -> . assign
    (34) statement -> . condicional
    (35) statement -> . read
    (36) statement -> . write
    (37) statement -> . loop_cond
    (38) statement -> . loop_range
    (39) statement -> . return
    (40) statement -> . void_func
    (118) empty -> .
    (42) assign -> . var np_push_operand oper_assign np_push_operator expression np_end SEMICOLON
    (57) condicional -> . IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END
    (60) read -> . READ L_PAR read2 R_PAR SEMICOLON
    (63) write -> . WRITE L_PAR writeB R_PAR SEMICOLON
    (68) loop_cond -> . WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE
    (69) loop_range -> . FOR var np_push_operand EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR
    (70) return -> . RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON
    (41) void_func -> . func_call SEMICOLON
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    R_BRACE         reduce using rule 118 (empty -> .)
    IF              shift and go to state 66
    READ            shift and go to state 67
    WRITE           shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70
    RETURN          shift and go to state 71
    ID              shift and go to state 73

    statement                      shift and go to state 55
    blockB                         shift and go to state 83
    empty                          shift and go to state 56
    assign                         shift and go to state 57
    condicional                    shift and go to state 58
    read                           shift and go to state 59
    write                          shift and go to state 60
    loop_cond                      shift and go to state 61
    loop_range                     shift and go to state 62
    return                         shift and go to state 63
    void_func                      shift and go to state 64
    var                            shift and go to state 65
    func_call                      shift and go to state 72

state 56

    (25) blockB -> empty .

    R_BRACE         reduce using rule 25 (blockB -> empty .)


state 57

    (33) statement -> assign .

    IF              reduce using rule 33 (statement -> assign .)
    READ            reduce using rule 33 (statement -> assign .)
    WRITE           reduce using rule 33 (statement -> assign .)
    WHILE           reduce using rule 33 (statement -> assign .)
    FOR             reduce using rule 33 (statement -> assign .)
    RETURN          reduce using rule 33 (statement -> assign .)
    ID              reduce using rule 33 (statement -> assign .)
    R_BRACE         reduce using rule 33 (statement -> assign .)


state 58

    (34) statement -> condicional .

    IF              reduce using rule 34 (statement -> condicional .)
    READ            reduce using rule 34 (statement -> condicional .)
    WRITE           reduce using rule 34 (statement -> condicional .)
    WHILE           reduce using rule 34 (statement -> condicional .)
    FOR             reduce using rule 34 (statement -> condicional .)
    RETURN          reduce using rule 34 (statement -> condicional .)
    ID              reduce using rule 34 (statement -> condicional .)
    R_BRACE         reduce using rule 34 (statement -> condicional .)


state 59

    (35) statement -> read .

    IF              reduce using rule 35 (statement -> read .)
    READ            reduce using rule 35 (statement -> read .)
    WRITE           reduce using rule 35 (statement -> read .)
    WHILE           reduce using rule 35 (statement -> read .)
    FOR             reduce using rule 35 (statement -> read .)
    RETURN          reduce using rule 35 (statement -> read .)
    ID              reduce using rule 35 (statement -> read .)
    R_BRACE         reduce using rule 35 (statement -> read .)


state 60

    (36) statement -> write .

    IF              reduce using rule 36 (statement -> write .)
    READ            reduce using rule 36 (statement -> write .)
    WRITE           reduce using rule 36 (statement -> write .)
    WHILE           reduce using rule 36 (statement -> write .)
    FOR             reduce using rule 36 (statement -> write .)
    RETURN          reduce using rule 36 (statement -> write .)
    ID              reduce using rule 36 (statement -> write .)
    R_BRACE         reduce using rule 36 (statement -> write .)


state 61

    (37) statement -> loop_cond .

    IF              reduce using rule 37 (statement -> loop_cond .)
    READ            reduce using rule 37 (statement -> loop_cond .)
    WRITE           reduce using rule 37 (statement -> loop_cond .)
    WHILE           reduce using rule 37 (statement -> loop_cond .)
    FOR             reduce using rule 37 (statement -> loop_cond .)
    RETURN          reduce using rule 37 (statement -> loop_cond .)
    ID              reduce using rule 37 (statement -> loop_cond .)
    R_BRACE         reduce using rule 37 (statement -> loop_cond .)


state 62

    (38) statement -> loop_range .

    IF              reduce using rule 38 (statement -> loop_range .)
    READ            reduce using rule 38 (statement -> loop_range .)
    WRITE           reduce using rule 38 (statement -> loop_range .)
    WHILE           reduce using rule 38 (statement -> loop_range .)
    FOR             reduce using rule 38 (statement -> loop_range .)
    RETURN          reduce using rule 38 (statement -> loop_range .)
    ID              reduce using rule 38 (statement -> loop_range .)
    R_BRACE         reduce using rule 38 (statement -> loop_range .)


state 63

    (39) statement -> return .

    IF              reduce using rule 39 (statement -> return .)
    READ            reduce using rule 39 (statement -> return .)
    WRITE           reduce using rule 39 (statement -> return .)
    WHILE           reduce using rule 39 (statement -> return .)
    FOR             reduce using rule 39 (statement -> return .)
    RETURN          reduce using rule 39 (statement -> return .)
    ID              reduce using rule 39 (statement -> return .)
    R_BRACE         reduce using rule 39 (statement -> return .)


state 64

    (40) statement -> void_func .

    IF              reduce using rule 40 (statement -> void_func .)
    READ            reduce using rule 40 (statement -> void_func .)
    WRITE           reduce using rule 40 (statement -> void_func .)
    WHILE           reduce using rule 40 (statement -> void_func .)
    FOR             reduce using rule 40 (statement -> void_func .)
    RETURN          reduce using rule 40 (statement -> void_func .)
    ID              reduce using rule 40 (statement -> void_func .)
    R_BRACE         reduce using rule 40 (statement -> void_func .)


state 65

    (42) assign -> var . np_push_operand oper_assign np_push_operator expression np_end SEMICOLON
    (121) np_push_operand -> .

    EQUAL           reduce using rule 121 (np_push_operand -> .)
    MULT_EQ         reduce using rule 121 (np_push_operand -> .)
    DIV_EQ          reduce using rule 121 (np_push_operand -> .)
    PLUS_EQ         reduce using rule 121 (np_push_operand -> .)
    MINUS_EQ        reduce using rule 121 (np_push_operand -> .)

    np_push_operand                shift and go to state 84

state 66

    (57) condicional -> IF . L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END

    L_PAR           shift and go to state 85


state 67

    (60) read -> READ . L_PAR read2 R_PAR SEMICOLON

    L_PAR           shift and go to state 86


state 68

    (63) write -> WRITE . L_PAR writeB R_PAR SEMICOLON

    L_PAR           shift and go to state 87


state 69

    (68) loop_cond -> WHILE . L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE

    L_PAR           shift and go to state 88


state 70

    (69) loop_range -> FOR . var np_push_operand EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID

    ID              shift and go to state 41

    var                            shift and go to state 89

state 71

    (70) return -> RETURN . L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON

    L_PAR           shift and go to state 90


state 72

    (41) void_func -> func_call . SEMICOLON

    SEMICOLON       shift and go to state 91


state 73

    (18) var -> ID . L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> ID .
    (71) func_call -> ID . np_ERA L_PAR func_call_arguments R_PAR np_GOSUB
    (148) np_ERA -> .

    L_BRACKET       shift and go to state 50
    EQUAL           reduce using rule 19 (var -> ID .)
    MULT_EQ         reduce using rule 19 (var -> ID .)
    DIV_EQ          reduce using rule 19 (var -> ID .)
    PLUS_EQ         reduce using rule 19 (var -> ID .)
    MINUS_EQ        reduce using rule 19 (var -> ID .)
    EXP             reduce using rule 19 (var -> ID .)
    MULT            reduce using rule 19 (var -> ID .)
    DIV             reduce using rule 19 (var -> ID .)
    REMAINDER       reduce using rule 19 (var -> ID .)
    PLUS            reduce using rule 19 (var -> ID .)
    MINUS           reduce using rule 19 (var -> ID .)
    R_BRACKET       reduce using rule 19 (var -> ID .)
    LESS            reduce using rule 19 (var -> ID .)
    GREATER         reduce using rule 19 (var -> ID .)
    LESS_EQ         reduce using rule 19 (var -> ID .)
    GREATER_EQ      reduce using rule 19 (var -> ID .)
    EQUIVALENT      reduce using rule 19 (var -> ID .)
    DIFFERENT       reduce using rule 19 (var -> ID .)
    OR              reduce using rule 19 (var -> ID .)
    AND             reduce using rule 19 (var -> ID .)
    R_PAR           reduce using rule 19 (var -> ID .)
    COMMA           reduce using rule 19 (var -> ID .)
    SEMICOLON       reduce using rule 19 (var -> ID .)
    TO              reduce using rule 19 (var -> ID .)
    L_BRACE         reduce using rule 19 (var -> ID .)
    L_PAR           reduce using rule 148 (np_ERA -> .)

    np_ERA                         shift and go to state 92

state 74

    (8) varsB -> type np_set_curr_datatype COLON varsC SEMICOLON varsB .

    R_BRACE         reduce using rule 8 (varsB -> type np_set_curr_datatype COLON varsC SEMICOLON varsB .)


state 75

    (10) varsC -> var np_add_var COMMA . varsC
    (9) varsC -> . var np_add_var
    (10) varsC -> . var np_add_var COMMA varsC
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID

    ID              shift and go to state 41

    var                            shift and go to state 40
    varsC                          shift and go to state 93

state 76

    (18) var -> ID L_BRACKET np_arr_start . exp np_end np_arr_end R_BRACKET
    (94) exp -> . term exp2
    (98) term -> . factor term2
    (103) factor -> . exponent factorB
    (106) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (107) exponent -> . exponentB
    (108) exponentB -> . MINUS var_cte
    (109) exponentB -> . var_cte
    (110) var_cte -> . var np_push_operand
    (111) var_cte -> . predef_func
    (112) var_cte -> . func_call
    (113) var_cte -> . CTE_INT np_push_cte_int
    (114) var_cte -> . CTE_FLOAT np_push_cte_float
    (115) var_cte -> . CTE_CHAR np_push_cte_char
    (116) var_cte -> . CTE_STRING np_push_cte_str
    (117) var_cte -> . CTE_BOOL np_push_cte_bool
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (43) predef_func -> . LENGTH L_PAR vector R_PAR
    (44) predef_func -> . MIN L_PAR vector R_PAR
    (45) predef_func -> . MAX L_PAR vector R_PAR
    (46) predef_func -> . MEAN L_PAR vector R_PAR
    (47) predef_func -> . MEDIAN L_PAR vector R_PAR
    (48) predef_func -> . MODE L_PAR vector R_PAR
    (49) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (50) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . VARIANCE L_PAR vector R_PAR
    (52) predef_func -> . DOT L_PAR vector COMMA vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (54) predef_func -> . ABS L_PAR CTE_INT R_PAR
    (55) predef_func -> . ROOF L_PAR CTE_FLOAT R_PAR
    (56) predef_func -> . FLOOR L_PAR CTE_FLOAT R_PAR
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 98
    MINUS           shift and go to state 100
    CTE_INT         shift and go to state 105
    CTE_FLOAT       shift and go to state 106
    CTE_CHAR        shift and go to state 107
    CTE_STRING      shift and go to state 108
    CTE_BOOL        shift and go to state 109
    ID              shift and go to state 73
    LENGTH          shift and go to state 110
    MIN             shift and go to state 111
    MAX             shift and go to state 112
    MEAN            shift and go to state 113
    MEDIAN          shift and go to state 114
    MODE            shift and go to state 115
    PLOT_XY         shift and go to state 116
    REGRESSION      shift and go to state 117
    VARIANCE        shift and go to state 118
    DOT             shift and go to state 119
    SUM             shift and go to state 120
    ABS             shift and go to state 121
    ROOF            shift and go to state 122
    FLOOR           shift and go to state 123

    exp                            shift and go to state 94
    term                           shift and go to state 95
    factor                         shift and go to state 96
    exponent                       shift and go to state 97
    exponentB                      shift and go to state 99
    var_cte                        shift and go to state 101
    var                            shift and go to state 102
    predef_func                    shift and go to state 103
    func_call                      shift and go to state 104

state 77

    (11) function -> FUNCTION func_type ID np_set_curr_proc L_PAR params R_PAR np_set_quad_start . vblock np_ENDFunc
    (26) vblock -> . L_BRACE vars vblockB R_BRACE
    (27) vblock -> . block
    (23) block -> . L_BRACE blockB R_BRACE

    L_BRACE         shift and go to state 46

    vblock                         shift and go to state 124
    block                          shift and go to state 47

state 78

    (30) params -> type COLON ID . np_add_param
    (31) params -> type COLON ID . np_add_param COMMA params
    (145) np_add_param -> .

    COMMA           reduce using rule 145 (np_add_param -> .)
    R_PAR           reduce using rule 145 (np_add_param -> .)

    np_add_param                   shift and go to state 125

state 79

    (26) vblock -> L_BRACE vars vblockB . R_BRACE

    R_BRACE         shift and go to state 126


state 80

    (28) vblockB -> statement . vblockB
    (28) vblockB -> . statement vblockB
    (29) vblockB -> . empty
    (33) statement -> . assign
    (34) statement -> . condicional
    (35) statement -> . read
    (36) statement -> . write
    (37) statement -> . loop_cond
    (38) statement -> . loop_range
    (39) statement -> . return
    (40) statement -> . void_func
    (118) empty -> .
    (42) assign -> . var np_push_operand oper_assign np_push_operator expression np_end SEMICOLON
    (57) condicional -> . IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END
    (60) read -> . READ L_PAR read2 R_PAR SEMICOLON
    (63) write -> . WRITE L_PAR writeB R_PAR SEMICOLON
    (68) loop_cond -> . WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE
    (69) loop_range -> . FOR var np_push_operand EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR
    (70) return -> . RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON
    (41) void_func -> . func_call SEMICOLON
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    R_BRACE         reduce using rule 118 (empty -> .)
    IF              shift and go to state 66
    READ            shift and go to state 67
    WRITE           shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70
    RETURN          shift and go to state 71
    ID              shift and go to state 73

    statement                      shift and go to state 80
    vblockB                        shift and go to state 127
    empty                          shift and go to state 81
    assign                         shift and go to state 57
    condicional                    shift and go to state 58
    read                           shift and go to state 59
    write                          shift and go to state 60
    loop_cond                      shift and go to state 61
    loop_range                     shift and go to state 62
    return                         shift and go to state 63
    void_func                      shift and go to state 64
    var                            shift and go to state 65
    func_call                      shift and go to state 72

state 81

    (29) vblockB -> empty .

    R_BRACE         reduce using rule 29 (vblockB -> empty .)


state 82

    (23) block -> L_BRACE blockB R_BRACE .

    $end            reduce using rule 23 (block -> L_BRACE blockB R_BRACE .)
    FUNCTION        reduce using rule 23 (block -> L_BRACE blockB R_BRACE .)
    MAIN            reduce using rule 23 (block -> L_BRACE blockB R_BRACE .)
    ELSE            reduce using rule 23 (block -> L_BRACE blockB R_BRACE .)
    IF              reduce using rule 23 (block -> L_BRACE blockB R_BRACE .)
    READ            reduce using rule 23 (block -> L_BRACE blockB R_BRACE .)
    WRITE           reduce using rule 23 (block -> L_BRACE blockB R_BRACE .)
    WHILE           reduce using rule 23 (block -> L_BRACE blockB R_BRACE .)
    FOR             reduce using rule 23 (block -> L_BRACE blockB R_BRACE .)
    RETURN          reduce using rule 23 (block -> L_BRACE blockB R_BRACE .)
    ID              reduce using rule 23 (block -> L_BRACE blockB R_BRACE .)
    R_BRACE         reduce using rule 23 (block -> L_BRACE blockB R_BRACE .)


state 83

    (24) blockB -> statement blockB .

    R_BRACE         reduce using rule 24 (blockB -> statement blockB .)


state 84

    (42) assign -> var np_push_operand . oper_assign np_push_operator expression np_end SEMICOLON
    (79) oper_assign -> . EQUAL
    (80) oper_assign -> . MULT_EQ
    (81) oper_assign -> . DIV_EQ
    (82) oper_assign -> . PLUS_EQ
    (83) oper_assign -> . MINUS_EQ

    EQUAL           shift and go to state 129
    MULT_EQ         shift and go to state 130
    DIV_EQ          shift and go to state 131
    PLUS_EQ         shift and go to state 132
    MINUS_EQ        shift and go to state 133

    oper_assign                    shift and go to state 128

state 85

    (57) condicional -> IF L_PAR . expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END
    (75) expression -> . not logic expressionB
    (84) not -> . NOT np_push_operator
    (85) not -> . empty
    (118) empty -> .

    NOT             shift and go to state 136
    L_PAR           reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    CTE_INT         reduce using rule 118 (empty -> .)
    CTE_FLOAT       reduce using rule 118 (empty -> .)
    CTE_CHAR        reduce using rule 118 (empty -> .)
    CTE_STRING      reduce using rule 118 (empty -> .)
    CTE_BOOL        reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    LENGTH          reduce using rule 118 (empty -> .)
    MIN             reduce using rule 118 (empty -> .)
    MAX             reduce using rule 118 (empty -> .)
    MEAN            reduce using rule 118 (empty -> .)
    MEDIAN          reduce using rule 118 (empty -> .)
    MODE            reduce using rule 118 (empty -> .)
    PLOT_XY         reduce using rule 118 (empty -> .)
    REGRESSION      reduce using rule 118 (empty -> .)
    VARIANCE        reduce using rule 118 (empty -> .)
    DOT             reduce using rule 118 (empty -> .)
    SUM             reduce using rule 118 (empty -> .)
    ABS             reduce using rule 118 (empty -> .)
    ROOF            reduce using rule 118 (empty -> .)
    FLOOR           reduce using rule 118 (empty -> .)

    expression                     shift and go to state 134
    not                            shift and go to state 135
    empty                          shift and go to state 137

state 86

    (60) read -> READ L_PAR . read2 R_PAR SEMICOLON
    (61) read2 -> . var np_read
    (62) read2 -> . var np_read COMMA read2
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID

    ID              shift and go to state 41

    read2                          shift and go to state 138
    var                            shift and go to state 139

state 87

    (63) write -> WRITE L_PAR . writeB R_PAR SEMICOLON
    (64) writeB -> . expression np_end np_write writeC
    (65) writeB -> . CTE_STRING np_push_cte_str np_write writeC
    (75) expression -> . not logic expressionB
    (84) not -> . NOT np_push_operator
    (85) not -> . empty
    (118) empty -> .

  ! shift/reduce conflict for CTE_STRING resolved as shift
    CTE_STRING      shift and go to state 142
    NOT             shift and go to state 136
    L_PAR           reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    CTE_INT         reduce using rule 118 (empty -> .)
    CTE_FLOAT       reduce using rule 118 (empty -> .)
    CTE_CHAR        reduce using rule 118 (empty -> .)
    CTE_BOOL        reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    LENGTH          reduce using rule 118 (empty -> .)
    MIN             reduce using rule 118 (empty -> .)
    MAX             reduce using rule 118 (empty -> .)
    MEAN            reduce using rule 118 (empty -> .)
    MEDIAN          reduce using rule 118 (empty -> .)
    MODE            reduce using rule 118 (empty -> .)
    PLOT_XY         reduce using rule 118 (empty -> .)
    REGRESSION      reduce using rule 118 (empty -> .)
    VARIANCE        reduce using rule 118 (empty -> .)
    DOT             reduce using rule 118 (empty -> .)
    SUM             reduce using rule 118 (empty -> .)
    ABS             reduce using rule 118 (empty -> .)
    ROOF            reduce using rule 118 (empty -> .)
    FLOOR           reduce using rule 118 (empty -> .)

  ! CTE_STRING      [ reduce using rule 118 (empty -> .) ]

    writeB                         shift and go to state 140
    expression                     shift and go to state 141
    not                            shift and go to state 135
    empty                          shift and go to state 137

state 88

    (68) loop_cond -> WHILE L_PAR . np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE
    (144) np_CHECKPOINT -> .

    NOT             reduce using rule 144 (np_CHECKPOINT -> .)
    L_PAR           reduce using rule 144 (np_CHECKPOINT -> .)
    MINUS           reduce using rule 144 (np_CHECKPOINT -> .)
    CTE_INT         reduce using rule 144 (np_CHECKPOINT -> .)
    CTE_FLOAT       reduce using rule 144 (np_CHECKPOINT -> .)
    CTE_CHAR        reduce using rule 144 (np_CHECKPOINT -> .)
    CTE_STRING      reduce using rule 144 (np_CHECKPOINT -> .)
    CTE_BOOL        reduce using rule 144 (np_CHECKPOINT -> .)
    ID              reduce using rule 144 (np_CHECKPOINT -> .)
    LENGTH          reduce using rule 144 (np_CHECKPOINT -> .)
    MIN             reduce using rule 144 (np_CHECKPOINT -> .)
    MAX             reduce using rule 144 (np_CHECKPOINT -> .)
    MEAN            reduce using rule 144 (np_CHECKPOINT -> .)
    MEDIAN          reduce using rule 144 (np_CHECKPOINT -> .)
    MODE            reduce using rule 144 (np_CHECKPOINT -> .)
    PLOT_XY         reduce using rule 144 (np_CHECKPOINT -> .)
    REGRESSION      reduce using rule 144 (np_CHECKPOINT -> .)
    VARIANCE        reduce using rule 144 (np_CHECKPOINT -> .)
    DOT             reduce using rule 144 (np_CHECKPOINT -> .)
    SUM             reduce using rule 144 (np_CHECKPOINT -> .)
    ABS             reduce using rule 144 (np_CHECKPOINT -> .)
    ROOF            reduce using rule 144 (np_CHECKPOINT -> .)
    FLOOR           reduce using rule 144 (np_CHECKPOINT -> .)

    np_CHECKPOINT                  shift and go to state 143

state 89

    (69) loop_range -> FOR var . np_push_operand EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR
    (121) np_push_operand -> .

    EQUAL           reduce using rule 121 (np_push_operand -> .)

    np_push_operand                shift and go to state 144

state 90

    (70) return -> RETURN L_PAR . np_stop exp np_end np_set_return R_PAR SEMICOLON
    (153) np_stop -> .

    L_PAR           reduce using rule 153 (np_stop -> .)
    MINUS           reduce using rule 153 (np_stop -> .)
    CTE_INT         reduce using rule 153 (np_stop -> .)
    CTE_FLOAT       reduce using rule 153 (np_stop -> .)
    CTE_CHAR        reduce using rule 153 (np_stop -> .)
    CTE_STRING      reduce using rule 153 (np_stop -> .)
    CTE_BOOL        reduce using rule 153 (np_stop -> .)
    ID              reduce using rule 153 (np_stop -> .)
    LENGTH          reduce using rule 153 (np_stop -> .)
    MIN             reduce using rule 153 (np_stop -> .)
    MAX             reduce using rule 153 (np_stop -> .)
    MEAN            reduce using rule 153 (np_stop -> .)
    MEDIAN          reduce using rule 153 (np_stop -> .)
    MODE            reduce using rule 153 (np_stop -> .)
    PLOT_XY         reduce using rule 153 (np_stop -> .)
    REGRESSION      reduce using rule 153 (np_stop -> .)
    VARIANCE        reduce using rule 153 (np_stop -> .)
    DOT             reduce using rule 153 (np_stop -> .)
    SUM             reduce using rule 153 (np_stop -> .)
    ABS             reduce using rule 153 (np_stop -> .)
    ROOF            reduce using rule 153 (np_stop -> .)
    FLOOR           reduce using rule 153 (np_stop -> .)

    np_stop                        shift and go to state 145

state 91

    (41) void_func -> func_call SEMICOLON .

    IF              reduce using rule 41 (void_func -> func_call SEMICOLON .)
    READ            reduce using rule 41 (void_func -> func_call SEMICOLON .)
    WRITE           reduce using rule 41 (void_func -> func_call SEMICOLON .)
    WHILE           reduce using rule 41 (void_func -> func_call SEMICOLON .)
    FOR             reduce using rule 41 (void_func -> func_call SEMICOLON .)
    RETURN          reduce using rule 41 (void_func -> func_call SEMICOLON .)
    ID              reduce using rule 41 (void_func -> func_call SEMICOLON .)
    R_BRACE         reduce using rule 41 (void_func -> func_call SEMICOLON .)


state 92

    (71) func_call -> ID np_ERA . L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 146


state 93

    (10) varsC -> var np_add_var COMMA varsC .

    SEMICOLON       reduce using rule 10 (varsC -> var np_add_var COMMA varsC .)


state 94

    (18) var -> ID L_BRACKET np_arr_start exp . np_end np_arr_end R_BRACKET
    (133) np_end -> .

    R_BRACKET       reduce using rule 133 (np_end -> .)

    np_end                         shift and go to state 147

state 95

    (94) exp -> term . exp2
    (95) exp2 -> . PLUS np_push_operator exp
    (96) exp2 -> . MINUS np_push_operator exp
    (97) exp2 -> . empty
    (118) empty -> .

    PLUS            shift and go to state 149
    MINUS           shift and go to state 150
    R_BRACKET       reduce using rule 118 (empty -> .)
    LESS            reduce using rule 118 (empty -> .)
    GREATER         reduce using rule 118 (empty -> .)
    LESS_EQ         reduce using rule 118 (empty -> .)
    GREATER_EQ      reduce using rule 118 (empty -> .)
    EQUIVALENT      reduce using rule 118 (empty -> .)
    DIFFERENT       reduce using rule 118 (empty -> .)
    OR              reduce using rule 118 (empty -> .)
    AND             reduce using rule 118 (empty -> .)
    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    L_BRACE         reduce using rule 118 (empty -> .)

    exp2                           shift and go to state 148
    empty                          shift and go to state 151

state 96

    (98) term -> factor . term2
    (99) term2 -> . MULT np_push_operator term
    (100) term2 -> . DIV np_push_operator term
    (101) term2 -> . REMAINDER np_push_operator term
    (102) term2 -> . empty
    (118) empty -> .

    MULT            shift and go to state 153
    DIV             shift and go to state 154
    REMAINDER       shift and go to state 155
    PLUS            reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    R_BRACKET       reduce using rule 118 (empty -> .)
    LESS            reduce using rule 118 (empty -> .)
    GREATER         reduce using rule 118 (empty -> .)
    LESS_EQ         reduce using rule 118 (empty -> .)
    GREATER_EQ      reduce using rule 118 (empty -> .)
    EQUIVALENT      reduce using rule 118 (empty -> .)
    DIFFERENT       reduce using rule 118 (empty -> .)
    OR              reduce using rule 118 (empty -> .)
    AND             reduce using rule 118 (empty -> .)
    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    L_BRACE         reduce using rule 118 (empty -> .)

    term2                          shift and go to state 152
    empty                          shift and go to state 156

state 97

    (103) factor -> exponent . factorB
    (104) factorB -> . EXP factor
    (105) factorB -> . empty
    (118) empty -> .

    EXP             shift and go to state 158
    MULT            reduce using rule 118 (empty -> .)
    DIV             reduce using rule 118 (empty -> .)
    REMAINDER       reduce using rule 118 (empty -> .)
    PLUS            reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    R_BRACKET       reduce using rule 118 (empty -> .)
    LESS            reduce using rule 118 (empty -> .)
    GREATER         reduce using rule 118 (empty -> .)
    LESS_EQ         reduce using rule 118 (empty -> .)
    GREATER_EQ      reduce using rule 118 (empty -> .)
    EQUIVALENT      reduce using rule 118 (empty -> .)
    DIFFERENT       reduce using rule 118 (empty -> .)
    OR              reduce using rule 118 (empty -> .)
    AND             reduce using rule 118 (empty -> .)
    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    L_BRACE         reduce using rule 118 (empty -> .)

    factorB                        shift and go to state 157
    empty                          shift and go to state 159

state 98

    (106) exponent -> L_PAR . np_push_operator expression R_PAR np_rpar
    (120) np_push_operator -> .

    NOT             reduce using rule 120 (np_push_operator -> .)
    L_PAR           reduce using rule 120 (np_push_operator -> .)
    MINUS           reduce using rule 120 (np_push_operator -> .)
    CTE_INT         reduce using rule 120 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 120 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 120 (np_push_operator -> .)
    CTE_STRING      reduce using rule 120 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 120 (np_push_operator -> .)
    ID              reduce using rule 120 (np_push_operator -> .)
    LENGTH          reduce using rule 120 (np_push_operator -> .)
    MIN             reduce using rule 120 (np_push_operator -> .)
    MAX             reduce using rule 120 (np_push_operator -> .)
    MEAN            reduce using rule 120 (np_push_operator -> .)
    MEDIAN          reduce using rule 120 (np_push_operator -> .)
    MODE            reduce using rule 120 (np_push_operator -> .)
    PLOT_XY         reduce using rule 120 (np_push_operator -> .)
    REGRESSION      reduce using rule 120 (np_push_operator -> .)
    VARIANCE        reduce using rule 120 (np_push_operator -> .)
    DOT             reduce using rule 120 (np_push_operator -> .)
    SUM             reduce using rule 120 (np_push_operator -> .)
    ABS             reduce using rule 120 (np_push_operator -> .)
    ROOF            reduce using rule 120 (np_push_operator -> .)
    FLOOR           reduce using rule 120 (np_push_operator -> .)

    np_push_operator               shift and go to state 160

state 99

    (107) exponent -> exponentB .

    EXP             reduce using rule 107 (exponent -> exponentB .)
    MULT            reduce using rule 107 (exponent -> exponentB .)
    DIV             reduce using rule 107 (exponent -> exponentB .)
    REMAINDER       reduce using rule 107 (exponent -> exponentB .)
    PLUS            reduce using rule 107 (exponent -> exponentB .)
    MINUS           reduce using rule 107 (exponent -> exponentB .)
    R_BRACKET       reduce using rule 107 (exponent -> exponentB .)
    LESS            reduce using rule 107 (exponent -> exponentB .)
    GREATER         reduce using rule 107 (exponent -> exponentB .)
    LESS_EQ         reduce using rule 107 (exponent -> exponentB .)
    GREATER_EQ      reduce using rule 107 (exponent -> exponentB .)
    EQUIVALENT      reduce using rule 107 (exponent -> exponentB .)
    DIFFERENT       reduce using rule 107 (exponent -> exponentB .)
    OR              reduce using rule 107 (exponent -> exponentB .)
    AND             reduce using rule 107 (exponent -> exponentB .)
    R_PAR           reduce using rule 107 (exponent -> exponentB .)
    COMMA           reduce using rule 107 (exponent -> exponentB .)
    SEMICOLON       reduce using rule 107 (exponent -> exponentB .)
    TO              reduce using rule 107 (exponent -> exponentB .)
    L_BRACE         reduce using rule 107 (exponent -> exponentB .)


state 100

    (108) exponentB -> MINUS . var_cte
    (110) var_cte -> . var np_push_operand
    (111) var_cte -> . predef_func
    (112) var_cte -> . func_call
    (113) var_cte -> . CTE_INT np_push_cte_int
    (114) var_cte -> . CTE_FLOAT np_push_cte_float
    (115) var_cte -> . CTE_CHAR np_push_cte_char
    (116) var_cte -> . CTE_STRING np_push_cte_str
    (117) var_cte -> . CTE_BOOL np_push_cte_bool
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (43) predef_func -> . LENGTH L_PAR vector R_PAR
    (44) predef_func -> . MIN L_PAR vector R_PAR
    (45) predef_func -> . MAX L_PAR vector R_PAR
    (46) predef_func -> . MEAN L_PAR vector R_PAR
    (47) predef_func -> . MEDIAN L_PAR vector R_PAR
    (48) predef_func -> . MODE L_PAR vector R_PAR
    (49) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (50) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . VARIANCE L_PAR vector R_PAR
    (52) predef_func -> . DOT L_PAR vector COMMA vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (54) predef_func -> . ABS L_PAR CTE_INT R_PAR
    (55) predef_func -> . ROOF L_PAR CTE_FLOAT R_PAR
    (56) predef_func -> . FLOOR L_PAR CTE_FLOAT R_PAR
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    CTE_INT         shift and go to state 105
    CTE_FLOAT       shift and go to state 106
    CTE_CHAR        shift and go to state 107
    CTE_STRING      shift and go to state 108
    CTE_BOOL        shift and go to state 109
    ID              shift and go to state 73
    LENGTH          shift and go to state 110
    MIN             shift and go to state 111
    MAX             shift and go to state 112
    MEAN            shift and go to state 113
    MEDIAN          shift and go to state 114
    MODE            shift and go to state 115
    PLOT_XY         shift and go to state 116
    REGRESSION      shift and go to state 117
    VARIANCE        shift and go to state 118
    DOT             shift and go to state 119
    SUM             shift and go to state 120
    ABS             shift and go to state 121
    ROOF            shift and go to state 122
    FLOOR           shift and go to state 123

    var_cte                        shift and go to state 161
    var                            shift and go to state 102
    predef_func                    shift and go to state 103
    func_call                      shift and go to state 104

state 101

    (109) exponentB -> var_cte .

    EXP             reduce using rule 109 (exponentB -> var_cte .)
    MULT            reduce using rule 109 (exponentB -> var_cte .)
    DIV             reduce using rule 109 (exponentB -> var_cte .)
    REMAINDER       reduce using rule 109 (exponentB -> var_cte .)
    PLUS            reduce using rule 109 (exponentB -> var_cte .)
    MINUS           reduce using rule 109 (exponentB -> var_cte .)
    R_BRACKET       reduce using rule 109 (exponentB -> var_cte .)
    LESS            reduce using rule 109 (exponentB -> var_cte .)
    GREATER         reduce using rule 109 (exponentB -> var_cte .)
    LESS_EQ         reduce using rule 109 (exponentB -> var_cte .)
    GREATER_EQ      reduce using rule 109 (exponentB -> var_cte .)
    EQUIVALENT      reduce using rule 109 (exponentB -> var_cte .)
    DIFFERENT       reduce using rule 109 (exponentB -> var_cte .)
    OR              reduce using rule 109 (exponentB -> var_cte .)
    AND             reduce using rule 109 (exponentB -> var_cte .)
    R_PAR           reduce using rule 109 (exponentB -> var_cte .)
    COMMA           reduce using rule 109 (exponentB -> var_cte .)
    SEMICOLON       reduce using rule 109 (exponentB -> var_cte .)
    TO              reduce using rule 109 (exponentB -> var_cte .)
    L_BRACE         reduce using rule 109 (exponentB -> var_cte .)


state 102

    (110) var_cte -> var . np_push_operand
    (121) np_push_operand -> .

    EXP             reduce using rule 121 (np_push_operand -> .)
    MULT            reduce using rule 121 (np_push_operand -> .)
    DIV             reduce using rule 121 (np_push_operand -> .)
    REMAINDER       reduce using rule 121 (np_push_operand -> .)
    PLUS            reduce using rule 121 (np_push_operand -> .)
    MINUS           reduce using rule 121 (np_push_operand -> .)
    R_BRACKET       reduce using rule 121 (np_push_operand -> .)
    LESS            reduce using rule 121 (np_push_operand -> .)
    GREATER         reduce using rule 121 (np_push_operand -> .)
    LESS_EQ         reduce using rule 121 (np_push_operand -> .)
    GREATER_EQ      reduce using rule 121 (np_push_operand -> .)
    EQUIVALENT      reduce using rule 121 (np_push_operand -> .)
    DIFFERENT       reduce using rule 121 (np_push_operand -> .)
    OR              reduce using rule 121 (np_push_operand -> .)
    AND             reduce using rule 121 (np_push_operand -> .)
    R_PAR           reduce using rule 121 (np_push_operand -> .)
    COMMA           reduce using rule 121 (np_push_operand -> .)
    SEMICOLON       reduce using rule 121 (np_push_operand -> .)
    TO              reduce using rule 121 (np_push_operand -> .)
    L_BRACE         reduce using rule 121 (np_push_operand -> .)

    np_push_operand                shift and go to state 162

state 103

    (111) var_cte -> predef_func .

    EXP             reduce using rule 111 (var_cte -> predef_func .)
    MULT            reduce using rule 111 (var_cte -> predef_func .)
    DIV             reduce using rule 111 (var_cte -> predef_func .)
    REMAINDER       reduce using rule 111 (var_cte -> predef_func .)
    PLUS            reduce using rule 111 (var_cte -> predef_func .)
    MINUS           reduce using rule 111 (var_cte -> predef_func .)
    R_BRACKET       reduce using rule 111 (var_cte -> predef_func .)
    LESS            reduce using rule 111 (var_cte -> predef_func .)
    GREATER         reduce using rule 111 (var_cte -> predef_func .)
    LESS_EQ         reduce using rule 111 (var_cte -> predef_func .)
    GREATER_EQ      reduce using rule 111 (var_cte -> predef_func .)
    EQUIVALENT      reduce using rule 111 (var_cte -> predef_func .)
    DIFFERENT       reduce using rule 111 (var_cte -> predef_func .)
    OR              reduce using rule 111 (var_cte -> predef_func .)
    AND             reduce using rule 111 (var_cte -> predef_func .)
    R_PAR           reduce using rule 111 (var_cte -> predef_func .)
    COMMA           reduce using rule 111 (var_cte -> predef_func .)
    SEMICOLON       reduce using rule 111 (var_cte -> predef_func .)
    TO              reduce using rule 111 (var_cte -> predef_func .)
    L_BRACE         reduce using rule 111 (var_cte -> predef_func .)


state 104

    (112) var_cte -> func_call .

    EXP             reduce using rule 112 (var_cte -> func_call .)
    MULT            reduce using rule 112 (var_cte -> func_call .)
    DIV             reduce using rule 112 (var_cte -> func_call .)
    REMAINDER       reduce using rule 112 (var_cte -> func_call .)
    PLUS            reduce using rule 112 (var_cte -> func_call .)
    MINUS           reduce using rule 112 (var_cte -> func_call .)
    R_BRACKET       reduce using rule 112 (var_cte -> func_call .)
    LESS            reduce using rule 112 (var_cte -> func_call .)
    GREATER         reduce using rule 112 (var_cte -> func_call .)
    LESS_EQ         reduce using rule 112 (var_cte -> func_call .)
    GREATER_EQ      reduce using rule 112 (var_cte -> func_call .)
    EQUIVALENT      reduce using rule 112 (var_cte -> func_call .)
    DIFFERENT       reduce using rule 112 (var_cte -> func_call .)
    OR              reduce using rule 112 (var_cte -> func_call .)
    AND             reduce using rule 112 (var_cte -> func_call .)
    R_PAR           reduce using rule 112 (var_cte -> func_call .)
    COMMA           reduce using rule 112 (var_cte -> func_call .)
    SEMICOLON       reduce using rule 112 (var_cte -> func_call .)
    TO              reduce using rule 112 (var_cte -> func_call .)
    L_BRACE         reduce using rule 112 (var_cte -> func_call .)


state 105

    (113) var_cte -> CTE_INT . np_push_cte_int
    (122) np_push_cte_int -> .

    EXP             reduce using rule 122 (np_push_cte_int -> .)
    MULT            reduce using rule 122 (np_push_cte_int -> .)
    DIV             reduce using rule 122 (np_push_cte_int -> .)
    REMAINDER       reduce using rule 122 (np_push_cte_int -> .)
    PLUS            reduce using rule 122 (np_push_cte_int -> .)
    MINUS           reduce using rule 122 (np_push_cte_int -> .)
    R_BRACKET       reduce using rule 122 (np_push_cte_int -> .)
    LESS            reduce using rule 122 (np_push_cte_int -> .)
    GREATER         reduce using rule 122 (np_push_cte_int -> .)
    LESS_EQ         reduce using rule 122 (np_push_cte_int -> .)
    GREATER_EQ      reduce using rule 122 (np_push_cte_int -> .)
    EQUIVALENT      reduce using rule 122 (np_push_cte_int -> .)
    DIFFERENT       reduce using rule 122 (np_push_cte_int -> .)
    OR              reduce using rule 122 (np_push_cte_int -> .)
    AND             reduce using rule 122 (np_push_cte_int -> .)
    R_PAR           reduce using rule 122 (np_push_cte_int -> .)
    COMMA           reduce using rule 122 (np_push_cte_int -> .)
    SEMICOLON       reduce using rule 122 (np_push_cte_int -> .)
    TO              reduce using rule 122 (np_push_cte_int -> .)
    L_BRACE         reduce using rule 122 (np_push_cte_int -> .)

    np_push_cte_int                shift and go to state 163

state 106

    (114) var_cte -> CTE_FLOAT . np_push_cte_float
    (123) np_push_cte_float -> .

    EXP             reduce using rule 123 (np_push_cte_float -> .)
    MULT            reduce using rule 123 (np_push_cte_float -> .)
    DIV             reduce using rule 123 (np_push_cte_float -> .)
    REMAINDER       reduce using rule 123 (np_push_cte_float -> .)
    PLUS            reduce using rule 123 (np_push_cte_float -> .)
    MINUS           reduce using rule 123 (np_push_cte_float -> .)
    R_BRACKET       reduce using rule 123 (np_push_cte_float -> .)
    LESS            reduce using rule 123 (np_push_cte_float -> .)
    GREATER         reduce using rule 123 (np_push_cte_float -> .)
    LESS_EQ         reduce using rule 123 (np_push_cte_float -> .)
    GREATER_EQ      reduce using rule 123 (np_push_cte_float -> .)
    EQUIVALENT      reduce using rule 123 (np_push_cte_float -> .)
    DIFFERENT       reduce using rule 123 (np_push_cte_float -> .)
    OR              reduce using rule 123 (np_push_cte_float -> .)
    AND             reduce using rule 123 (np_push_cte_float -> .)
    R_PAR           reduce using rule 123 (np_push_cte_float -> .)
    COMMA           reduce using rule 123 (np_push_cte_float -> .)
    SEMICOLON       reduce using rule 123 (np_push_cte_float -> .)
    TO              reduce using rule 123 (np_push_cte_float -> .)
    L_BRACE         reduce using rule 123 (np_push_cte_float -> .)

    np_push_cte_float              shift and go to state 164

state 107

    (115) var_cte -> CTE_CHAR . np_push_cte_char
    (124) np_push_cte_char -> .

    EXP             reduce using rule 124 (np_push_cte_char -> .)
    MULT            reduce using rule 124 (np_push_cte_char -> .)
    DIV             reduce using rule 124 (np_push_cte_char -> .)
    REMAINDER       reduce using rule 124 (np_push_cte_char -> .)
    PLUS            reduce using rule 124 (np_push_cte_char -> .)
    MINUS           reduce using rule 124 (np_push_cte_char -> .)
    R_BRACKET       reduce using rule 124 (np_push_cte_char -> .)
    LESS            reduce using rule 124 (np_push_cte_char -> .)
    GREATER         reduce using rule 124 (np_push_cte_char -> .)
    LESS_EQ         reduce using rule 124 (np_push_cte_char -> .)
    GREATER_EQ      reduce using rule 124 (np_push_cte_char -> .)
    EQUIVALENT      reduce using rule 124 (np_push_cte_char -> .)
    DIFFERENT       reduce using rule 124 (np_push_cte_char -> .)
    OR              reduce using rule 124 (np_push_cte_char -> .)
    AND             reduce using rule 124 (np_push_cte_char -> .)
    R_PAR           reduce using rule 124 (np_push_cte_char -> .)
    COMMA           reduce using rule 124 (np_push_cte_char -> .)
    SEMICOLON       reduce using rule 124 (np_push_cte_char -> .)
    TO              reduce using rule 124 (np_push_cte_char -> .)
    L_BRACE         reduce using rule 124 (np_push_cte_char -> .)

    np_push_cte_char               shift and go to state 165

state 108

    (116) var_cte -> CTE_STRING . np_push_cte_str
    (125) np_push_cte_str -> .

    EXP             reduce using rule 125 (np_push_cte_str -> .)
    MULT            reduce using rule 125 (np_push_cte_str -> .)
    DIV             reduce using rule 125 (np_push_cte_str -> .)
    REMAINDER       reduce using rule 125 (np_push_cte_str -> .)
    PLUS            reduce using rule 125 (np_push_cte_str -> .)
    MINUS           reduce using rule 125 (np_push_cte_str -> .)
    R_BRACKET       reduce using rule 125 (np_push_cte_str -> .)
    LESS            reduce using rule 125 (np_push_cte_str -> .)
    GREATER         reduce using rule 125 (np_push_cte_str -> .)
    LESS_EQ         reduce using rule 125 (np_push_cte_str -> .)
    GREATER_EQ      reduce using rule 125 (np_push_cte_str -> .)
    EQUIVALENT      reduce using rule 125 (np_push_cte_str -> .)
    DIFFERENT       reduce using rule 125 (np_push_cte_str -> .)
    OR              reduce using rule 125 (np_push_cte_str -> .)
    AND             reduce using rule 125 (np_push_cte_str -> .)
    R_PAR           reduce using rule 125 (np_push_cte_str -> .)
    COMMA           reduce using rule 125 (np_push_cte_str -> .)
    SEMICOLON       reduce using rule 125 (np_push_cte_str -> .)
    TO              reduce using rule 125 (np_push_cte_str -> .)
    L_BRACE         reduce using rule 125 (np_push_cte_str -> .)

    np_push_cte_str                shift and go to state 166

state 109

    (117) var_cte -> CTE_BOOL . np_push_cte_bool
    (126) np_push_cte_bool -> .

    EXP             reduce using rule 126 (np_push_cte_bool -> .)
    MULT            reduce using rule 126 (np_push_cte_bool -> .)
    DIV             reduce using rule 126 (np_push_cte_bool -> .)
    REMAINDER       reduce using rule 126 (np_push_cte_bool -> .)
    PLUS            reduce using rule 126 (np_push_cte_bool -> .)
    MINUS           reduce using rule 126 (np_push_cte_bool -> .)
    R_BRACKET       reduce using rule 126 (np_push_cte_bool -> .)
    LESS            reduce using rule 126 (np_push_cte_bool -> .)
    GREATER         reduce using rule 126 (np_push_cte_bool -> .)
    LESS_EQ         reduce using rule 126 (np_push_cte_bool -> .)
    GREATER_EQ      reduce using rule 126 (np_push_cte_bool -> .)
    EQUIVALENT      reduce using rule 126 (np_push_cte_bool -> .)
    DIFFERENT       reduce using rule 126 (np_push_cte_bool -> .)
    OR              reduce using rule 126 (np_push_cte_bool -> .)
    AND             reduce using rule 126 (np_push_cte_bool -> .)
    R_PAR           reduce using rule 126 (np_push_cte_bool -> .)
    COMMA           reduce using rule 126 (np_push_cte_bool -> .)
    SEMICOLON       reduce using rule 126 (np_push_cte_bool -> .)
    TO              reduce using rule 126 (np_push_cte_bool -> .)
    L_BRACE         reduce using rule 126 (np_push_cte_bool -> .)

    np_push_cte_bool               shift and go to state 167

state 110

    (43) predef_func -> LENGTH . L_PAR vector R_PAR

    L_PAR           shift and go to state 168


state 111

    (44) predef_func -> MIN . L_PAR vector R_PAR

    L_PAR           shift and go to state 169


state 112

    (45) predef_func -> MAX . L_PAR vector R_PAR

    L_PAR           shift and go to state 170


state 113

    (46) predef_func -> MEAN . L_PAR vector R_PAR

    L_PAR           shift and go to state 171


state 114

    (47) predef_func -> MEDIAN . L_PAR vector R_PAR

    L_PAR           shift and go to state 172


state 115

    (48) predef_func -> MODE . L_PAR vector R_PAR

    L_PAR           shift and go to state 173


state 116

    (49) predef_func -> PLOT_XY . L_PAR vector COMMA vector R_PAR

    L_PAR           shift and go to state 174


state 117

    (50) predef_func -> REGRESSION . L_PAR vector COMMA vector R_PAR

    L_PAR           shift and go to state 175


state 118

    (51) predef_func -> VARIANCE . L_PAR vector R_PAR

    L_PAR           shift and go to state 176


state 119

    (52) predef_func -> DOT . L_PAR vector COMMA vector R_PAR

    L_PAR           shift and go to state 177


state 120

    (53) predef_func -> SUM . L_PAR vector R_PAR

    L_PAR           shift and go to state 178


state 121

    (54) predef_func -> ABS . L_PAR CTE_INT R_PAR

    L_PAR           shift and go to state 179


state 122

    (55) predef_func -> ROOF . L_PAR CTE_FLOAT R_PAR

    L_PAR           shift and go to state 180


state 123

    (56) predef_func -> FLOOR . L_PAR CTE_FLOAT R_PAR

    L_PAR           shift and go to state 181


state 124

    (11) function -> FUNCTION func_type ID np_set_curr_proc L_PAR params R_PAR np_set_quad_start vblock . np_ENDFunc
    (150) np_ENDFunc -> .

    FUNCTION        reduce using rule 150 (np_ENDFunc -> .)
    MAIN            reduce using rule 150 (np_ENDFunc -> .)

    np_ENDFunc                     shift and go to state 182

state 125

    (30) params -> type COLON ID np_add_param .
    (31) params -> type COLON ID np_add_param . COMMA params

    R_PAR           reduce using rule 30 (params -> type COLON ID np_add_param .)
    COMMA           shift and go to state 183


state 126

    (26) vblock -> L_BRACE vars vblockB R_BRACE .

    $end            reduce using rule 26 (vblock -> L_BRACE vars vblockB R_BRACE .)
    FUNCTION        reduce using rule 26 (vblock -> L_BRACE vars vblockB R_BRACE .)
    MAIN            reduce using rule 26 (vblock -> L_BRACE vars vblockB R_BRACE .)


state 127

    (28) vblockB -> statement vblockB .

    R_BRACE         reduce using rule 28 (vblockB -> statement vblockB .)


state 128

    (42) assign -> var np_push_operand oper_assign . np_push_operator expression np_end SEMICOLON
    (120) np_push_operator -> .

    NOT             reduce using rule 120 (np_push_operator -> .)
    L_PAR           reduce using rule 120 (np_push_operator -> .)
    MINUS           reduce using rule 120 (np_push_operator -> .)
    CTE_INT         reduce using rule 120 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 120 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 120 (np_push_operator -> .)
    CTE_STRING      reduce using rule 120 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 120 (np_push_operator -> .)
    ID              reduce using rule 120 (np_push_operator -> .)
    LENGTH          reduce using rule 120 (np_push_operator -> .)
    MIN             reduce using rule 120 (np_push_operator -> .)
    MAX             reduce using rule 120 (np_push_operator -> .)
    MEAN            reduce using rule 120 (np_push_operator -> .)
    MEDIAN          reduce using rule 120 (np_push_operator -> .)
    MODE            reduce using rule 120 (np_push_operator -> .)
    PLOT_XY         reduce using rule 120 (np_push_operator -> .)
    REGRESSION      reduce using rule 120 (np_push_operator -> .)
    VARIANCE        reduce using rule 120 (np_push_operator -> .)
    DOT             reduce using rule 120 (np_push_operator -> .)
    SUM             reduce using rule 120 (np_push_operator -> .)
    ABS             reduce using rule 120 (np_push_operator -> .)
    ROOF            reduce using rule 120 (np_push_operator -> .)
    FLOOR           reduce using rule 120 (np_push_operator -> .)

    np_push_operator               shift and go to state 184

state 129

    (79) oper_assign -> EQUAL .

    NOT             reduce using rule 79 (oper_assign -> EQUAL .)
    L_PAR           reduce using rule 79 (oper_assign -> EQUAL .)
    MINUS           reduce using rule 79 (oper_assign -> EQUAL .)
    CTE_INT         reduce using rule 79 (oper_assign -> EQUAL .)
    CTE_FLOAT       reduce using rule 79 (oper_assign -> EQUAL .)
    CTE_CHAR        reduce using rule 79 (oper_assign -> EQUAL .)
    CTE_STRING      reduce using rule 79 (oper_assign -> EQUAL .)
    CTE_BOOL        reduce using rule 79 (oper_assign -> EQUAL .)
    ID              reduce using rule 79 (oper_assign -> EQUAL .)
    LENGTH          reduce using rule 79 (oper_assign -> EQUAL .)
    MIN             reduce using rule 79 (oper_assign -> EQUAL .)
    MAX             reduce using rule 79 (oper_assign -> EQUAL .)
    MEAN            reduce using rule 79 (oper_assign -> EQUAL .)
    MEDIAN          reduce using rule 79 (oper_assign -> EQUAL .)
    MODE            reduce using rule 79 (oper_assign -> EQUAL .)
    PLOT_XY         reduce using rule 79 (oper_assign -> EQUAL .)
    REGRESSION      reduce using rule 79 (oper_assign -> EQUAL .)
    VARIANCE        reduce using rule 79 (oper_assign -> EQUAL .)
    DOT             reduce using rule 79 (oper_assign -> EQUAL .)
    SUM             reduce using rule 79 (oper_assign -> EQUAL .)
    ABS             reduce using rule 79 (oper_assign -> EQUAL .)
    ROOF            reduce using rule 79 (oper_assign -> EQUAL .)
    FLOOR           reduce using rule 79 (oper_assign -> EQUAL .)


state 130

    (80) oper_assign -> MULT_EQ .

    NOT             reduce using rule 80 (oper_assign -> MULT_EQ .)
    L_PAR           reduce using rule 80 (oper_assign -> MULT_EQ .)
    MINUS           reduce using rule 80 (oper_assign -> MULT_EQ .)
    CTE_INT         reduce using rule 80 (oper_assign -> MULT_EQ .)
    CTE_FLOAT       reduce using rule 80 (oper_assign -> MULT_EQ .)
    CTE_CHAR        reduce using rule 80 (oper_assign -> MULT_EQ .)
    CTE_STRING      reduce using rule 80 (oper_assign -> MULT_EQ .)
    CTE_BOOL        reduce using rule 80 (oper_assign -> MULT_EQ .)
    ID              reduce using rule 80 (oper_assign -> MULT_EQ .)
    LENGTH          reduce using rule 80 (oper_assign -> MULT_EQ .)
    MIN             reduce using rule 80 (oper_assign -> MULT_EQ .)
    MAX             reduce using rule 80 (oper_assign -> MULT_EQ .)
    MEAN            reduce using rule 80 (oper_assign -> MULT_EQ .)
    MEDIAN          reduce using rule 80 (oper_assign -> MULT_EQ .)
    MODE            reduce using rule 80 (oper_assign -> MULT_EQ .)
    PLOT_XY         reduce using rule 80 (oper_assign -> MULT_EQ .)
    REGRESSION      reduce using rule 80 (oper_assign -> MULT_EQ .)
    VARIANCE        reduce using rule 80 (oper_assign -> MULT_EQ .)
    DOT             reduce using rule 80 (oper_assign -> MULT_EQ .)
    SUM             reduce using rule 80 (oper_assign -> MULT_EQ .)
    ABS             reduce using rule 80 (oper_assign -> MULT_EQ .)
    ROOF            reduce using rule 80 (oper_assign -> MULT_EQ .)
    FLOOR           reduce using rule 80 (oper_assign -> MULT_EQ .)


state 131

    (81) oper_assign -> DIV_EQ .

    NOT             reduce using rule 81 (oper_assign -> DIV_EQ .)
    L_PAR           reduce using rule 81 (oper_assign -> DIV_EQ .)
    MINUS           reduce using rule 81 (oper_assign -> DIV_EQ .)
    CTE_INT         reduce using rule 81 (oper_assign -> DIV_EQ .)
    CTE_FLOAT       reduce using rule 81 (oper_assign -> DIV_EQ .)
    CTE_CHAR        reduce using rule 81 (oper_assign -> DIV_EQ .)
    CTE_STRING      reduce using rule 81 (oper_assign -> DIV_EQ .)
    CTE_BOOL        reduce using rule 81 (oper_assign -> DIV_EQ .)
    ID              reduce using rule 81 (oper_assign -> DIV_EQ .)
    LENGTH          reduce using rule 81 (oper_assign -> DIV_EQ .)
    MIN             reduce using rule 81 (oper_assign -> DIV_EQ .)
    MAX             reduce using rule 81 (oper_assign -> DIV_EQ .)
    MEAN            reduce using rule 81 (oper_assign -> DIV_EQ .)
    MEDIAN          reduce using rule 81 (oper_assign -> DIV_EQ .)
    MODE            reduce using rule 81 (oper_assign -> DIV_EQ .)
    PLOT_XY         reduce using rule 81 (oper_assign -> DIV_EQ .)
    REGRESSION      reduce using rule 81 (oper_assign -> DIV_EQ .)
    VARIANCE        reduce using rule 81 (oper_assign -> DIV_EQ .)
    DOT             reduce using rule 81 (oper_assign -> DIV_EQ .)
    SUM             reduce using rule 81 (oper_assign -> DIV_EQ .)
    ABS             reduce using rule 81 (oper_assign -> DIV_EQ .)
    ROOF            reduce using rule 81 (oper_assign -> DIV_EQ .)
    FLOOR           reduce using rule 81 (oper_assign -> DIV_EQ .)


state 132

    (82) oper_assign -> PLUS_EQ .

    NOT             reduce using rule 82 (oper_assign -> PLUS_EQ .)
    L_PAR           reduce using rule 82 (oper_assign -> PLUS_EQ .)
    MINUS           reduce using rule 82 (oper_assign -> PLUS_EQ .)
    CTE_INT         reduce using rule 82 (oper_assign -> PLUS_EQ .)
    CTE_FLOAT       reduce using rule 82 (oper_assign -> PLUS_EQ .)
    CTE_CHAR        reduce using rule 82 (oper_assign -> PLUS_EQ .)
    CTE_STRING      reduce using rule 82 (oper_assign -> PLUS_EQ .)
    CTE_BOOL        reduce using rule 82 (oper_assign -> PLUS_EQ .)
    ID              reduce using rule 82 (oper_assign -> PLUS_EQ .)
    LENGTH          reduce using rule 82 (oper_assign -> PLUS_EQ .)
    MIN             reduce using rule 82 (oper_assign -> PLUS_EQ .)
    MAX             reduce using rule 82 (oper_assign -> PLUS_EQ .)
    MEAN            reduce using rule 82 (oper_assign -> PLUS_EQ .)
    MEDIAN          reduce using rule 82 (oper_assign -> PLUS_EQ .)
    MODE            reduce using rule 82 (oper_assign -> PLUS_EQ .)
    PLOT_XY         reduce using rule 82 (oper_assign -> PLUS_EQ .)
    REGRESSION      reduce using rule 82 (oper_assign -> PLUS_EQ .)
    VARIANCE        reduce using rule 82 (oper_assign -> PLUS_EQ .)
    DOT             reduce using rule 82 (oper_assign -> PLUS_EQ .)
    SUM             reduce using rule 82 (oper_assign -> PLUS_EQ .)
    ABS             reduce using rule 82 (oper_assign -> PLUS_EQ .)
    ROOF            reduce using rule 82 (oper_assign -> PLUS_EQ .)
    FLOOR           reduce using rule 82 (oper_assign -> PLUS_EQ .)


state 133

    (83) oper_assign -> MINUS_EQ .

    NOT             reduce using rule 83 (oper_assign -> MINUS_EQ .)
    L_PAR           reduce using rule 83 (oper_assign -> MINUS_EQ .)
    MINUS           reduce using rule 83 (oper_assign -> MINUS_EQ .)
    CTE_INT         reduce using rule 83 (oper_assign -> MINUS_EQ .)
    CTE_FLOAT       reduce using rule 83 (oper_assign -> MINUS_EQ .)
    CTE_CHAR        reduce using rule 83 (oper_assign -> MINUS_EQ .)
    CTE_STRING      reduce using rule 83 (oper_assign -> MINUS_EQ .)
    CTE_BOOL        reduce using rule 83 (oper_assign -> MINUS_EQ .)
    ID              reduce using rule 83 (oper_assign -> MINUS_EQ .)
    LENGTH          reduce using rule 83 (oper_assign -> MINUS_EQ .)
    MIN             reduce using rule 83 (oper_assign -> MINUS_EQ .)
    MAX             reduce using rule 83 (oper_assign -> MINUS_EQ .)
    MEAN            reduce using rule 83 (oper_assign -> MINUS_EQ .)
    MEDIAN          reduce using rule 83 (oper_assign -> MINUS_EQ .)
    MODE            reduce using rule 83 (oper_assign -> MINUS_EQ .)
    PLOT_XY         reduce using rule 83 (oper_assign -> MINUS_EQ .)
    REGRESSION      reduce using rule 83 (oper_assign -> MINUS_EQ .)
    VARIANCE        reduce using rule 83 (oper_assign -> MINUS_EQ .)
    DOT             reduce using rule 83 (oper_assign -> MINUS_EQ .)
    SUM             reduce using rule 83 (oper_assign -> MINUS_EQ .)
    ABS             reduce using rule 83 (oper_assign -> MINUS_EQ .)
    ROOF            reduce using rule 83 (oper_assign -> MINUS_EQ .)
    FLOOR           reduce using rule 83 (oper_assign -> MINUS_EQ .)


state 134

    (57) condicional -> IF L_PAR expression . np_end np_GOTOF R_PAR block cond2 np_GOTO_END
    (133) np_end -> .

    R_PAR           reduce using rule 133 (np_end -> .)

    np_end                         shift and go to state 185

state 135

    (75) expression -> not . logic expressionB
    (86) logic -> . exp logic2
    (94) exp -> . term exp2
    (98) term -> . factor term2
    (103) factor -> . exponent factorB
    (106) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (107) exponent -> . exponentB
    (108) exponentB -> . MINUS var_cte
    (109) exponentB -> . var_cte
    (110) var_cte -> . var np_push_operand
    (111) var_cte -> . predef_func
    (112) var_cte -> . func_call
    (113) var_cte -> . CTE_INT np_push_cte_int
    (114) var_cte -> . CTE_FLOAT np_push_cte_float
    (115) var_cte -> . CTE_CHAR np_push_cte_char
    (116) var_cte -> . CTE_STRING np_push_cte_str
    (117) var_cte -> . CTE_BOOL np_push_cte_bool
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (43) predef_func -> . LENGTH L_PAR vector R_PAR
    (44) predef_func -> . MIN L_PAR vector R_PAR
    (45) predef_func -> . MAX L_PAR vector R_PAR
    (46) predef_func -> . MEAN L_PAR vector R_PAR
    (47) predef_func -> . MEDIAN L_PAR vector R_PAR
    (48) predef_func -> . MODE L_PAR vector R_PAR
    (49) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (50) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . VARIANCE L_PAR vector R_PAR
    (52) predef_func -> . DOT L_PAR vector COMMA vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (54) predef_func -> . ABS L_PAR CTE_INT R_PAR
    (55) predef_func -> . ROOF L_PAR CTE_FLOAT R_PAR
    (56) predef_func -> . FLOOR L_PAR CTE_FLOAT R_PAR
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 98
    MINUS           shift and go to state 100
    CTE_INT         shift and go to state 105
    CTE_FLOAT       shift and go to state 106
    CTE_CHAR        shift and go to state 107
    CTE_STRING      shift and go to state 108
    CTE_BOOL        shift and go to state 109
    ID              shift and go to state 73
    LENGTH          shift and go to state 110
    MIN             shift and go to state 111
    MAX             shift and go to state 112
    MEAN            shift and go to state 113
    MEDIAN          shift and go to state 114
    MODE            shift and go to state 115
    PLOT_XY         shift and go to state 116
    REGRESSION      shift and go to state 117
    VARIANCE        shift and go to state 118
    DOT             shift and go to state 119
    SUM             shift and go to state 120
    ABS             shift and go to state 121
    ROOF            shift and go to state 122
    FLOOR           shift and go to state 123

    logic                          shift and go to state 186
    exp                            shift and go to state 187
    term                           shift and go to state 95
    factor                         shift and go to state 96
    exponent                       shift and go to state 97
    exponentB                      shift and go to state 99
    var_cte                        shift and go to state 101
    var                            shift and go to state 102
    predef_func                    shift and go to state 103
    func_call                      shift and go to state 104

state 136

    (84) not -> NOT . np_push_operator
    (120) np_push_operator -> .

    L_PAR           reduce using rule 120 (np_push_operator -> .)
    MINUS           reduce using rule 120 (np_push_operator -> .)
    CTE_INT         reduce using rule 120 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 120 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 120 (np_push_operator -> .)
    CTE_STRING      reduce using rule 120 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 120 (np_push_operator -> .)
    ID              reduce using rule 120 (np_push_operator -> .)
    LENGTH          reduce using rule 120 (np_push_operator -> .)
    MIN             reduce using rule 120 (np_push_operator -> .)
    MAX             reduce using rule 120 (np_push_operator -> .)
    MEAN            reduce using rule 120 (np_push_operator -> .)
    MEDIAN          reduce using rule 120 (np_push_operator -> .)
    MODE            reduce using rule 120 (np_push_operator -> .)
    PLOT_XY         reduce using rule 120 (np_push_operator -> .)
    REGRESSION      reduce using rule 120 (np_push_operator -> .)
    VARIANCE        reduce using rule 120 (np_push_operator -> .)
    DOT             reduce using rule 120 (np_push_operator -> .)
    SUM             reduce using rule 120 (np_push_operator -> .)
    ABS             reduce using rule 120 (np_push_operator -> .)
    ROOF            reduce using rule 120 (np_push_operator -> .)
    FLOOR           reduce using rule 120 (np_push_operator -> .)

    np_push_operator               shift and go to state 188

state 137

    (85) not -> empty .

    L_PAR           reduce using rule 85 (not -> empty .)
    MINUS           reduce using rule 85 (not -> empty .)
    CTE_INT         reduce using rule 85 (not -> empty .)
    CTE_FLOAT       reduce using rule 85 (not -> empty .)
    CTE_CHAR        reduce using rule 85 (not -> empty .)
    CTE_STRING      reduce using rule 85 (not -> empty .)
    CTE_BOOL        reduce using rule 85 (not -> empty .)
    ID              reduce using rule 85 (not -> empty .)
    LENGTH          reduce using rule 85 (not -> empty .)
    MIN             reduce using rule 85 (not -> empty .)
    MAX             reduce using rule 85 (not -> empty .)
    MEAN            reduce using rule 85 (not -> empty .)
    MEDIAN          reduce using rule 85 (not -> empty .)
    MODE            reduce using rule 85 (not -> empty .)
    PLOT_XY         reduce using rule 85 (not -> empty .)
    REGRESSION      reduce using rule 85 (not -> empty .)
    VARIANCE        reduce using rule 85 (not -> empty .)
    DOT             reduce using rule 85 (not -> empty .)
    SUM             reduce using rule 85 (not -> empty .)
    ABS             reduce using rule 85 (not -> empty .)
    ROOF            reduce using rule 85 (not -> empty .)
    FLOOR           reduce using rule 85 (not -> empty .)


state 138

    (60) read -> READ L_PAR read2 . R_PAR SEMICOLON

    R_PAR           shift and go to state 189


state 139

    (61) read2 -> var . np_read
    (62) read2 -> var . np_read COMMA read2
    (134) np_read -> .

    COMMA           reduce using rule 134 (np_read -> .)
    R_PAR           reduce using rule 134 (np_read -> .)

    np_read                        shift and go to state 190

state 140

    (63) write -> WRITE L_PAR writeB . R_PAR SEMICOLON

    R_PAR           shift and go to state 191


state 141

    (64) writeB -> expression . np_end np_write writeC
    (133) np_end -> .

    COMMA           reduce using rule 133 (np_end -> .)
    R_PAR           reduce using rule 133 (np_end -> .)

    np_end                         shift and go to state 192

state 142

    (65) writeB -> CTE_STRING . np_push_cte_str np_write writeC
    (125) np_push_cte_str -> .

    COMMA           reduce using rule 125 (np_push_cte_str -> .)
    R_PAR           reduce using rule 125 (np_push_cte_str -> .)

    np_push_cte_str                shift and go to state 193

state 143

    (68) loop_cond -> WHILE L_PAR np_CHECKPOINT . expression R_PAR np_end np_GOTOF block np_GOTO_WHILE
    (75) expression -> . not logic expressionB
    (84) not -> . NOT np_push_operator
    (85) not -> . empty
    (118) empty -> .

    NOT             shift and go to state 136
    L_PAR           reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    CTE_INT         reduce using rule 118 (empty -> .)
    CTE_FLOAT       reduce using rule 118 (empty -> .)
    CTE_CHAR        reduce using rule 118 (empty -> .)
    CTE_STRING      reduce using rule 118 (empty -> .)
    CTE_BOOL        reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    LENGTH          reduce using rule 118 (empty -> .)
    MIN             reduce using rule 118 (empty -> .)
    MAX             reduce using rule 118 (empty -> .)
    MEAN            reduce using rule 118 (empty -> .)
    MEDIAN          reduce using rule 118 (empty -> .)
    MODE            reduce using rule 118 (empty -> .)
    PLOT_XY         reduce using rule 118 (empty -> .)
    REGRESSION      reduce using rule 118 (empty -> .)
    VARIANCE        reduce using rule 118 (empty -> .)
    DOT             reduce using rule 118 (empty -> .)
    SUM             reduce using rule 118 (empty -> .)
    ABS             reduce using rule 118 (empty -> .)
    ROOF            reduce using rule 118 (empty -> .)
    FLOOR           reduce using rule 118 (empty -> .)

    expression                     shift and go to state 194
    not                            shift and go to state 135
    empty                          shift and go to state 137

state 144

    (69) loop_range -> FOR var np_push_operand . EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR

    EQUAL           shift and go to state 195


state 145

    (70) return -> RETURN L_PAR np_stop . exp np_end np_set_return R_PAR SEMICOLON
    (94) exp -> . term exp2
    (98) term -> . factor term2
    (103) factor -> . exponent factorB
    (106) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (107) exponent -> . exponentB
    (108) exponentB -> . MINUS var_cte
    (109) exponentB -> . var_cte
    (110) var_cte -> . var np_push_operand
    (111) var_cte -> . predef_func
    (112) var_cte -> . func_call
    (113) var_cte -> . CTE_INT np_push_cte_int
    (114) var_cte -> . CTE_FLOAT np_push_cte_float
    (115) var_cte -> . CTE_CHAR np_push_cte_char
    (116) var_cte -> . CTE_STRING np_push_cte_str
    (117) var_cte -> . CTE_BOOL np_push_cte_bool
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (43) predef_func -> . LENGTH L_PAR vector R_PAR
    (44) predef_func -> . MIN L_PAR vector R_PAR
    (45) predef_func -> . MAX L_PAR vector R_PAR
    (46) predef_func -> . MEAN L_PAR vector R_PAR
    (47) predef_func -> . MEDIAN L_PAR vector R_PAR
    (48) predef_func -> . MODE L_PAR vector R_PAR
    (49) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (50) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . VARIANCE L_PAR vector R_PAR
    (52) predef_func -> . DOT L_PAR vector COMMA vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (54) predef_func -> . ABS L_PAR CTE_INT R_PAR
    (55) predef_func -> . ROOF L_PAR CTE_FLOAT R_PAR
    (56) predef_func -> . FLOOR L_PAR CTE_FLOAT R_PAR
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 98
    MINUS           shift and go to state 100
    CTE_INT         shift and go to state 105
    CTE_FLOAT       shift and go to state 106
    CTE_CHAR        shift and go to state 107
    CTE_STRING      shift and go to state 108
    CTE_BOOL        shift and go to state 109
    ID              shift and go to state 73
    LENGTH          shift and go to state 110
    MIN             shift and go to state 111
    MAX             shift and go to state 112
    MEAN            shift and go to state 113
    MEDIAN          shift and go to state 114
    MODE            shift and go to state 115
    PLOT_XY         shift and go to state 116
    REGRESSION      shift and go to state 117
    VARIANCE        shift and go to state 118
    DOT             shift and go to state 119
    SUM             shift and go to state 120
    ABS             shift and go to state 121
    ROOF            shift and go to state 122
    FLOOR           shift and go to state 123

    exp                            shift and go to state 196
    term                           shift and go to state 95
    factor                         shift and go to state 96
    exponent                       shift and go to state 97
    exponentB                      shift and go to state 99
    var_cte                        shift and go to state 101
    var                            shift and go to state 102
    predef_func                    shift and go to state 103
    func_call                      shift and go to state 104

state 146

    (71) func_call -> ID np_ERA L_PAR . func_call_arguments R_PAR np_GOSUB
    (72) func_call_arguments -> . np_stop exp np_end np_param
    (73) func_call_arguments -> . np_stop exp np_end np_param COMMA func_call_arguments
    (74) func_call_arguments -> . empty
    (153) np_stop -> .
    (118) empty -> .

    L_PAR           reduce using rule 153 (np_stop -> .)
    MINUS           reduce using rule 153 (np_stop -> .)
    CTE_INT         reduce using rule 153 (np_stop -> .)
    CTE_FLOAT       reduce using rule 153 (np_stop -> .)
    CTE_CHAR        reduce using rule 153 (np_stop -> .)
    CTE_STRING      reduce using rule 153 (np_stop -> .)
    CTE_BOOL        reduce using rule 153 (np_stop -> .)
    ID              reduce using rule 153 (np_stop -> .)
    LENGTH          reduce using rule 153 (np_stop -> .)
    MIN             reduce using rule 153 (np_stop -> .)
    MAX             reduce using rule 153 (np_stop -> .)
    MEAN            reduce using rule 153 (np_stop -> .)
    MEDIAN          reduce using rule 153 (np_stop -> .)
    MODE            reduce using rule 153 (np_stop -> .)
    PLOT_XY         reduce using rule 153 (np_stop -> .)
    REGRESSION      reduce using rule 153 (np_stop -> .)
    VARIANCE        reduce using rule 153 (np_stop -> .)
    DOT             reduce using rule 153 (np_stop -> .)
    SUM             reduce using rule 153 (np_stop -> .)
    ABS             reduce using rule 153 (np_stop -> .)
    ROOF            reduce using rule 153 (np_stop -> .)
    FLOOR           reduce using rule 153 (np_stop -> .)
    R_PAR           reduce using rule 118 (empty -> .)

    func_call_arguments            shift and go to state 197
    np_stop                        shift and go to state 198
    empty                          shift and go to state 199

state 147

    (18) var -> ID L_BRACKET np_arr_start exp np_end . np_arr_end R_BRACKET
    (152) np_arr_end -> .

    R_BRACKET       reduce using rule 152 (np_arr_end -> .)

    np_arr_end                     shift and go to state 200

state 148

    (94) exp -> term exp2 .

    R_BRACKET       reduce using rule 94 (exp -> term exp2 .)
    LESS            reduce using rule 94 (exp -> term exp2 .)
    GREATER         reduce using rule 94 (exp -> term exp2 .)
    LESS_EQ         reduce using rule 94 (exp -> term exp2 .)
    GREATER_EQ      reduce using rule 94 (exp -> term exp2 .)
    EQUIVALENT      reduce using rule 94 (exp -> term exp2 .)
    DIFFERENT       reduce using rule 94 (exp -> term exp2 .)
    OR              reduce using rule 94 (exp -> term exp2 .)
    AND             reduce using rule 94 (exp -> term exp2 .)
    R_PAR           reduce using rule 94 (exp -> term exp2 .)
    COMMA           reduce using rule 94 (exp -> term exp2 .)
    SEMICOLON       reduce using rule 94 (exp -> term exp2 .)
    TO              reduce using rule 94 (exp -> term exp2 .)
    L_BRACE         reduce using rule 94 (exp -> term exp2 .)


state 149

    (95) exp2 -> PLUS . np_push_operator exp
    (120) np_push_operator -> .

    L_PAR           reduce using rule 120 (np_push_operator -> .)
    MINUS           reduce using rule 120 (np_push_operator -> .)
    CTE_INT         reduce using rule 120 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 120 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 120 (np_push_operator -> .)
    CTE_STRING      reduce using rule 120 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 120 (np_push_operator -> .)
    ID              reduce using rule 120 (np_push_operator -> .)
    LENGTH          reduce using rule 120 (np_push_operator -> .)
    MIN             reduce using rule 120 (np_push_operator -> .)
    MAX             reduce using rule 120 (np_push_operator -> .)
    MEAN            reduce using rule 120 (np_push_operator -> .)
    MEDIAN          reduce using rule 120 (np_push_operator -> .)
    MODE            reduce using rule 120 (np_push_operator -> .)
    PLOT_XY         reduce using rule 120 (np_push_operator -> .)
    REGRESSION      reduce using rule 120 (np_push_operator -> .)
    VARIANCE        reduce using rule 120 (np_push_operator -> .)
    DOT             reduce using rule 120 (np_push_operator -> .)
    SUM             reduce using rule 120 (np_push_operator -> .)
    ABS             reduce using rule 120 (np_push_operator -> .)
    ROOF            reduce using rule 120 (np_push_operator -> .)
    FLOOR           reduce using rule 120 (np_push_operator -> .)

    np_push_operator               shift and go to state 201

state 150

    (96) exp2 -> MINUS . np_push_operator exp
    (120) np_push_operator -> .

    L_PAR           reduce using rule 120 (np_push_operator -> .)
    MINUS           reduce using rule 120 (np_push_operator -> .)
    CTE_INT         reduce using rule 120 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 120 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 120 (np_push_operator -> .)
    CTE_STRING      reduce using rule 120 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 120 (np_push_operator -> .)
    ID              reduce using rule 120 (np_push_operator -> .)
    LENGTH          reduce using rule 120 (np_push_operator -> .)
    MIN             reduce using rule 120 (np_push_operator -> .)
    MAX             reduce using rule 120 (np_push_operator -> .)
    MEAN            reduce using rule 120 (np_push_operator -> .)
    MEDIAN          reduce using rule 120 (np_push_operator -> .)
    MODE            reduce using rule 120 (np_push_operator -> .)
    PLOT_XY         reduce using rule 120 (np_push_operator -> .)
    REGRESSION      reduce using rule 120 (np_push_operator -> .)
    VARIANCE        reduce using rule 120 (np_push_operator -> .)
    DOT             reduce using rule 120 (np_push_operator -> .)
    SUM             reduce using rule 120 (np_push_operator -> .)
    ABS             reduce using rule 120 (np_push_operator -> .)
    ROOF            reduce using rule 120 (np_push_operator -> .)
    FLOOR           reduce using rule 120 (np_push_operator -> .)

    np_push_operator               shift and go to state 202

state 151

    (97) exp2 -> empty .

    R_BRACKET       reduce using rule 97 (exp2 -> empty .)
    LESS            reduce using rule 97 (exp2 -> empty .)
    GREATER         reduce using rule 97 (exp2 -> empty .)
    LESS_EQ         reduce using rule 97 (exp2 -> empty .)
    GREATER_EQ      reduce using rule 97 (exp2 -> empty .)
    EQUIVALENT      reduce using rule 97 (exp2 -> empty .)
    DIFFERENT       reduce using rule 97 (exp2 -> empty .)
    OR              reduce using rule 97 (exp2 -> empty .)
    AND             reduce using rule 97 (exp2 -> empty .)
    R_PAR           reduce using rule 97 (exp2 -> empty .)
    COMMA           reduce using rule 97 (exp2 -> empty .)
    SEMICOLON       reduce using rule 97 (exp2 -> empty .)
    TO              reduce using rule 97 (exp2 -> empty .)
    L_BRACE         reduce using rule 97 (exp2 -> empty .)


state 152

    (98) term -> factor term2 .

    PLUS            reduce using rule 98 (term -> factor term2 .)
    MINUS           reduce using rule 98 (term -> factor term2 .)
    R_BRACKET       reduce using rule 98 (term -> factor term2 .)
    LESS            reduce using rule 98 (term -> factor term2 .)
    GREATER         reduce using rule 98 (term -> factor term2 .)
    LESS_EQ         reduce using rule 98 (term -> factor term2 .)
    GREATER_EQ      reduce using rule 98 (term -> factor term2 .)
    EQUIVALENT      reduce using rule 98 (term -> factor term2 .)
    DIFFERENT       reduce using rule 98 (term -> factor term2 .)
    OR              reduce using rule 98 (term -> factor term2 .)
    AND             reduce using rule 98 (term -> factor term2 .)
    R_PAR           reduce using rule 98 (term -> factor term2 .)
    COMMA           reduce using rule 98 (term -> factor term2 .)
    SEMICOLON       reduce using rule 98 (term -> factor term2 .)
    TO              reduce using rule 98 (term -> factor term2 .)
    L_BRACE         reduce using rule 98 (term -> factor term2 .)


state 153

    (99) term2 -> MULT . np_push_operator term
    (120) np_push_operator -> .

    L_PAR           reduce using rule 120 (np_push_operator -> .)
    MINUS           reduce using rule 120 (np_push_operator -> .)
    CTE_INT         reduce using rule 120 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 120 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 120 (np_push_operator -> .)
    CTE_STRING      reduce using rule 120 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 120 (np_push_operator -> .)
    ID              reduce using rule 120 (np_push_operator -> .)
    LENGTH          reduce using rule 120 (np_push_operator -> .)
    MIN             reduce using rule 120 (np_push_operator -> .)
    MAX             reduce using rule 120 (np_push_operator -> .)
    MEAN            reduce using rule 120 (np_push_operator -> .)
    MEDIAN          reduce using rule 120 (np_push_operator -> .)
    MODE            reduce using rule 120 (np_push_operator -> .)
    PLOT_XY         reduce using rule 120 (np_push_operator -> .)
    REGRESSION      reduce using rule 120 (np_push_operator -> .)
    VARIANCE        reduce using rule 120 (np_push_operator -> .)
    DOT             reduce using rule 120 (np_push_operator -> .)
    SUM             reduce using rule 120 (np_push_operator -> .)
    ABS             reduce using rule 120 (np_push_operator -> .)
    ROOF            reduce using rule 120 (np_push_operator -> .)
    FLOOR           reduce using rule 120 (np_push_operator -> .)

    np_push_operator               shift and go to state 203

state 154

    (100) term2 -> DIV . np_push_operator term
    (120) np_push_operator -> .

    L_PAR           reduce using rule 120 (np_push_operator -> .)
    MINUS           reduce using rule 120 (np_push_operator -> .)
    CTE_INT         reduce using rule 120 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 120 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 120 (np_push_operator -> .)
    CTE_STRING      reduce using rule 120 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 120 (np_push_operator -> .)
    ID              reduce using rule 120 (np_push_operator -> .)
    LENGTH          reduce using rule 120 (np_push_operator -> .)
    MIN             reduce using rule 120 (np_push_operator -> .)
    MAX             reduce using rule 120 (np_push_operator -> .)
    MEAN            reduce using rule 120 (np_push_operator -> .)
    MEDIAN          reduce using rule 120 (np_push_operator -> .)
    MODE            reduce using rule 120 (np_push_operator -> .)
    PLOT_XY         reduce using rule 120 (np_push_operator -> .)
    REGRESSION      reduce using rule 120 (np_push_operator -> .)
    VARIANCE        reduce using rule 120 (np_push_operator -> .)
    DOT             reduce using rule 120 (np_push_operator -> .)
    SUM             reduce using rule 120 (np_push_operator -> .)
    ABS             reduce using rule 120 (np_push_operator -> .)
    ROOF            reduce using rule 120 (np_push_operator -> .)
    FLOOR           reduce using rule 120 (np_push_operator -> .)

    np_push_operator               shift and go to state 204

state 155

    (101) term2 -> REMAINDER . np_push_operator term
    (120) np_push_operator -> .

    L_PAR           reduce using rule 120 (np_push_operator -> .)
    MINUS           reduce using rule 120 (np_push_operator -> .)
    CTE_INT         reduce using rule 120 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 120 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 120 (np_push_operator -> .)
    CTE_STRING      reduce using rule 120 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 120 (np_push_operator -> .)
    ID              reduce using rule 120 (np_push_operator -> .)
    LENGTH          reduce using rule 120 (np_push_operator -> .)
    MIN             reduce using rule 120 (np_push_operator -> .)
    MAX             reduce using rule 120 (np_push_operator -> .)
    MEAN            reduce using rule 120 (np_push_operator -> .)
    MEDIAN          reduce using rule 120 (np_push_operator -> .)
    MODE            reduce using rule 120 (np_push_operator -> .)
    PLOT_XY         reduce using rule 120 (np_push_operator -> .)
    REGRESSION      reduce using rule 120 (np_push_operator -> .)
    VARIANCE        reduce using rule 120 (np_push_operator -> .)
    DOT             reduce using rule 120 (np_push_operator -> .)
    SUM             reduce using rule 120 (np_push_operator -> .)
    ABS             reduce using rule 120 (np_push_operator -> .)
    ROOF            reduce using rule 120 (np_push_operator -> .)
    FLOOR           reduce using rule 120 (np_push_operator -> .)

    np_push_operator               shift and go to state 205

state 156

    (102) term2 -> empty .

    PLUS            reduce using rule 102 (term2 -> empty .)
    MINUS           reduce using rule 102 (term2 -> empty .)
    R_BRACKET       reduce using rule 102 (term2 -> empty .)
    LESS            reduce using rule 102 (term2 -> empty .)
    GREATER         reduce using rule 102 (term2 -> empty .)
    LESS_EQ         reduce using rule 102 (term2 -> empty .)
    GREATER_EQ      reduce using rule 102 (term2 -> empty .)
    EQUIVALENT      reduce using rule 102 (term2 -> empty .)
    DIFFERENT       reduce using rule 102 (term2 -> empty .)
    OR              reduce using rule 102 (term2 -> empty .)
    AND             reduce using rule 102 (term2 -> empty .)
    R_PAR           reduce using rule 102 (term2 -> empty .)
    COMMA           reduce using rule 102 (term2 -> empty .)
    SEMICOLON       reduce using rule 102 (term2 -> empty .)
    TO              reduce using rule 102 (term2 -> empty .)
    L_BRACE         reduce using rule 102 (term2 -> empty .)


state 157

    (103) factor -> exponent factorB .

    MULT            reduce using rule 103 (factor -> exponent factorB .)
    DIV             reduce using rule 103 (factor -> exponent factorB .)
    REMAINDER       reduce using rule 103 (factor -> exponent factorB .)
    PLUS            reduce using rule 103 (factor -> exponent factorB .)
    MINUS           reduce using rule 103 (factor -> exponent factorB .)
    R_BRACKET       reduce using rule 103 (factor -> exponent factorB .)
    LESS            reduce using rule 103 (factor -> exponent factorB .)
    GREATER         reduce using rule 103 (factor -> exponent factorB .)
    LESS_EQ         reduce using rule 103 (factor -> exponent factorB .)
    GREATER_EQ      reduce using rule 103 (factor -> exponent factorB .)
    EQUIVALENT      reduce using rule 103 (factor -> exponent factorB .)
    DIFFERENT       reduce using rule 103 (factor -> exponent factorB .)
    OR              reduce using rule 103 (factor -> exponent factorB .)
    AND             reduce using rule 103 (factor -> exponent factorB .)
    R_PAR           reduce using rule 103 (factor -> exponent factorB .)
    COMMA           reduce using rule 103 (factor -> exponent factorB .)
    SEMICOLON       reduce using rule 103 (factor -> exponent factorB .)
    TO              reduce using rule 103 (factor -> exponent factorB .)
    L_BRACE         reduce using rule 103 (factor -> exponent factorB .)


state 158

    (104) factorB -> EXP . factor
    (103) factor -> . exponent factorB
    (106) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (107) exponent -> . exponentB
    (108) exponentB -> . MINUS var_cte
    (109) exponentB -> . var_cte
    (110) var_cte -> . var np_push_operand
    (111) var_cte -> . predef_func
    (112) var_cte -> . func_call
    (113) var_cte -> . CTE_INT np_push_cte_int
    (114) var_cte -> . CTE_FLOAT np_push_cte_float
    (115) var_cte -> . CTE_CHAR np_push_cte_char
    (116) var_cte -> . CTE_STRING np_push_cte_str
    (117) var_cte -> . CTE_BOOL np_push_cte_bool
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (43) predef_func -> . LENGTH L_PAR vector R_PAR
    (44) predef_func -> . MIN L_PAR vector R_PAR
    (45) predef_func -> . MAX L_PAR vector R_PAR
    (46) predef_func -> . MEAN L_PAR vector R_PAR
    (47) predef_func -> . MEDIAN L_PAR vector R_PAR
    (48) predef_func -> . MODE L_PAR vector R_PAR
    (49) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (50) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . VARIANCE L_PAR vector R_PAR
    (52) predef_func -> . DOT L_PAR vector COMMA vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (54) predef_func -> . ABS L_PAR CTE_INT R_PAR
    (55) predef_func -> . ROOF L_PAR CTE_FLOAT R_PAR
    (56) predef_func -> . FLOOR L_PAR CTE_FLOAT R_PAR
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 98
    MINUS           shift and go to state 100
    CTE_INT         shift and go to state 105
    CTE_FLOAT       shift and go to state 106
    CTE_CHAR        shift and go to state 107
    CTE_STRING      shift and go to state 108
    CTE_BOOL        shift and go to state 109
    ID              shift and go to state 73
    LENGTH          shift and go to state 110
    MIN             shift and go to state 111
    MAX             shift and go to state 112
    MEAN            shift and go to state 113
    MEDIAN          shift and go to state 114
    MODE            shift and go to state 115
    PLOT_XY         shift and go to state 116
    REGRESSION      shift and go to state 117
    VARIANCE        shift and go to state 118
    DOT             shift and go to state 119
    SUM             shift and go to state 120
    ABS             shift and go to state 121
    ROOF            shift and go to state 122
    FLOOR           shift and go to state 123

    factor                         shift and go to state 206
    exponent                       shift and go to state 97
    exponentB                      shift and go to state 99
    var_cte                        shift and go to state 101
    var                            shift and go to state 102
    predef_func                    shift and go to state 103
    func_call                      shift and go to state 104

state 159

    (105) factorB -> empty .

    MULT            reduce using rule 105 (factorB -> empty .)
    DIV             reduce using rule 105 (factorB -> empty .)
    REMAINDER       reduce using rule 105 (factorB -> empty .)
    PLUS            reduce using rule 105 (factorB -> empty .)
    MINUS           reduce using rule 105 (factorB -> empty .)
    R_BRACKET       reduce using rule 105 (factorB -> empty .)
    LESS            reduce using rule 105 (factorB -> empty .)
    GREATER         reduce using rule 105 (factorB -> empty .)
    LESS_EQ         reduce using rule 105 (factorB -> empty .)
    GREATER_EQ      reduce using rule 105 (factorB -> empty .)
    EQUIVALENT      reduce using rule 105 (factorB -> empty .)
    DIFFERENT       reduce using rule 105 (factorB -> empty .)
    OR              reduce using rule 105 (factorB -> empty .)
    AND             reduce using rule 105 (factorB -> empty .)
    R_PAR           reduce using rule 105 (factorB -> empty .)
    COMMA           reduce using rule 105 (factorB -> empty .)
    SEMICOLON       reduce using rule 105 (factorB -> empty .)
    TO              reduce using rule 105 (factorB -> empty .)
    L_BRACE         reduce using rule 105 (factorB -> empty .)


state 160

    (106) exponent -> L_PAR np_push_operator . expression R_PAR np_rpar
    (75) expression -> . not logic expressionB
    (84) not -> . NOT np_push_operator
    (85) not -> . empty
    (118) empty -> .

    NOT             shift and go to state 136
    L_PAR           reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    CTE_INT         reduce using rule 118 (empty -> .)
    CTE_FLOAT       reduce using rule 118 (empty -> .)
    CTE_CHAR        reduce using rule 118 (empty -> .)
    CTE_STRING      reduce using rule 118 (empty -> .)
    CTE_BOOL        reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    LENGTH          reduce using rule 118 (empty -> .)
    MIN             reduce using rule 118 (empty -> .)
    MAX             reduce using rule 118 (empty -> .)
    MEAN            reduce using rule 118 (empty -> .)
    MEDIAN          reduce using rule 118 (empty -> .)
    MODE            reduce using rule 118 (empty -> .)
    PLOT_XY         reduce using rule 118 (empty -> .)
    REGRESSION      reduce using rule 118 (empty -> .)
    VARIANCE        reduce using rule 118 (empty -> .)
    DOT             reduce using rule 118 (empty -> .)
    SUM             reduce using rule 118 (empty -> .)
    ABS             reduce using rule 118 (empty -> .)
    ROOF            reduce using rule 118 (empty -> .)
    FLOOR           reduce using rule 118 (empty -> .)

    expression                     shift and go to state 207
    not                            shift and go to state 135
    empty                          shift and go to state 137

state 161

    (108) exponentB -> MINUS var_cte .

    EXP             reduce using rule 108 (exponentB -> MINUS var_cte .)
    MULT            reduce using rule 108 (exponentB -> MINUS var_cte .)
    DIV             reduce using rule 108 (exponentB -> MINUS var_cte .)
    REMAINDER       reduce using rule 108 (exponentB -> MINUS var_cte .)
    PLUS            reduce using rule 108 (exponentB -> MINUS var_cte .)
    MINUS           reduce using rule 108 (exponentB -> MINUS var_cte .)
    R_BRACKET       reduce using rule 108 (exponentB -> MINUS var_cte .)
    LESS            reduce using rule 108 (exponentB -> MINUS var_cte .)
    GREATER         reduce using rule 108 (exponentB -> MINUS var_cte .)
    LESS_EQ         reduce using rule 108 (exponentB -> MINUS var_cte .)
    GREATER_EQ      reduce using rule 108 (exponentB -> MINUS var_cte .)
    EQUIVALENT      reduce using rule 108 (exponentB -> MINUS var_cte .)
    DIFFERENT       reduce using rule 108 (exponentB -> MINUS var_cte .)
    OR              reduce using rule 108 (exponentB -> MINUS var_cte .)
    AND             reduce using rule 108 (exponentB -> MINUS var_cte .)
    R_PAR           reduce using rule 108 (exponentB -> MINUS var_cte .)
    COMMA           reduce using rule 108 (exponentB -> MINUS var_cte .)
    SEMICOLON       reduce using rule 108 (exponentB -> MINUS var_cte .)
    TO              reduce using rule 108 (exponentB -> MINUS var_cte .)
    L_BRACE         reduce using rule 108 (exponentB -> MINUS var_cte .)


state 162

    (110) var_cte -> var np_push_operand .

    EXP             reduce using rule 110 (var_cte -> var np_push_operand .)
    MULT            reduce using rule 110 (var_cte -> var np_push_operand .)
    DIV             reduce using rule 110 (var_cte -> var np_push_operand .)
    REMAINDER       reduce using rule 110 (var_cte -> var np_push_operand .)
    PLUS            reduce using rule 110 (var_cte -> var np_push_operand .)
    MINUS           reduce using rule 110 (var_cte -> var np_push_operand .)
    R_BRACKET       reduce using rule 110 (var_cte -> var np_push_operand .)
    LESS            reduce using rule 110 (var_cte -> var np_push_operand .)
    GREATER         reduce using rule 110 (var_cte -> var np_push_operand .)
    LESS_EQ         reduce using rule 110 (var_cte -> var np_push_operand .)
    GREATER_EQ      reduce using rule 110 (var_cte -> var np_push_operand .)
    EQUIVALENT      reduce using rule 110 (var_cte -> var np_push_operand .)
    DIFFERENT       reduce using rule 110 (var_cte -> var np_push_operand .)
    OR              reduce using rule 110 (var_cte -> var np_push_operand .)
    AND             reduce using rule 110 (var_cte -> var np_push_operand .)
    R_PAR           reduce using rule 110 (var_cte -> var np_push_operand .)
    COMMA           reduce using rule 110 (var_cte -> var np_push_operand .)
    SEMICOLON       reduce using rule 110 (var_cte -> var np_push_operand .)
    TO              reduce using rule 110 (var_cte -> var np_push_operand .)
    L_BRACE         reduce using rule 110 (var_cte -> var np_push_operand .)


state 163

    (113) var_cte -> CTE_INT np_push_cte_int .

    EXP             reduce using rule 113 (var_cte -> CTE_INT np_push_cte_int .)
    MULT            reduce using rule 113 (var_cte -> CTE_INT np_push_cte_int .)
    DIV             reduce using rule 113 (var_cte -> CTE_INT np_push_cte_int .)
    REMAINDER       reduce using rule 113 (var_cte -> CTE_INT np_push_cte_int .)
    PLUS            reduce using rule 113 (var_cte -> CTE_INT np_push_cte_int .)
    MINUS           reduce using rule 113 (var_cte -> CTE_INT np_push_cte_int .)
    R_BRACKET       reduce using rule 113 (var_cte -> CTE_INT np_push_cte_int .)
    LESS            reduce using rule 113 (var_cte -> CTE_INT np_push_cte_int .)
    GREATER         reduce using rule 113 (var_cte -> CTE_INT np_push_cte_int .)
    LESS_EQ         reduce using rule 113 (var_cte -> CTE_INT np_push_cte_int .)
    GREATER_EQ      reduce using rule 113 (var_cte -> CTE_INT np_push_cte_int .)
    EQUIVALENT      reduce using rule 113 (var_cte -> CTE_INT np_push_cte_int .)
    DIFFERENT       reduce using rule 113 (var_cte -> CTE_INT np_push_cte_int .)
    OR              reduce using rule 113 (var_cte -> CTE_INT np_push_cte_int .)
    AND             reduce using rule 113 (var_cte -> CTE_INT np_push_cte_int .)
    R_PAR           reduce using rule 113 (var_cte -> CTE_INT np_push_cte_int .)
    COMMA           reduce using rule 113 (var_cte -> CTE_INT np_push_cte_int .)
    SEMICOLON       reduce using rule 113 (var_cte -> CTE_INT np_push_cte_int .)
    TO              reduce using rule 113 (var_cte -> CTE_INT np_push_cte_int .)
    L_BRACE         reduce using rule 113 (var_cte -> CTE_INT np_push_cte_int .)


state 164

    (114) var_cte -> CTE_FLOAT np_push_cte_float .

    EXP             reduce using rule 114 (var_cte -> CTE_FLOAT np_push_cte_float .)
    MULT            reduce using rule 114 (var_cte -> CTE_FLOAT np_push_cte_float .)
    DIV             reduce using rule 114 (var_cte -> CTE_FLOAT np_push_cte_float .)
    REMAINDER       reduce using rule 114 (var_cte -> CTE_FLOAT np_push_cte_float .)
    PLUS            reduce using rule 114 (var_cte -> CTE_FLOAT np_push_cte_float .)
    MINUS           reduce using rule 114 (var_cte -> CTE_FLOAT np_push_cte_float .)
    R_BRACKET       reduce using rule 114 (var_cte -> CTE_FLOAT np_push_cte_float .)
    LESS            reduce using rule 114 (var_cte -> CTE_FLOAT np_push_cte_float .)
    GREATER         reduce using rule 114 (var_cte -> CTE_FLOAT np_push_cte_float .)
    LESS_EQ         reduce using rule 114 (var_cte -> CTE_FLOAT np_push_cte_float .)
    GREATER_EQ      reduce using rule 114 (var_cte -> CTE_FLOAT np_push_cte_float .)
    EQUIVALENT      reduce using rule 114 (var_cte -> CTE_FLOAT np_push_cte_float .)
    DIFFERENT       reduce using rule 114 (var_cte -> CTE_FLOAT np_push_cte_float .)
    OR              reduce using rule 114 (var_cte -> CTE_FLOAT np_push_cte_float .)
    AND             reduce using rule 114 (var_cte -> CTE_FLOAT np_push_cte_float .)
    R_PAR           reduce using rule 114 (var_cte -> CTE_FLOAT np_push_cte_float .)
    COMMA           reduce using rule 114 (var_cte -> CTE_FLOAT np_push_cte_float .)
    SEMICOLON       reduce using rule 114 (var_cte -> CTE_FLOAT np_push_cte_float .)
    TO              reduce using rule 114 (var_cte -> CTE_FLOAT np_push_cte_float .)
    L_BRACE         reduce using rule 114 (var_cte -> CTE_FLOAT np_push_cte_float .)


state 165

    (115) var_cte -> CTE_CHAR np_push_cte_char .

    EXP             reduce using rule 115 (var_cte -> CTE_CHAR np_push_cte_char .)
    MULT            reduce using rule 115 (var_cte -> CTE_CHAR np_push_cte_char .)
    DIV             reduce using rule 115 (var_cte -> CTE_CHAR np_push_cte_char .)
    REMAINDER       reduce using rule 115 (var_cte -> CTE_CHAR np_push_cte_char .)
    PLUS            reduce using rule 115 (var_cte -> CTE_CHAR np_push_cte_char .)
    MINUS           reduce using rule 115 (var_cte -> CTE_CHAR np_push_cte_char .)
    R_BRACKET       reduce using rule 115 (var_cte -> CTE_CHAR np_push_cte_char .)
    LESS            reduce using rule 115 (var_cte -> CTE_CHAR np_push_cte_char .)
    GREATER         reduce using rule 115 (var_cte -> CTE_CHAR np_push_cte_char .)
    LESS_EQ         reduce using rule 115 (var_cte -> CTE_CHAR np_push_cte_char .)
    GREATER_EQ      reduce using rule 115 (var_cte -> CTE_CHAR np_push_cte_char .)
    EQUIVALENT      reduce using rule 115 (var_cte -> CTE_CHAR np_push_cte_char .)
    DIFFERENT       reduce using rule 115 (var_cte -> CTE_CHAR np_push_cte_char .)
    OR              reduce using rule 115 (var_cte -> CTE_CHAR np_push_cte_char .)
    AND             reduce using rule 115 (var_cte -> CTE_CHAR np_push_cte_char .)
    R_PAR           reduce using rule 115 (var_cte -> CTE_CHAR np_push_cte_char .)
    COMMA           reduce using rule 115 (var_cte -> CTE_CHAR np_push_cte_char .)
    SEMICOLON       reduce using rule 115 (var_cte -> CTE_CHAR np_push_cte_char .)
    TO              reduce using rule 115 (var_cte -> CTE_CHAR np_push_cte_char .)
    L_BRACE         reduce using rule 115 (var_cte -> CTE_CHAR np_push_cte_char .)


state 166

    (116) var_cte -> CTE_STRING np_push_cte_str .

    EXP             reduce using rule 116 (var_cte -> CTE_STRING np_push_cte_str .)
    MULT            reduce using rule 116 (var_cte -> CTE_STRING np_push_cte_str .)
    DIV             reduce using rule 116 (var_cte -> CTE_STRING np_push_cte_str .)
    REMAINDER       reduce using rule 116 (var_cte -> CTE_STRING np_push_cte_str .)
    PLUS            reduce using rule 116 (var_cte -> CTE_STRING np_push_cte_str .)
    MINUS           reduce using rule 116 (var_cte -> CTE_STRING np_push_cte_str .)
    R_BRACKET       reduce using rule 116 (var_cte -> CTE_STRING np_push_cte_str .)
    LESS            reduce using rule 116 (var_cte -> CTE_STRING np_push_cte_str .)
    GREATER         reduce using rule 116 (var_cte -> CTE_STRING np_push_cte_str .)
    LESS_EQ         reduce using rule 116 (var_cte -> CTE_STRING np_push_cte_str .)
    GREATER_EQ      reduce using rule 116 (var_cte -> CTE_STRING np_push_cte_str .)
    EQUIVALENT      reduce using rule 116 (var_cte -> CTE_STRING np_push_cte_str .)
    DIFFERENT       reduce using rule 116 (var_cte -> CTE_STRING np_push_cte_str .)
    OR              reduce using rule 116 (var_cte -> CTE_STRING np_push_cte_str .)
    AND             reduce using rule 116 (var_cte -> CTE_STRING np_push_cte_str .)
    R_PAR           reduce using rule 116 (var_cte -> CTE_STRING np_push_cte_str .)
    COMMA           reduce using rule 116 (var_cte -> CTE_STRING np_push_cte_str .)
    SEMICOLON       reduce using rule 116 (var_cte -> CTE_STRING np_push_cte_str .)
    TO              reduce using rule 116 (var_cte -> CTE_STRING np_push_cte_str .)
    L_BRACE         reduce using rule 116 (var_cte -> CTE_STRING np_push_cte_str .)


state 167

    (117) var_cte -> CTE_BOOL np_push_cte_bool .

    EXP             reduce using rule 117 (var_cte -> CTE_BOOL np_push_cte_bool .)
    MULT            reduce using rule 117 (var_cte -> CTE_BOOL np_push_cte_bool .)
    DIV             reduce using rule 117 (var_cte -> CTE_BOOL np_push_cte_bool .)
    REMAINDER       reduce using rule 117 (var_cte -> CTE_BOOL np_push_cte_bool .)
    PLUS            reduce using rule 117 (var_cte -> CTE_BOOL np_push_cte_bool .)
    MINUS           reduce using rule 117 (var_cte -> CTE_BOOL np_push_cte_bool .)
    R_BRACKET       reduce using rule 117 (var_cte -> CTE_BOOL np_push_cte_bool .)
    LESS            reduce using rule 117 (var_cte -> CTE_BOOL np_push_cte_bool .)
    GREATER         reduce using rule 117 (var_cte -> CTE_BOOL np_push_cte_bool .)
    LESS_EQ         reduce using rule 117 (var_cte -> CTE_BOOL np_push_cte_bool .)
    GREATER_EQ      reduce using rule 117 (var_cte -> CTE_BOOL np_push_cte_bool .)
    EQUIVALENT      reduce using rule 117 (var_cte -> CTE_BOOL np_push_cte_bool .)
    DIFFERENT       reduce using rule 117 (var_cte -> CTE_BOOL np_push_cte_bool .)
    OR              reduce using rule 117 (var_cte -> CTE_BOOL np_push_cte_bool .)
    AND             reduce using rule 117 (var_cte -> CTE_BOOL np_push_cte_bool .)
    R_PAR           reduce using rule 117 (var_cte -> CTE_BOOL np_push_cte_bool .)
    COMMA           reduce using rule 117 (var_cte -> CTE_BOOL np_push_cte_bool .)
    SEMICOLON       reduce using rule 117 (var_cte -> CTE_BOOL np_push_cte_bool .)
    TO              reduce using rule 117 (var_cte -> CTE_BOOL np_push_cte_bool .)
    L_BRACE         reduce using rule 117 (var_cte -> CTE_BOOL np_push_cte_bool .)


state 168

    (43) predef_func -> LENGTH L_PAR . vector R_PAR
    (20) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 209

    vector                         shift and go to state 208

state 169

    (44) predef_func -> MIN L_PAR . vector R_PAR
    (20) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 209

    vector                         shift and go to state 210

state 170

    (45) predef_func -> MAX L_PAR . vector R_PAR
    (20) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 209

    vector                         shift and go to state 211

state 171

    (46) predef_func -> MEAN L_PAR . vector R_PAR
    (20) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 209

    vector                         shift and go to state 212

state 172

    (47) predef_func -> MEDIAN L_PAR . vector R_PAR
    (20) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 209

    vector                         shift and go to state 213

state 173

    (48) predef_func -> MODE L_PAR . vector R_PAR
    (20) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 209

    vector                         shift and go to state 214

state 174

    (49) predef_func -> PLOT_XY L_PAR . vector COMMA vector R_PAR
    (20) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 209

    vector                         shift and go to state 215

state 175

    (50) predef_func -> REGRESSION L_PAR . vector COMMA vector R_PAR
    (20) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 209

    vector                         shift and go to state 216

state 176

    (51) predef_func -> VARIANCE L_PAR . vector R_PAR
    (20) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 209

    vector                         shift and go to state 217

state 177

    (52) predef_func -> DOT L_PAR . vector COMMA vector R_PAR
    (20) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 209

    vector                         shift and go to state 218

state 178

    (53) predef_func -> SUM L_PAR . vector R_PAR
    (20) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 209

    vector                         shift and go to state 219

state 179

    (54) predef_func -> ABS L_PAR . CTE_INT R_PAR

    CTE_INT         shift and go to state 220


state 180

    (55) predef_func -> ROOF L_PAR . CTE_FLOAT R_PAR

    CTE_FLOAT       shift and go to state 221


state 181

    (56) predef_func -> FLOOR L_PAR . CTE_FLOAT R_PAR

    CTE_FLOAT       shift and go to state 222


state 182

    (11) function -> FUNCTION func_type ID np_set_curr_proc L_PAR params R_PAR np_set_quad_start vblock np_ENDFunc .

    FUNCTION        reduce using rule 11 (function -> FUNCTION func_type ID np_set_curr_proc L_PAR params R_PAR np_set_quad_start vblock np_ENDFunc .)
    MAIN            reduce using rule 11 (function -> FUNCTION func_type ID np_set_curr_proc L_PAR params R_PAR np_set_quad_start vblock np_ENDFunc .)


state 183

    (31) params -> type COLON ID np_add_param COMMA . params
    (30) params -> . type COLON ID np_add_param
    (31) params -> . type COLON ID np_add_param COMMA params
    (32) params -> . empty
    (13) type -> . INT
    (14) type -> . FLOAT
    (15) type -> . BOOL
    (16) type -> . CHAR
    (17) type -> . STRING
    (118) empty -> .

    INT             shift and go to state 22
    FLOAT           shift and go to state 23
    BOOL            shift and go to state 24
    CHAR            shift and go to state 25
    STRING          shift and go to state 26
    R_PAR           reduce using rule 118 (empty -> .)

    type                           shift and go to state 43
    params                         shift and go to state 223
    empty                          shift and go to state 44

state 184

    (42) assign -> var np_push_operand oper_assign np_push_operator . expression np_end SEMICOLON
    (75) expression -> . not logic expressionB
    (84) not -> . NOT np_push_operator
    (85) not -> . empty
    (118) empty -> .

    NOT             shift and go to state 136
    L_PAR           reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    CTE_INT         reduce using rule 118 (empty -> .)
    CTE_FLOAT       reduce using rule 118 (empty -> .)
    CTE_CHAR        reduce using rule 118 (empty -> .)
    CTE_STRING      reduce using rule 118 (empty -> .)
    CTE_BOOL        reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    LENGTH          reduce using rule 118 (empty -> .)
    MIN             reduce using rule 118 (empty -> .)
    MAX             reduce using rule 118 (empty -> .)
    MEAN            reduce using rule 118 (empty -> .)
    MEDIAN          reduce using rule 118 (empty -> .)
    MODE            reduce using rule 118 (empty -> .)
    PLOT_XY         reduce using rule 118 (empty -> .)
    REGRESSION      reduce using rule 118 (empty -> .)
    VARIANCE        reduce using rule 118 (empty -> .)
    DOT             reduce using rule 118 (empty -> .)
    SUM             reduce using rule 118 (empty -> .)
    ABS             reduce using rule 118 (empty -> .)
    ROOF            reduce using rule 118 (empty -> .)
    FLOOR           reduce using rule 118 (empty -> .)

    expression                     shift and go to state 224
    not                            shift and go to state 135
    empty                          shift and go to state 137

state 185

    (57) condicional -> IF L_PAR expression np_end . np_GOTOF R_PAR block cond2 np_GOTO_END
    (139) np_GOTOF -> .

    R_PAR           reduce using rule 139 (np_GOTOF -> .)

    np_GOTOF                       shift and go to state 225

state 186

    (75) expression -> not logic . expressionB
    (76) expressionB -> . OR np_push_operator expression
    (77) expressionB -> . AND np_push_operator expression
    (78) expressionB -> . empty
    (118) empty -> .

    OR              shift and go to state 227
    AND             shift and go to state 228
    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)

    expressionB                    shift and go to state 226
    empty                          shift and go to state 229

state 187

    (86) logic -> exp . logic2
    (87) logic2 -> . LESS np_push_operator exp
    (88) logic2 -> . GREATER np_push_operator exp
    (89) logic2 -> . LESS_EQ np_push_operator exp
    (90) logic2 -> . GREATER_EQ np_push_operator exp
    (91) logic2 -> . EQUIVALENT np_push_operator exp
    (92) logic2 -> . DIFFERENT np_push_operator exp
    (93) logic2 -> . empty
    (118) empty -> .

    LESS            shift and go to state 231
    GREATER         shift and go to state 232
    LESS_EQ         shift and go to state 233
    GREATER_EQ      shift and go to state 234
    EQUIVALENT      shift and go to state 235
    DIFFERENT       shift and go to state 236
    OR              reduce using rule 118 (empty -> .)
    AND             reduce using rule 118 (empty -> .)
    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)

    logic2                         shift and go to state 230
    empty                          shift and go to state 237

state 188

    (84) not -> NOT np_push_operator .

    L_PAR           reduce using rule 84 (not -> NOT np_push_operator .)
    MINUS           reduce using rule 84 (not -> NOT np_push_operator .)
    CTE_INT         reduce using rule 84 (not -> NOT np_push_operator .)
    CTE_FLOAT       reduce using rule 84 (not -> NOT np_push_operator .)
    CTE_CHAR        reduce using rule 84 (not -> NOT np_push_operator .)
    CTE_STRING      reduce using rule 84 (not -> NOT np_push_operator .)
    CTE_BOOL        reduce using rule 84 (not -> NOT np_push_operator .)
    ID              reduce using rule 84 (not -> NOT np_push_operator .)
    LENGTH          reduce using rule 84 (not -> NOT np_push_operator .)
    MIN             reduce using rule 84 (not -> NOT np_push_operator .)
    MAX             reduce using rule 84 (not -> NOT np_push_operator .)
    MEAN            reduce using rule 84 (not -> NOT np_push_operator .)
    MEDIAN          reduce using rule 84 (not -> NOT np_push_operator .)
    MODE            reduce using rule 84 (not -> NOT np_push_operator .)
    PLOT_XY         reduce using rule 84 (not -> NOT np_push_operator .)
    REGRESSION      reduce using rule 84 (not -> NOT np_push_operator .)
    VARIANCE        reduce using rule 84 (not -> NOT np_push_operator .)
    DOT             reduce using rule 84 (not -> NOT np_push_operator .)
    SUM             reduce using rule 84 (not -> NOT np_push_operator .)
    ABS             reduce using rule 84 (not -> NOT np_push_operator .)
    ROOF            reduce using rule 84 (not -> NOT np_push_operator .)
    FLOOR           reduce using rule 84 (not -> NOT np_push_operator .)


state 189

    (60) read -> READ L_PAR read2 R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 238


state 190

    (61) read2 -> var np_read .
    (62) read2 -> var np_read . COMMA read2

    R_PAR           reduce using rule 61 (read2 -> var np_read .)
    COMMA           shift and go to state 239


state 191

    (63) write -> WRITE L_PAR writeB R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 240


state 192

    (64) writeB -> expression np_end . np_write writeC
    (135) np_write -> .

    COMMA           reduce using rule 135 (np_write -> .)
    R_PAR           reduce using rule 135 (np_write -> .)

    np_write                       shift and go to state 241

state 193

    (65) writeB -> CTE_STRING np_push_cte_str . np_write writeC
    (135) np_write -> .

    COMMA           reduce using rule 135 (np_write -> .)
    R_PAR           reduce using rule 135 (np_write -> .)

    np_write                       shift and go to state 242

state 194

    (68) loop_cond -> WHILE L_PAR np_CHECKPOINT expression . R_PAR np_end np_GOTOF block np_GOTO_WHILE

    R_PAR           shift and go to state 243


state 195

    (69) loop_range -> FOR var np_push_operand EQUAL . np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR
    (120) np_push_operator -> .

    L_PAR           reduce using rule 120 (np_push_operator -> .)
    MINUS           reduce using rule 120 (np_push_operator -> .)
    CTE_INT         reduce using rule 120 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 120 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 120 (np_push_operator -> .)
    CTE_STRING      reduce using rule 120 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 120 (np_push_operator -> .)
    ID              reduce using rule 120 (np_push_operator -> .)
    LENGTH          reduce using rule 120 (np_push_operator -> .)
    MIN             reduce using rule 120 (np_push_operator -> .)
    MAX             reduce using rule 120 (np_push_operator -> .)
    MEAN            reduce using rule 120 (np_push_operator -> .)
    MEDIAN          reduce using rule 120 (np_push_operator -> .)
    MODE            reduce using rule 120 (np_push_operator -> .)
    PLOT_XY         reduce using rule 120 (np_push_operator -> .)
    REGRESSION      reduce using rule 120 (np_push_operator -> .)
    VARIANCE        reduce using rule 120 (np_push_operator -> .)
    DOT             reduce using rule 120 (np_push_operator -> .)
    SUM             reduce using rule 120 (np_push_operator -> .)
    ABS             reduce using rule 120 (np_push_operator -> .)
    ROOF            reduce using rule 120 (np_push_operator -> .)
    FLOOR           reduce using rule 120 (np_push_operator -> .)

    np_push_operator               shift and go to state 244

state 196

    (70) return -> RETURN L_PAR np_stop exp . np_end np_set_return R_PAR SEMICOLON
    (133) np_end -> .

    R_PAR           reduce using rule 133 (np_end -> .)

    np_end                         shift and go to state 245

state 197

    (71) func_call -> ID np_ERA L_PAR func_call_arguments . R_PAR np_GOSUB

    R_PAR           shift and go to state 246


state 198

    (72) func_call_arguments -> np_stop . exp np_end np_param
    (73) func_call_arguments -> np_stop . exp np_end np_param COMMA func_call_arguments
    (94) exp -> . term exp2
    (98) term -> . factor term2
    (103) factor -> . exponent factorB
    (106) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (107) exponent -> . exponentB
    (108) exponentB -> . MINUS var_cte
    (109) exponentB -> . var_cte
    (110) var_cte -> . var np_push_operand
    (111) var_cte -> . predef_func
    (112) var_cte -> . func_call
    (113) var_cte -> . CTE_INT np_push_cte_int
    (114) var_cte -> . CTE_FLOAT np_push_cte_float
    (115) var_cte -> . CTE_CHAR np_push_cte_char
    (116) var_cte -> . CTE_STRING np_push_cte_str
    (117) var_cte -> . CTE_BOOL np_push_cte_bool
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (43) predef_func -> . LENGTH L_PAR vector R_PAR
    (44) predef_func -> . MIN L_PAR vector R_PAR
    (45) predef_func -> . MAX L_PAR vector R_PAR
    (46) predef_func -> . MEAN L_PAR vector R_PAR
    (47) predef_func -> . MEDIAN L_PAR vector R_PAR
    (48) predef_func -> . MODE L_PAR vector R_PAR
    (49) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (50) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . VARIANCE L_PAR vector R_PAR
    (52) predef_func -> . DOT L_PAR vector COMMA vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (54) predef_func -> . ABS L_PAR CTE_INT R_PAR
    (55) predef_func -> . ROOF L_PAR CTE_FLOAT R_PAR
    (56) predef_func -> . FLOOR L_PAR CTE_FLOAT R_PAR
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 98
    MINUS           shift and go to state 100
    CTE_INT         shift and go to state 105
    CTE_FLOAT       shift and go to state 106
    CTE_CHAR        shift and go to state 107
    CTE_STRING      shift and go to state 108
    CTE_BOOL        shift and go to state 109
    ID              shift and go to state 73
    LENGTH          shift and go to state 110
    MIN             shift and go to state 111
    MAX             shift and go to state 112
    MEAN            shift and go to state 113
    MEDIAN          shift and go to state 114
    MODE            shift and go to state 115
    PLOT_XY         shift and go to state 116
    REGRESSION      shift and go to state 117
    VARIANCE        shift and go to state 118
    DOT             shift and go to state 119
    SUM             shift and go to state 120
    ABS             shift and go to state 121
    ROOF            shift and go to state 122
    FLOOR           shift and go to state 123

    exp                            shift and go to state 247
    term                           shift and go to state 95
    factor                         shift and go to state 96
    exponent                       shift and go to state 97
    exponentB                      shift and go to state 99
    var_cte                        shift and go to state 101
    var                            shift and go to state 102
    predef_func                    shift and go to state 103
    func_call                      shift and go to state 104

state 199

    (74) func_call_arguments -> empty .

    R_PAR           reduce using rule 74 (func_call_arguments -> empty .)


state 200

    (18) var -> ID L_BRACKET np_arr_start exp np_end np_arr_end . R_BRACKET

    R_BRACKET       shift and go to state 248


state 201

    (95) exp2 -> PLUS np_push_operator . exp
    (94) exp -> . term exp2
    (98) term -> . factor term2
    (103) factor -> . exponent factorB
    (106) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (107) exponent -> . exponentB
    (108) exponentB -> . MINUS var_cte
    (109) exponentB -> . var_cte
    (110) var_cte -> . var np_push_operand
    (111) var_cte -> . predef_func
    (112) var_cte -> . func_call
    (113) var_cte -> . CTE_INT np_push_cte_int
    (114) var_cte -> . CTE_FLOAT np_push_cte_float
    (115) var_cte -> . CTE_CHAR np_push_cte_char
    (116) var_cte -> . CTE_STRING np_push_cte_str
    (117) var_cte -> . CTE_BOOL np_push_cte_bool
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (43) predef_func -> . LENGTH L_PAR vector R_PAR
    (44) predef_func -> . MIN L_PAR vector R_PAR
    (45) predef_func -> . MAX L_PAR vector R_PAR
    (46) predef_func -> . MEAN L_PAR vector R_PAR
    (47) predef_func -> . MEDIAN L_PAR vector R_PAR
    (48) predef_func -> . MODE L_PAR vector R_PAR
    (49) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (50) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . VARIANCE L_PAR vector R_PAR
    (52) predef_func -> . DOT L_PAR vector COMMA vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (54) predef_func -> . ABS L_PAR CTE_INT R_PAR
    (55) predef_func -> . ROOF L_PAR CTE_FLOAT R_PAR
    (56) predef_func -> . FLOOR L_PAR CTE_FLOAT R_PAR
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 98
    MINUS           shift and go to state 100
    CTE_INT         shift and go to state 105
    CTE_FLOAT       shift and go to state 106
    CTE_CHAR        shift and go to state 107
    CTE_STRING      shift and go to state 108
    CTE_BOOL        shift and go to state 109
    ID              shift and go to state 73
    LENGTH          shift and go to state 110
    MIN             shift and go to state 111
    MAX             shift and go to state 112
    MEAN            shift and go to state 113
    MEDIAN          shift and go to state 114
    MODE            shift and go to state 115
    PLOT_XY         shift and go to state 116
    REGRESSION      shift and go to state 117
    VARIANCE        shift and go to state 118
    DOT             shift and go to state 119
    SUM             shift and go to state 120
    ABS             shift and go to state 121
    ROOF            shift and go to state 122
    FLOOR           shift and go to state 123

    exp                            shift and go to state 249
    term                           shift and go to state 95
    factor                         shift and go to state 96
    exponent                       shift and go to state 97
    exponentB                      shift and go to state 99
    var_cte                        shift and go to state 101
    var                            shift and go to state 102
    predef_func                    shift and go to state 103
    func_call                      shift and go to state 104

state 202

    (96) exp2 -> MINUS np_push_operator . exp
    (94) exp -> . term exp2
    (98) term -> . factor term2
    (103) factor -> . exponent factorB
    (106) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (107) exponent -> . exponentB
    (108) exponentB -> . MINUS var_cte
    (109) exponentB -> . var_cte
    (110) var_cte -> . var np_push_operand
    (111) var_cte -> . predef_func
    (112) var_cte -> . func_call
    (113) var_cte -> . CTE_INT np_push_cte_int
    (114) var_cte -> . CTE_FLOAT np_push_cte_float
    (115) var_cte -> . CTE_CHAR np_push_cte_char
    (116) var_cte -> . CTE_STRING np_push_cte_str
    (117) var_cte -> . CTE_BOOL np_push_cte_bool
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (43) predef_func -> . LENGTH L_PAR vector R_PAR
    (44) predef_func -> . MIN L_PAR vector R_PAR
    (45) predef_func -> . MAX L_PAR vector R_PAR
    (46) predef_func -> . MEAN L_PAR vector R_PAR
    (47) predef_func -> . MEDIAN L_PAR vector R_PAR
    (48) predef_func -> . MODE L_PAR vector R_PAR
    (49) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (50) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . VARIANCE L_PAR vector R_PAR
    (52) predef_func -> . DOT L_PAR vector COMMA vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (54) predef_func -> . ABS L_PAR CTE_INT R_PAR
    (55) predef_func -> . ROOF L_PAR CTE_FLOAT R_PAR
    (56) predef_func -> . FLOOR L_PAR CTE_FLOAT R_PAR
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 98
    MINUS           shift and go to state 100
    CTE_INT         shift and go to state 105
    CTE_FLOAT       shift and go to state 106
    CTE_CHAR        shift and go to state 107
    CTE_STRING      shift and go to state 108
    CTE_BOOL        shift and go to state 109
    ID              shift and go to state 73
    LENGTH          shift and go to state 110
    MIN             shift and go to state 111
    MAX             shift and go to state 112
    MEAN            shift and go to state 113
    MEDIAN          shift and go to state 114
    MODE            shift and go to state 115
    PLOT_XY         shift and go to state 116
    REGRESSION      shift and go to state 117
    VARIANCE        shift and go to state 118
    DOT             shift and go to state 119
    SUM             shift and go to state 120
    ABS             shift and go to state 121
    ROOF            shift and go to state 122
    FLOOR           shift and go to state 123

    exp                            shift and go to state 250
    term                           shift and go to state 95
    factor                         shift and go to state 96
    exponent                       shift and go to state 97
    exponentB                      shift and go to state 99
    var_cte                        shift and go to state 101
    var                            shift and go to state 102
    predef_func                    shift and go to state 103
    func_call                      shift and go to state 104

state 203

    (99) term2 -> MULT np_push_operator . term
    (98) term -> . factor term2
    (103) factor -> . exponent factorB
    (106) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (107) exponent -> . exponentB
    (108) exponentB -> . MINUS var_cte
    (109) exponentB -> . var_cte
    (110) var_cte -> . var np_push_operand
    (111) var_cte -> . predef_func
    (112) var_cte -> . func_call
    (113) var_cte -> . CTE_INT np_push_cte_int
    (114) var_cte -> . CTE_FLOAT np_push_cte_float
    (115) var_cte -> . CTE_CHAR np_push_cte_char
    (116) var_cte -> . CTE_STRING np_push_cte_str
    (117) var_cte -> . CTE_BOOL np_push_cte_bool
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (43) predef_func -> . LENGTH L_PAR vector R_PAR
    (44) predef_func -> . MIN L_PAR vector R_PAR
    (45) predef_func -> . MAX L_PAR vector R_PAR
    (46) predef_func -> . MEAN L_PAR vector R_PAR
    (47) predef_func -> . MEDIAN L_PAR vector R_PAR
    (48) predef_func -> . MODE L_PAR vector R_PAR
    (49) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (50) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . VARIANCE L_PAR vector R_PAR
    (52) predef_func -> . DOT L_PAR vector COMMA vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (54) predef_func -> . ABS L_PAR CTE_INT R_PAR
    (55) predef_func -> . ROOF L_PAR CTE_FLOAT R_PAR
    (56) predef_func -> . FLOOR L_PAR CTE_FLOAT R_PAR
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 98
    MINUS           shift and go to state 100
    CTE_INT         shift and go to state 105
    CTE_FLOAT       shift and go to state 106
    CTE_CHAR        shift and go to state 107
    CTE_STRING      shift and go to state 108
    CTE_BOOL        shift and go to state 109
    ID              shift and go to state 73
    LENGTH          shift and go to state 110
    MIN             shift and go to state 111
    MAX             shift and go to state 112
    MEAN            shift and go to state 113
    MEDIAN          shift and go to state 114
    MODE            shift and go to state 115
    PLOT_XY         shift and go to state 116
    REGRESSION      shift and go to state 117
    VARIANCE        shift and go to state 118
    DOT             shift and go to state 119
    SUM             shift and go to state 120
    ABS             shift and go to state 121
    ROOF            shift and go to state 122
    FLOOR           shift and go to state 123

    term                           shift and go to state 251
    factor                         shift and go to state 96
    exponent                       shift and go to state 97
    exponentB                      shift and go to state 99
    var_cte                        shift and go to state 101
    var                            shift and go to state 102
    predef_func                    shift and go to state 103
    func_call                      shift and go to state 104

state 204

    (100) term2 -> DIV np_push_operator . term
    (98) term -> . factor term2
    (103) factor -> . exponent factorB
    (106) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (107) exponent -> . exponentB
    (108) exponentB -> . MINUS var_cte
    (109) exponentB -> . var_cte
    (110) var_cte -> . var np_push_operand
    (111) var_cte -> . predef_func
    (112) var_cte -> . func_call
    (113) var_cte -> . CTE_INT np_push_cte_int
    (114) var_cte -> . CTE_FLOAT np_push_cte_float
    (115) var_cte -> . CTE_CHAR np_push_cte_char
    (116) var_cte -> . CTE_STRING np_push_cte_str
    (117) var_cte -> . CTE_BOOL np_push_cte_bool
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (43) predef_func -> . LENGTH L_PAR vector R_PAR
    (44) predef_func -> . MIN L_PAR vector R_PAR
    (45) predef_func -> . MAX L_PAR vector R_PAR
    (46) predef_func -> . MEAN L_PAR vector R_PAR
    (47) predef_func -> . MEDIAN L_PAR vector R_PAR
    (48) predef_func -> . MODE L_PAR vector R_PAR
    (49) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (50) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . VARIANCE L_PAR vector R_PAR
    (52) predef_func -> . DOT L_PAR vector COMMA vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (54) predef_func -> . ABS L_PAR CTE_INT R_PAR
    (55) predef_func -> . ROOF L_PAR CTE_FLOAT R_PAR
    (56) predef_func -> . FLOOR L_PAR CTE_FLOAT R_PAR
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 98
    MINUS           shift and go to state 100
    CTE_INT         shift and go to state 105
    CTE_FLOAT       shift and go to state 106
    CTE_CHAR        shift and go to state 107
    CTE_STRING      shift and go to state 108
    CTE_BOOL        shift and go to state 109
    ID              shift and go to state 73
    LENGTH          shift and go to state 110
    MIN             shift and go to state 111
    MAX             shift and go to state 112
    MEAN            shift and go to state 113
    MEDIAN          shift and go to state 114
    MODE            shift and go to state 115
    PLOT_XY         shift and go to state 116
    REGRESSION      shift and go to state 117
    VARIANCE        shift and go to state 118
    DOT             shift and go to state 119
    SUM             shift and go to state 120
    ABS             shift and go to state 121
    ROOF            shift and go to state 122
    FLOOR           shift and go to state 123

    term                           shift and go to state 252
    factor                         shift and go to state 96
    exponent                       shift and go to state 97
    exponentB                      shift and go to state 99
    var_cte                        shift and go to state 101
    var                            shift and go to state 102
    predef_func                    shift and go to state 103
    func_call                      shift and go to state 104

state 205

    (101) term2 -> REMAINDER np_push_operator . term
    (98) term -> . factor term2
    (103) factor -> . exponent factorB
    (106) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (107) exponent -> . exponentB
    (108) exponentB -> . MINUS var_cte
    (109) exponentB -> . var_cte
    (110) var_cte -> . var np_push_operand
    (111) var_cte -> . predef_func
    (112) var_cte -> . func_call
    (113) var_cte -> . CTE_INT np_push_cte_int
    (114) var_cte -> . CTE_FLOAT np_push_cte_float
    (115) var_cte -> . CTE_CHAR np_push_cte_char
    (116) var_cte -> . CTE_STRING np_push_cte_str
    (117) var_cte -> . CTE_BOOL np_push_cte_bool
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (43) predef_func -> . LENGTH L_PAR vector R_PAR
    (44) predef_func -> . MIN L_PAR vector R_PAR
    (45) predef_func -> . MAX L_PAR vector R_PAR
    (46) predef_func -> . MEAN L_PAR vector R_PAR
    (47) predef_func -> . MEDIAN L_PAR vector R_PAR
    (48) predef_func -> . MODE L_PAR vector R_PAR
    (49) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (50) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . VARIANCE L_PAR vector R_PAR
    (52) predef_func -> . DOT L_PAR vector COMMA vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (54) predef_func -> . ABS L_PAR CTE_INT R_PAR
    (55) predef_func -> . ROOF L_PAR CTE_FLOAT R_PAR
    (56) predef_func -> . FLOOR L_PAR CTE_FLOAT R_PAR
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 98
    MINUS           shift and go to state 100
    CTE_INT         shift and go to state 105
    CTE_FLOAT       shift and go to state 106
    CTE_CHAR        shift and go to state 107
    CTE_STRING      shift and go to state 108
    CTE_BOOL        shift and go to state 109
    ID              shift and go to state 73
    LENGTH          shift and go to state 110
    MIN             shift and go to state 111
    MAX             shift and go to state 112
    MEAN            shift and go to state 113
    MEDIAN          shift and go to state 114
    MODE            shift and go to state 115
    PLOT_XY         shift and go to state 116
    REGRESSION      shift and go to state 117
    VARIANCE        shift and go to state 118
    DOT             shift and go to state 119
    SUM             shift and go to state 120
    ABS             shift and go to state 121
    ROOF            shift and go to state 122
    FLOOR           shift and go to state 123

    term                           shift and go to state 253
    factor                         shift and go to state 96
    exponent                       shift and go to state 97
    exponentB                      shift and go to state 99
    var_cte                        shift and go to state 101
    var                            shift and go to state 102
    predef_func                    shift and go to state 103
    func_call                      shift and go to state 104

state 206

    (104) factorB -> EXP factor .

    MULT            reduce using rule 104 (factorB -> EXP factor .)
    DIV             reduce using rule 104 (factorB -> EXP factor .)
    REMAINDER       reduce using rule 104 (factorB -> EXP factor .)
    PLUS            reduce using rule 104 (factorB -> EXP factor .)
    MINUS           reduce using rule 104 (factorB -> EXP factor .)
    R_BRACKET       reduce using rule 104 (factorB -> EXP factor .)
    LESS            reduce using rule 104 (factorB -> EXP factor .)
    GREATER         reduce using rule 104 (factorB -> EXP factor .)
    LESS_EQ         reduce using rule 104 (factorB -> EXP factor .)
    GREATER_EQ      reduce using rule 104 (factorB -> EXP factor .)
    EQUIVALENT      reduce using rule 104 (factorB -> EXP factor .)
    DIFFERENT       reduce using rule 104 (factorB -> EXP factor .)
    OR              reduce using rule 104 (factorB -> EXP factor .)
    AND             reduce using rule 104 (factorB -> EXP factor .)
    R_PAR           reduce using rule 104 (factorB -> EXP factor .)
    COMMA           reduce using rule 104 (factorB -> EXP factor .)
    SEMICOLON       reduce using rule 104 (factorB -> EXP factor .)
    TO              reduce using rule 104 (factorB -> EXP factor .)
    L_BRACE         reduce using rule 104 (factorB -> EXP factor .)


state 207

    (106) exponent -> L_PAR np_push_operator expression . R_PAR np_rpar

    R_PAR           shift and go to state 254


state 208

    (43) predef_func -> LENGTH L_PAR vector . R_PAR

    R_PAR           shift and go to state 255


state 209

    (20) vector -> ID . L_BRACKET R_BRACKET

    L_BRACKET       shift and go to state 256


state 210

    (44) predef_func -> MIN L_PAR vector . R_PAR

    R_PAR           shift and go to state 257


state 211

    (45) predef_func -> MAX L_PAR vector . R_PAR

    R_PAR           shift and go to state 258


state 212

    (46) predef_func -> MEAN L_PAR vector . R_PAR

    R_PAR           shift and go to state 259


state 213

    (47) predef_func -> MEDIAN L_PAR vector . R_PAR

    R_PAR           shift and go to state 260


state 214

    (48) predef_func -> MODE L_PAR vector . R_PAR

    R_PAR           shift and go to state 261


state 215

    (49) predef_func -> PLOT_XY L_PAR vector . COMMA vector R_PAR

    COMMA           shift and go to state 262


state 216

    (50) predef_func -> REGRESSION L_PAR vector . COMMA vector R_PAR

    COMMA           shift and go to state 263


state 217

    (51) predef_func -> VARIANCE L_PAR vector . R_PAR

    R_PAR           shift and go to state 264


state 218

    (52) predef_func -> DOT L_PAR vector . COMMA vector R_PAR

    COMMA           shift and go to state 265


state 219

    (53) predef_func -> SUM L_PAR vector . R_PAR

    R_PAR           shift and go to state 266


state 220

    (54) predef_func -> ABS L_PAR CTE_INT . R_PAR

    R_PAR           shift and go to state 267


state 221

    (55) predef_func -> ROOF L_PAR CTE_FLOAT . R_PAR

    R_PAR           shift and go to state 268


state 222

    (56) predef_func -> FLOOR L_PAR CTE_FLOAT . R_PAR

    R_PAR           shift and go to state 269


state 223

    (31) params -> type COLON ID np_add_param COMMA params .

    R_PAR           reduce using rule 31 (params -> type COLON ID np_add_param COMMA params .)


state 224

    (42) assign -> var np_push_operand oper_assign np_push_operator expression . np_end SEMICOLON
    (133) np_end -> .

    SEMICOLON       reduce using rule 133 (np_end -> .)

    np_end                         shift and go to state 270

state 225

    (57) condicional -> IF L_PAR expression np_end np_GOTOF . R_PAR block cond2 np_GOTO_END

    R_PAR           shift and go to state 271


state 226

    (75) expression -> not logic expressionB .

    R_PAR           reduce using rule 75 (expression -> not logic expressionB .)
    COMMA           reduce using rule 75 (expression -> not logic expressionB .)
    SEMICOLON       reduce using rule 75 (expression -> not logic expressionB .)


state 227

    (76) expressionB -> OR . np_push_operator expression
    (120) np_push_operator -> .

    NOT             reduce using rule 120 (np_push_operator -> .)
    L_PAR           reduce using rule 120 (np_push_operator -> .)
    MINUS           reduce using rule 120 (np_push_operator -> .)
    CTE_INT         reduce using rule 120 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 120 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 120 (np_push_operator -> .)
    CTE_STRING      reduce using rule 120 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 120 (np_push_operator -> .)
    ID              reduce using rule 120 (np_push_operator -> .)
    LENGTH          reduce using rule 120 (np_push_operator -> .)
    MIN             reduce using rule 120 (np_push_operator -> .)
    MAX             reduce using rule 120 (np_push_operator -> .)
    MEAN            reduce using rule 120 (np_push_operator -> .)
    MEDIAN          reduce using rule 120 (np_push_operator -> .)
    MODE            reduce using rule 120 (np_push_operator -> .)
    PLOT_XY         reduce using rule 120 (np_push_operator -> .)
    REGRESSION      reduce using rule 120 (np_push_operator -> .)
    VARIANCE        reduce using rule 120 (np_push_operator -> .)
    DOT             reduce using rule 120 (np_push_operator -> .)
    SUM             reduce using rule 120 (np_push_operator -> .)
    ABS             reduce using rule 120 (np_push_operator -> .)
    ROOF            reduce using rule 120 (np_push_operator -> .)
    FLOOR           reduce using rule 120 (np_push_operator -> .)

    np_push_operator               shift and go to state 272

state 228

    (77) expressionB -> AND . np_push_operator expression
    (120) np_push_operator -> .

    NOT             reduce using rule 120 (np_push_operator -> .)
    L_PAR           reduce using rule 120 (np_push_operator -> .)
    MINUS           reduce using rule 120 (np_push_operator -> .)
    CTE_INT         reduce using rule 120 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 120 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 120 (np_push_operator -> .)
    CTE_STRING      reduce using rule 120 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 120 (np_push_operator -> .)
    ID              reduce using rule 120 (np_push_operator -> .)
    LENGTH          reduce using rule 120 (np_push_operator -> .)
    MIN             reduce using rule 120 (np_push_operator -> .)
    MAX             reduce using rule 120 (np_push_operator -> .)
    MEAN            reduce using rule 120 (np_push_operator -> .)
    MEDIAN          reduce using rule 120 (np_push_operator -> .)
    MODE            reduce using rule 120 (np_push_operator -> .)
    PLOT_XY         reduce using rule 120 (np_push_operator -> .)
    REGRESSION      reduce using rule 120 (np_push_operator -> .)
    VARIANCE        reduce using rule 120 (np_push_operator -> .)
    DOT             reduce using rule 120 (np_push_operator -> .)
    SUM             reduce using rule 120 (np_push_operator -> .)
    ABS             reduce using rule 120 (np_push_operator -> .)
    ROOF            reduce using rule 120 (np_push_operator -> .)
    FLOOR           reduce using rule 120 (np_push_operator -> .)

    np_push_operator               shift and go to state 273

state 229

    (78) expressionB -> empty .

    R_PAR           reduce using rule 78 (expressionB -> empty .)
    COMMA           reduce using rule 78 (expressionB -> empty .)
    SEMICOLON       reduce using rule 78 (expressionB -> empty .)


state 230

    (86) logic -> exp logic2 .

    OR              reduce using rule 86 (logic -> exp logic2 .)
    AND             reduce using rule 86 (logic -> exp logic2 .)
    R_PAR           reduce using rule 86 (logic -> exp logic2 .)
    COMMA           reduce using rule 86 (logic -> exp logic2 .)
    SEMICOLON       reduce using rule 86 (logic -> exp logic2 .)


state 231

    (87) logic2 -> LESS . np_push_operator exp
    (120) np_push_operator -> .

    L_PAR           reduce using rule 120 (np_push_operator -> .)
    MINUS           reduce using rule 120 (np_push_operator -> .)
    CTE_INT         reduce using rule 120 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 120 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 120 (np_push_operator -> .)
    CTE_STRING      reduce using rule 120 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 120 (np_push_operator -> .)
    ID              reduce using rule 120 (np_push_operator -> .)
    LENGTH          reduce using rule 120 (np_push_operator -> .)
    MIN             reduce using rule 120 (np_push_operator -> .)
    MAX             reduce using rule 120 (np_push_operator -> .)
    MEAN            reduce using rule 120 (np_push_operator -> .)
    MEDIAN          reduce using rule 120 (np_push_operator -> .)
    MODE            reduce using rule 120 (np_push_operator -> .)
    PLOT_XY         reduce using rule 120 (np_push_operator -> .)
    REGRESSION      reduce using rule 120 (np_push_operator -> .)
    VARIANCE        reduce using rule 120 (np_push_operator -> .)
    DOT             reduce using rule 120 (np_push_operator -> .)
    SUM             reduce using rule 120 (np_push_operator -> .)
    ABS             reduce using rule 120 (np_push_operator -> .)
    ROOF            reduce using rule 120 (np_push_operator -> .)
    FLOOR           reduce using rule 120 (np_push_operator -> .)

    np_push_operator               shift and go to state 274

state 232

    (88) logic2 -> GREATER . np_push_operator exp
    (120) np_push_operator -> .

    L_PAR           reduce using rule 120 (np_push_operator -> .)
    MINUS           reduce using rule 120 (np_push_operator -> .)
    CTE_INT         reduce using rule 120 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 120 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 120 (np_push_operator -> .)
    CTE_STRING      reduce using rule 120 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 120 (np_push_operator -> .)
    ID              reduce using rule 120 (np_push_operator -> .)
    LENGTH          reduce using rule 120 (np_push_operator -> .)
    MIN             reduce using rule 120 (np_push_operator -> .)
    MAX             reduce using rule 120 (np_push_operator -> .)
    MEAN            reduce using rule 120 (np_push_operator -> .)
    MEDIAN          reduce using rule 120 (np_push_operator -> .)
    MODE            reduce using rule 120 (np_push_operator -> .)
    PLOT_XY         reduce using rule 120 (np_push_operator -> .)
    REGRESSION      reduce using rule 120 (np_push_operator -> .)
    VARIANCE        reduce using rule 120 (np_push_operator -> .)
    DOT             reduce using rule 120 (np_push_operator -> .)
    SUM             reduce using rule 120 (np_push_operator -> .)
    ABS             reduce using rule 120 (np_push_operator -> .)
    ROOF            reduce using rule 120 (np_push_operator -> .)
    FLOOR           reduce using rule 120 (np_push_operator -> .)

    np_push_operator               shift and go to state 275

state 233

    (89) logic2 -> LESS_EQ . np_push_operator exp
    (120) np_push_operator -> .

    L_PAR           reduce using rule 120 (np_push_operator -> .)
    MINUS           reduce using rule 120 (np_push_operator -> .)
    CTE_INT         reduce using rule 120 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 120 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 120 (np_push_operator -> .)
    CTE_STRING      reduce using rule 120 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 120 (np_push_operator -> .)
    ID              reduce using rule 120 (np_push_operator -> .)
    LENGTH          reduce using rule 120 (np_push_operator -> .)
    MIN             reduce using rule 120 (np_push_operator -> .)
    MAX             reduce using rule 120 (np_push_operator -> .)
    MEAN            reduce using rule 120 (np_push_operator -> .)
    MEDIAN          reduce using rule 120 (np_push_operator -> .)
    MODE            reduce using rule 120 (np_push_operator -> .)
    PLOT_XY         reduce using rule 120 (np_push_operator -> .)
    REGRESSION      reduce using rule 120 (np_push_operator -> .)
    VARIANCE        reduce using rule 120 (np_push_operator -> .)
    DOT             reduce using rule 120 (np_push_operator -> .)
    SUM             reduce using rule 120 (np_push_operator -> .)
    ABS             reduce using rule 120 (np_push_operator -> .)
    ROOF            reduce using rule 120 (np_push_operator -> .)
    FLOOR           reduce using rule 120 (np_push_operator -> .)

    np_push_operator               shift and go to state 276

state 234

    (90) logic2 -> GREATER_EQ . np_push_operator exp
    (120) np_push_operator -> .

    L_PAR           reduce using rule 120 (np_push_operator -> .)
    MINUS           reduce using rule 120 (np_push_operator -> .)
    CTE_INT         reduce using rule 120 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 120 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 120 (np_push_operator -> .)
    CTE_STRING      reduce using rule 120 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 120 (np_push_operator -> .)
    ID              reduce using rule 120 (np_push_operator -> .)
    LENGTH          reduce using rule 120 (np_push_operator -> .)
    MIN             reduce using rule 120 (np_push_operator -> .)
    MAX             reduce using rule 120 (np_push_operator -> .)
    MEAN            reduce using rule 120 (np_push_operator -> .)
    MEDIAN          reduce using rule 120 (np_push_operator -> .)
    MODE            reduce using rule 120 (np_push_operator -> .)
    PLOT_XY         reduce using rule 120 (np_push_operator -> .)
    REGRESSION      reduce using rule 120 (np_push_operator -> .)
    VARIANCE        reduce using rule 120 (np_push_operator -> .)
    DOT             reduce using rule 120 (np_push_operator -> .)
    SUM             reduce using rule 120 (np_push_operator -> .)
    ABS             reduce using rule 120 (np_push_operator -> .)
    ROOF            reduce using rule 120 (np_push_operator -> .)
    FLOOR           reduce using rule 120 (np_push_operator -> .)

    np_push_operator               shift and go to state 277

state 235

    (91) logic2 -> EQUIVALENT . np_push_operator exp
    (120) np_push_operator -> .

    L_PAR           reduce using rule 120 (np_push_operator -> .)
    MINUS           reduce using rule 120 (np_push_operator -> .)
    CTE_INT         reduce using rule 120 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 120 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 120 (np_push_operator -> .)
    CTE_STRING      reduce using rule 120 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 120 (np_push_operator -> .)
    ID              reduce using rule 120 (np_push_operator -> .)
    LENGTH          reduce using rule 120 (np_push_operator -> .)
    MIN             reduce using rule 120 (np_push_operator -> .)
    MAX             reduce using rule 120 (np_push_operator -> .)
    MEAN            reduce using rule 120 (np_push_operator -> .)
    MEDIAN          reduce using rule 120 (np_push_operator -> .)
    MODE            reduce using rule 120 (np_push_operator -> .)
    PLOT_XY         reduce using rule 120 (np_push_operator -> .)
    REGRESSION      reduce using rule 120 (np_push_operator -> .)
    VARIANCE        reduce using rule 120 (np_push_operator -> .)
    DOT             reduce using rule 120 (np_push_operator -> .)
    SUM             reduce using rule 120 (np_push_operator -> .)
    ABS             reduce using rule 120 (np_push_operator -> .)
    ROOF            reduce using rule 120 (np_push_operator -> .)
    FLOOR           reduce using rule 120 (np_push_operator -> .)

    np_push_operator               shift and go to state 278

state 236

    (92) logic2 -> DIFFERENT . np_push_operator exp
    (120) np_push_operator -> .

    L_PAR           reduce using rule 120 (np_push_operator -> .)
    MINUS           reduce using rule 120 (np_push_operator -> .)
    CTE_INT         reduce using rule 120 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 120 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 120 (np_push_operator -> .)
    CTE_STRING      reduce using rule 120 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 120 (np_push_operator -> .)
    ID              reduce using rule 120 (np_push_operator -> .)
    LENGTH          reduce using rule 120 (np_push_operator -> .)
    MIN             reduce using rule 120 (np_push_operator -> .)
    MAX             reduce using rule 120 (np_push_operator -> .)
    MEAN            reduce using rule 120 (np_push_operator -> .)
    MEDIAN          reduce using rule 120 (np_push_operator -> .)
    MODE            reduce using rule 120 (np_push_operator -> .)
    PLOT_XY         reduce using rule 120 (np_push_operator -> .)
    REGRESSION      reduce using rule 120 (np_push_operator -> .)
    VARIANCE        reduce using rule 120 (np_push_operator -> .)
    DOT             reduce using rule 120 (np_push_operator -> .)
    SUM             reduce using rule 120 (np_push_operator -> .)
    ABS             reduce using rule 120 (np_push_operator -> .)
    ROOF            reduce using rule 120 (np_push_operator -> .)
    FLOOR           reduce using rule 120 (np_push_operator -> .)

    np_push_operator               shift and go to state 279

state 237

    (93) logic2 -> empty .

    OR              reduce using rule 93 (logic2 -> empty .)
    AND             reduce using rule 93 (logic2 -> empty .)
    R_PAR           reduce using rule 93 (logic2 -> empty .)
    COMMA           reduce using rule 93 (logic2 -> empty .)
    SEMICOLON       reduce using rule 93 (logic2 -> empty .)


state 238

    (60) read -> READ L_PAR read2 R_PAR SEMICOLON .

    IF              reduce using rule 60 (read -> READ L_PAR read2 R_PAR SEMICOLON .)
    READ            reduce using rule 60 (read -> READ L_PAR read2 R_PAR SEMICOLON .)
    WRITE           reduce using rule 60 (read -> READ L_PAR read2 R_PAR SEMICOLON .)
    WHILE           reduce using rule 60 (read -> READ L_PAR read2 R_PAR SEMICOLON .)
    FOR             reduce using rule 60 (read -> READ L_PAR read2 R_PAR SEMICOLON .)
    RETURN          reduce using rule 60 (read -> READ L_PAR read2 R_PAR SEMICOLON .)
    ID              reduce using rule 60 (read -> READ L_PAR read2 R_PAR SEMICOLON .)
    R_BRACE         reduce using rule 60 (read -> READ L_PAR read2 R_PAR SEMICOLON .)


state 239

    (62) read2 -> var np_read COMMA . read2
    (61) read2 -> . var np_read
    (62) read2 -> . var np_read COMMA read2
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID

    ID              shift and go to state 41

    var                            shift and go to state 139
    read2                          shift and go to state 280

state 240

    (63) write -> WRITE L_PAR writeB R_PAR SEMICOLON .

    IF              reduce using rule 63 (write -> WRITE L_PAR writeB R_PAR SEMICOLON .)
    READ            reduce using rule 63 (write -> WRITE L_PAR writeB R_PAR SEMICOLON .)
    WRITE           reduce using rule 63 (write -> WRITE L_PAR writeB R_PAR SEMICOLON .)
    WHILE           reduce using rule 63 (write -> WRITE L_PAR writeB R_PAR SEMICOLON .)
    FOR             reduce using rule 63 (write -> WRITE L_PAR writeB R_PAR SEMICOLON .)
    RETURN          reduce using rule 63 (write -> WRITE L_PAR writeB R_PAR SEMICOLON .)
    ID              reduce using rule 63 (write -> WRITE L_PAR writeB R_PAR SEMICOLON .)
    R_BRACE         reduce using rule 63 (write -> WRITE L_PAR writeB R_PAR SEMICOLON .)


state 241

    (64) writeB -> expression np_end np_write . writeC
    (66) writeC -> . COMMA writeB
    (67) writeC -> . empty
    (118) empty -> .

    COMMA           shift and go to state 282
    R_PAR           reduce using rule 118 (empty -> .)

    writeC                         shift and go to state 281
    empty                          shift and go to state 283

state 242

    (65) writeB -> CTE_STRING np_push_cte_str np_write . writeC
    (66) writeC -> . COMMA writeB
    (67) writeC -> . empty
    (118) empty -> .

    COMMA           shift and go to state 282
    R_PAR           reduce using rule 118 (empty -> .)

    writeC                         shift and go to state 284
    empty                          shift and go to state 283

state 243

    (68) loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR . np_end np_GOTOF block np_GOTO_WHILE
    (133) np_end -> .

    L_BRACE         reduce using rule 133 (np_end -> .)

    np_end                         shift and go to state 285

state 244

    (69) loop_range -> FOR var np_push_operand EQUAL np_push_operator . exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR
    (94) exp -> . term exp2
    (98) term -> . factor term2
    (103) factor -> . exponent factorB
    (106) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (107) exponent -> . exponentB
    (108) exponentB -> . MINUS var_cte
    (109) exponentB -> . var_cte
    (110) var_cte -> . var np_push_operand
    (111) var_cte -> . predef_func
    (112) var_cte -> . func_call
    (113) var_cte -> . CTE_INT np_push_cte_int
    (114) var_cte -> . CTE_FLOAT np_push_cte_float
    (115) var_cte -> . CTE_CHAR np_push_cte_char
    (116) var_cte -> . CTE_STRING np_push_cte_str
    (117) var_cte -> . CTE_BOOL np_push_cte_bool
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (43) predef_func -> . LENGTH L_PAR vector R_PAR
    (44) predef_func -> . MIN L_PAR vector R_PAR
    (45) predef_func -> . MAX L_PAR vector R_PAR
    (46) predef_func -> . MEAN L_PAR vector R_PAR
    (47) predef_func -> . MEDIAN L_PAR vector R_PAR
    (48) predef_func -> . MODE L_PAR vector R_PAR
    (49) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (50) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . VARIANCE L_PAR vector R_PAR
    (52) predef_func -> . DOT L_PAR vector COMMA vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (54) predef_func -> . ABS L_PAR CTE_INT R_PAR
    (55) predef_func -> . ROOF L_PAR CTE_FLOAT R_PAR
    (56) predef_func -> . FLOOR L_PAR CTE_FLOAT R_PAR
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 98
    MINUS           shift and go to state 100
    CTE_INT         shift and go to state 105
    CTE_FLOAT       shift and go to state 106
    CTE_CHAR        shift and go to state 107
    CTE_STRING      shift and go to state 108
    CTE_BOOL        shift and go to state 109
    ID              shift and go to state 73
    LENGTH          shift and go to state 110
    MIN             shift and go to state 111
    MAX             shift and go to state 112
    MEAN            shift and go to state 113
    MEDIAN          shift and go to state 114
    MODE            shift and go to state 115
    PLOT_XY         shift and go to state 116
    REGRESSION      shift and go to state 117
    VARIANCE        shift and go to state 118
    DOT             shift and go to state 119
    SUM             shift and go to state 120
    ABS             shift and go to state 121
    ROOF            shift and go to state 122
    FLOOR           shift and go to state 123

    var                            shift and go to state 102
    exp                            shift and go to state 286
    term                           shift and go to state 95
    factor                         shift and go to state 96
    exponent                       shift and go to state 97
    exponentB                      shift and go to state 99
    var_cte                        shift and go to state 101
    predef_func                    shift and go to state 103
    func_call                      shift and go to state 104

state 245

    (70) return -> RETURN L_PAR np_stop exp np_end . np_set_return R_PAR SEMICOLON
    (132) np_set_return -> .

    R_PAR           reduce using rule 132 (np_set_return -> .)

    np_set_return                  shift and go to state 287

state 246

    (71) func_call -> ID np_ERA L_PAR func_call_arguments R_PAR . np_GOSUB
    (147) np_GOSUB -> .

    SEMICOLON       reduce using rule 147 (np_GOSUB -> .)
    EXP             reduce using rule 147 (np_GOSUB -> .)
    MULT            reduce using rule 147 (np_GOSUB -> .)
    DIV             reduce using rule 147 (np_GOSUB -> .)
    REMAINDER       reduce using rule 147 (np_GOSUB -> .)
    PLUS            reduce using rule 147 (np_GOSUB -> .)
    MINUS           reduce using rule 147 (np_GOSUB -> .)
    R_BRACKET       reduce using rule 147 (np_GOSUB -> .)
    LESS            reduce using rule 147 (np_GOSUB -> .)
    GREATER         reduce using rule 147 (np_GOSUB -> .)
    LESS_EQ         reduce using rule 147 (np_GOSUB -> .)
    GREATER_EQ      reduce using rule 147 (np_GOSUB -> .)
    EQUIVALENT      reduce using rule 147 (np_GOSUB -> .)
    DIFFERENT       reduce using rule 147 (np_GOSUB -> .)
    OR              reduce using rule 147 (np_GOSUB -> .)
    AND             reduce using rule 147 (np_GOSUB -> .)
    R_PAR           reduce using rule 147 (np_GOSUB -> .)
    COMMA           reduce using rule 147 (np_GOSUB -> .)
    TO              reduce using rule 147 (np_GOSUB -> .)
    L_BRACE         reduce using rule 147 (np_GOSUB -> .)

    np_GOSUB                       shift and go to state 288

state 247

    (72) func_call_arguments -> np_stop exp . np_end np_param
    (73) func_call_arguments -> np_stop exp . np_end np_param COMMA func_call_arguments
    (133) np_end -> .

    COMMA           reduce using rule 133 (np_end -> .)
    R_PAR           reduce using rule 133 (np_end -> .)

    np_end                         shift and go to state 289

state 248

    (18) var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .

    COMMA           reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    SEMICOLON       reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    EQUAL           reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    MULT_EQ         reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    DIV_EQ          reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    PLUS_EQ         reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    MINUS_EQ        reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    EXP             reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    MULT            reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    DIV             reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    REMAINDER       reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    PLUS            reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    MINUS           reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    R_BRACKET       reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    R_PAR           reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    LESS            reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    GREATER         reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    LESS_EQ         reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    GREATER_EQ      reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    EQUIVALENT      reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    DIFFERENT       reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    OR              reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    AND             reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    TO              reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    L_BRACE         reduce using rule 18 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)


state 249

    (95) exp2 -> PLUS np_push_operator exp .

    R_BRACKET       reduce using rule 95 (exp2 -> PLUS np_push_operator exp .)
    LESS            reduce using rule 95 (exp2 -> PLUS np_push_operator exp .)
    GREATER         reduce using rule 95 (exp2 -> PLUS np_push_operator exp .)
    LESS_EQ         reduce using rule 95 (exp2 -> PLUS np_push_operator exp .)
    GREATER_EQ      reduce using rule 95 (exp2 -> PLUS np_push_operator exp .)
    EQUIVALENT      reduce using rule 95 (exp2 -> PLUS np_push_operator exp .)
    DIFFERENT       reduce using rule 95 (exp2 -> PLUS np_push_operator exp .)
    OR              reduce using rule 95 (exp2 -> PLUS np_push_operator exp .)
    AND             reduce using rule 95 (exp2 -> PLUS np_push_operator exp .)
    R_PAR           reduce using rule 95 (exp2 -> PLUS np_push_operator exp .)
    COMMA           reduce using rule 95 (exp2 -> PLUS np_push_operator exp .)
    SEMICOLON       reduce using rule 95 (exp2 -> PLUS np_push_operator exp .)
    TO              reduce using rule 95 (exp2 -> PLUS np_push_operator exp .)
    L_BRACE         reduce using rule 95 (exp2 -> PLUS np_push_operator exp .)


state 250

    (96) exp2 -> MINUS np_push_operator exp .

    R_BRACKET       reduce using rule 96 (exp2 -> MINUS np_push_operator exp .)
    LESS            reduce using rule 96 (exp2 -> MINUS np_push_operator exp .)
    GREATER         reduce using rule 96 (exp2 -> MINUS np_push_operator exp .)
    LESS_EQ         reduce using rule 96 (exp2 -> MINUS np_push_operator exp .)
    GREATER_EQ      reduce using rule 96 (exp2 -> MINUS np_push_operator exp .)
    EQUIVALENT      reduce using rule 96 (exp2 -> MINUS np_push_operator exp .)
    DIFFERENT       reduce using rule 96 (exp2 -> MINUS np_push_operator exp .)
    OR              reduce using rule 96 (exp2 -> MINUS np_push_operator exp .)
    AND             reduce using rule 96 (exp2 -> MINUS np_push_operator exp .)
    R_PAR           reduce using rule 96 (exp2 -> MINUS np_push_operator exp .)
    COMMA           reduce using rule 96 (exp2 -> MINUS np_push_operator exp .)
    SEMICOLON       reduce using rule 96 (exp2 -> MINUS np_push_operator exp .)
    TO              reduce using rule 96 (exp2 -> MINUS np_push_operator exp .)
    L_BRACE         reduce using rule 96 (exp2 -> MINUS np_push_operator exp .)


state 251

    (99) term2 -> MULT np_push_operator term .

    PLUS            reduce using rule 99 (term2 -> MULT np_push_operator term .)
    MINUS           reduce using rule 99 (term2 -> MULT np_push_operator term .)
    R_BRACKET       reduce using rule 99 (term2 -> MULT np_push_operator term .)
    LESS            reduce using rule 99 (term2 -> MULT np_push_operator term .)
    GREATER         reduce using rule 99 (term2 -> MULT np_push_operator term .)
    LESS_EQ         reduce using rule 99 (term2 -> MULT np_push_operator term .)
    GREATER_EQ      reduce using rule 99 (term2 -> MULT np_push_operator term .)
    EQUIVALENT      reduce using rule 99 (term2 -> MULT np_push_operator term .)
    DIFFERENT       reduce using rule 99 (term2 -> MULT np_push_operator term .)
    OR              reduce using rule 99 (term2 -> MULT np_push_operator term .)
    AND             reduce using rule 99 (term2 -> MULT np_push_operator term .)
    R_PAR           reduce using rule 99 (term2 -> MULT np_push_operator term .)
    COMMA           reduce using rule 99 (term2 -> MULT np_push_operator term .)
    SEMICOLON       reduce using rule 99 (term2 -> MULT np_push_operator term .)
    TO              reduce using rule 99 (term2 -> MULT np_push_operator term .)
    L_BRACE         reduce using rule 99 (term2 -> MULT np_push_operator term .)


state 252

    (100) term2 -> DIV np_push_operator term .

    PLUS            reduce using rule 100 (term2 -> DIV np_push_operator term .)
    MINUS           reduce using rule 100 (term2 -> DIV np_push_operator term .)
    R_BRACKET       reduce using rule 100 (term2 -> DIV np_push_operator term .)
    LESS            reduce using rule 100 (term2 -> DIV np_push_operator term .)
    GREATER         reduce using rule 100 (term2 -> DIV np_push_operator term .)
    LESS_EQ         reduce using rule 100 (term2 -> DIV np_push_operator term .)
    GREATER_EQ      reduce using rule 100 (term2 -> DIV np_push_operator term .)
    EQUIVALENT      reduce using rule 100 (term2 -> DIV np_push_operator term .)
    DIFFERENT       reduce using rule 100 (term2 -> DIV np_push_operator term .)
    OR              reduce using rule 100 (term2 -> DIV np_push_operator term .)
    AND             reduce using rule 100 (term2 -> DIV np_push_operator term .)
    R_PAR           reduce using rule 100 (term2 -> DIV np_push_operator term .)
    COMMA           reduce using rule 100 (term2 -> DIV np_push_operator term .)
    SEMICOLON       reduce using rule 100 (term2 -> DIV np_push_operator term .)
    TO              reduce using rule 100 (term2 -> DIV np_push_operator term .)
    L_BRACE         reduce using rule 100 (term2 -> DIV np_push_operator term .)


state 253

    (101) term2 -> REMAINDER np_push_operator term .

    PLUS            reduce using rule 101 (term2 -> REMAINDER np_push_operator term .)
    MINUS           reduce using rule 101 (term2 -> REMAINDER np_push_operator term .)
    R_BRACKET       reduce using rule 101 (term2 -> REMAINDER np_push_operator term .)
    LESS            reduce using rule 101 (term2 -> REMAINDER np_push_operator term .)
    GREATER         reduce using rule 101 (term2 -> REMAINDER np_push_operator term .)
    LESS_EQ         reduce using rule 101 (term2 -> REMAINDER np_push_operator term .)
    GREATER_EQ      reduce using rule 101 (term2 -> REMAINDER np_push_operator term .)
    EQUIVALENT      reduce using rule 101 (term2 -> REMAINDER np_push_operator term .)
    DIFFERENT       reduce using rule 101 (term2 -> REMAINDER np_push_operator term .)
    OR              reduce using rule 101 (term2 -> REMAINDER np_push_operator term .)
    AND             reduce using rule 101 (term2 -> REMAINDER np_push_operator term .)
    R_PAR           reduce using rule 101 (term2 -> REMAINDER np_push_operator term .)
    COMMA           reduce using rule 101 (term2 -> REMAINDER np_push_operator term .)
    SEMICOLON       reduce using rule 101 (term2 -> REMAINDER np_push_operator term .)
    TO              reduce using rule 101 (term2 -> REMAINDER np_push_operator term .)
    L_BRACE         reduce using rule 101 (term2 -> REMAINDER np_push_operator term .)


state 254

    (106) exponent -> L_PAR np_push_operator expression R_PAR . np_rpar
    (131) np_rpar -> .

    EXP             reduce using rule 131 (np_rpar -> .)
    MULT            reduce using rule 131 (np_rpar -> .)
    DIV             reduce using rule 131 (np_rpar -> .)
    REMAINDER       reduce using rule 131 (np_rpar -> .)
    PLUS            reduce using rule 131 (np_rpar -> .)
    MINUS           reduce using rule 131 (np_rpar -> .)
    R_BRACKET       reduce using rule 131 (np_rpar -> .)
    LESS            reduce using rule 131 (np_rpar -> .)
    GREATER         reduce using rule 131 (np_rpar -> .)
    LESS_EQ         reduce using rule 131 (np_rpar -> .)
    GREATER_EQ      reduce using rule 131 (np_rpar -> .)
    EQUIVALENT      reduce using rule 131 (np_rpar -> .)
    DIFFERENT       reduce using rule 131 (np_rpar -> .)
    OR              reduce using rule 131 (np_rpar -> .)
    AND             reduce using rule 131 (np_rpar -> .)
    R_PAR           reduce using rule 131 (np_rpar -> .)
    COMMA           reduce using rule 131 (np_rpar -> .)
    SEMICOLON       reduce using rule 131 (np_rpar -> .)
    TO              reduce using rule 131 (np_rpar -> .)
    L_BRACE         reduce using rule 131 (np_rpar -> .)

    np_rpar                        shift and go to state 290

state 255

    (43) predef_func -> LENGTH L_PAR vector R_PAR .

    EXP             reduce using rule 43 (predef_func -> LENGTH L_PAR vector R_PAR .)
    MULT            reduce using rule 43 (predef_func -> LENGTH L_PAR vector R_PAR .)
    DIV             reduce using rule 43 (predef_func -> LENGTH L_PAR vector R_PAR .)
    REMAINDER       reduce using rule 43 (predef_func -> LENGTH L_PAR vector R_PAR .)
    PLUS            reduce using rule 43 (predef_func -> LENGTH L_PAR vector R_PAR .)
    MINUS           reduce using rule 43 (predef_func -> LENGTH L_PAR vector R_PAR .)
    R_BRACKET       reduce using rule 43 (predef_func -> LENGTH L_PAR vector R_PAR .)
    LESS            reduce using rule 43 (predef_func -> LENGTH L_PAR vector R_PAR .)
    GREATER         reduce using rule 43 (predef_func -> LENGTH L_PAR vector R_PAR .)
    LESS_EQ         reduce using rule 43 (predef_func -> LENGTH L_PAR vector R_PAR .)
    GREATER_EQ      reduce using rule 43 (predef_func -> LENGTH L_PAR vector R_PAR .)
    EQUIVALENT      reduce using rule 43 (predef_func -> LENGTH L_PAR vector R_PAR .)
    DIFFERENT       reduce using rule 43 (predef_func -> LENGTH L_PAR vector R_PAR .)
    OR              reduce using rule 43 (predef_func -> LENGTH L_PAR vector R_PAR .)
    AND             reduce using rule 43 (predef_func -> LENGTH L_PAR vector R_PAR .)
    R_PAR           reduce using rule 43 (predef_func -> LENGTH L_PAR vector R_PAR .)
    COMMA           reduce using rule 43 (predef_func -> LENGTH L_PAR vector R_PAR .)
    SEMICOLON       reduce using rule 43 (predef_func -> LENGTH L_PAR vector R_PAR .)
    TO              reduce using rule 43 (predef_func -> LENGTH L_PAR vector R_PAR .)
    L_BRACE         reduce using rule 43 (predef_func -> LENGTH L_PAR vector R_PAR .)


state 256

    (20) vector -> ID L_BRACKET . R_BRACKET

    R_BRACKET       shift and go to state 291


state 257

    (44) predef_func -> MIN L_PAR vector R_PAR .

    EXP             reduce using rule 44 (predef_func -> MIN L_PAR vector R_PAR .)
    MULT            reduce using rule 44 (predef_func -> MIN L_PAR vector R_PAR .)
    DIV             reduce using rule 44 (predef_func -> MIN L_PAR vector R_PAR .)
    REMAINDER       reduce using rule 44 (predef_func -> MIN L_PAR vector R_PAR .)
    PLUS            reduce using rule 44 (predef_func -> MIN L_PAR vector R_PAR .)
    MINUS           reduce using rule 44 (predef_func -> MIN L_PAR vector R_PAR .)
    R_BRACKET       reduce using rule 44 (predef_func -> MIN L_PAR vector R_PAR .)
    LESS            reduce using rule 44 (predef_func -> MIN L_PAR vector R_PAR .)
    GREATER         reduce using rule 44 (predef_func -> MIN L_PAR vector R_PAR .)
    LESS_EQ         reduce using rule 44 (predef_func -> MIN L_PAR vector R_PAR .)
    GREATER_EQ      reduce using rule 44 (predef_func -> MIN L_PAR vector R_PAR .)
    EQUIVALENT      reduce using rule 44 (predef_func -> MIN L_PAR vector R_PAR .)
    DIFFERENT       reduce using rule 44 (predef_func -> MIN L_PAR vector R_PAR .)
    OR              reduce using rule 44 (predef_func -> MIN L_PAR vector R_PAR .)
    AND             reduce using rule 44 (predef_func -> MIN L_PAR vector R_PAR .)
    R_PAR           reduce using rule 44 (predef_func -> MIN L_PAR vector R_PAR .)
    COMMA           reduce using rule 44 (predef_func -> MIN L_PAR vector R_PAR .)
    SEMICOLON       reduce using rule 44 (predef_func -> MIN L_PAR vector R_PAR .)
    TO              reduce using rule 44 (predef_func -> MIN L_PAR vector R_PAR .)
    L_BRACE         reduce using rule 44 (predef_func -> MIN L_PAR vector R_PAR .)


state 258

    (45) predef_func -> MAX L_PAR vector R_PAR .

    EXP             reduce using rule 45 (predef_func -> MAX L_PAR vector R_PAR .)
    MULT            reduce using rule 45 (predef_func -> MAX L_PAR vector R_PAR .)
    DIV             reduce using rule 45 (predef_func -> MAX L_PAR vector R_PAR .)
    REMAINDER       reduce using rule 45 (predef_func -> MAX L_PAR vector R_PAR .)
    PLUS            reduce using rule 45 (predef_func -> MAX L_PAR vector R_PAR .)
    MINUS           reduce using rule 45 (predef_func -> MAX L_PAR vector R_PAR .)
    R_BRACKET       reduce using rule 45 (predef_func -> MAX L_PAR vector R_PAR .)
    LESS            reduce using rule 45 (predef_func -> MAX L_PAR vector R_PAR .)
    GREATER         reduce using rule 45 (predef_func -> MAX L_PAR vector R_PAR .)
    LESS_EQ         reduce using rule 45 (predef_func -> MAX L_PAR vector R_PAR .)
    GREATER_EQ      reduce using rule 45 (predef_func -> MAX L_PAR vector R_PAR .)
    EQUIVALENT      reduce using rule 45 (predef_func -> MAX L_PAR vector R_PAR .)
    DIFFERENT       reduce using rule 45 (predef_func -> MAX L_PAR vector R_PAR .)
    OR              reduce using rule 45 (predef_func -> MAX L_PAR vector R_PAR .)
    AND             reduce using rule 45 (predef_func -> MAX L_PAR vector R_PAR .)
    R_PAR           reduce using rule 45 (predef_func -> MAX L_PAR vector R_PAR .)
    COMMA           reduce using rule 45 (predef_func -> MAX L_PAR vector R_PAR .)
    SEMICOLON       reduce using rule 45 (predef_func -> MAX L_PAR vector R_PAR .)
    TO              reduce using rule 45 (predef_func -> MAX L_PAR vector R_PAR .)
    L_BRACE         reduce using rule 45 (predef_func -> MAX L_PAR vector R_PAR .)


state 259

    (46) predef_func -> MEAN L_PAR vector R_PAR .

    EXP             reduce using rule 46 (predef_func -> MEAN L_PAR vector R_PAR .)
    MULT            reduce using rule 46 (predef_func -> MEAN L_PAR vector R_PAR .)
    DIV             reduce using rule 46 (predef_func -> MEAN L_PAR vector R_PAR .)
    REMAINDER       reduce using rule 46 (predef_func -> MEAN L_PAR vector R_PAR .)
    PLUS            reduce using rule 46 (predef_func -> MEAN L_PAR vector R_PAR .)
    MINUS           reduce using rule 46 (predef_func -> MEAN L_PAR vector R_PAR .)
    R_BRACKET       reduce using rule 46 (predef_func -> MEAN L_PAR vector R_PAR .)
    LESS            reduce using rule 46 (predef_func -> MEAN L_PAR vector R_PAR .)
    GREATER         reduce using rule 46 (predef_func -> MEAN L_PAR vector R_PAR .)
    LESS_EQ         reduce using rule 46 (predef_func -> MEAN L_PAR vector R_PAR .)
    GREATER_EQ      reduce using rule 46 (predef_func -> MEAN L_PAR vector R_PAR .)
    EQUIVALENT      reduce using rule 46 (predef_func -> MEAN L_PAR vector R_PAR .)
    DIFFERENT       reduce using rule 46 (predef_func -> MEAN L_PAR vector R_PAR .)
    OR              reduce using rule 46 (predef_func -> MEAN L_PAR vector R_PAR .)
    AND             reduce using rule 46 (predef_func -> MEAN L_PAR vector R_PAR .)
    R_PAR           reduce using rule 46 (predef_func -> MEAN L_PAR vector R_PAR .)
    COMMA           reduce using rule 46 (predef_func -> MEAN L_PAR vector R_PAR .)
    SEMICOLON       reduce using rule 46 (predef_func -> MEAN L_PAR vector R_PAR .)
    TO              reduce using rule 46 (predef_func -> MEAN L_PAR vector R_PAR .)
    L_BRACE         reduce using rule 46 (predef_func -> MEAN L_PAR vector R_PAR .)


state 260

    (47) predef_func -> MEDIAN L_PAR vector R_PAR .

    EXP             reduce using rule 47 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    MULT            reduce using rule 47 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    DIV             reduce using rule 47 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    REMAINDER       reduce using rule 47 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    PLUS            reduce using rule 47 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    MINUS           reduce using rule 47 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    R_BRACKET       reduce using rule 47 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    LESS            reduce using rule 47 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    GREATER         reduce using rule 47 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    LESS_EQ         reduce using rule 47 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    GREATER_EQ      reduce using rule 47 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    EQUIVALENT      reduce using rule 47 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    DIFFERENT       reduce using rule 47 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    OR              reduce using rule 47 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    AND             reduce using rule 47 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    R_PAR           reduce using rule 47 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    COMMA           reduce using rule 47 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    SEMICOLON       reduce using rule 47 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    TO              reduce using rule 47 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    L_BRACE         reduce using rule 47 (predef_func -> MEDIAN L_PAR vector R_PAR .)


state 261

    (48) predef_func -> MODE L_PAR vector R_PAR .

    EXP             reduce using rule 48 (predef_func -> MODE L_PAR vector R_PAR .)
    MULT            reduce using rule 48 (predef_func -> MODE L_PAR vector R_PAR .)
    DIV             reduce using rule 48 (predef_func -> MODE L_PAR vector R_PAR .)
    REMAINDER       reduce using rule 48 (predef_func -> MODE L_PAR vector R_PAR .)
    PLUS            reduce using rule 48 (predef_func -> MODE L_PAR vector R_PAR .)
    MINUS           reduce using rule 48 (predef_func -> MODE L_PAR vector R_PAR .)
    R_BRACKET       reduce using rule 48 (predef_func -> MODE L_PAR vector R_PAR .)
    LESS            reduce using rule 48 (predef_func -> MODE L_PAR vector R_PAR .)
    GREATER         reduce using rule 48 (predef_func -> MODE L_PAR vector R_PAR .)
    LESS_EQ         reduce using rule 48 (predef_func -> MODE L_PAR vector R_PAR .)
    GREATER_EQ      reduce using rule 48 (predef_func -> MODE L_PAR vector R_PAR .)
    EQUIVALENT      reduce using rule 48 (predef_func -> MODE L_PAR vector R_PAR .)
    DIFFERENT       reduce using rule 48 (predef_func -> MODE L_PAR vector R_PAR .)
    OR              reduce using rule 48 (predef_func -> MODE L_PAR vector R_PAR .)
    AND             reduce using rule 48 (predef_func -> MODE L_PAR vector R_PAR .)
    R_PAR           reduce using rule 48 (predef_func -> MODE L_PAR vector R_PAR .)
    COMMA           reduce using rule 48 (predef_func -> MODE L_PAR vector R_PAR .)
    SEMICOLON       reduce using rule 48 (predef_func -> MODE L_PAR vector R_PAR .)
    TO              reduce using rule 48 (predef_func -> MODE L_PAR vector R_PAR .)
    L_BRACE         reduce using rule 48 (predef_func -> MODE L_PAR vector R_PAR .)


state 262

    (49) predef_func -> PLOT_XY L_PAR vector COMMA . vector R_PAR
    (20) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 209

    vector                         shift and go to state 292

state 263

    (50) predef_func -> REGRESSION L_PAR vector COMMA . vector R_PAR
    (20) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 209

    vector                         shift and go to state 293

state 264

    (51) predef_func -> VARIANCE L_PAR vector R_PAR .

    EXP             reduce using rule 51 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    MULT            reduce using rule 51 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    DIV             reduce using rule 51 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    REMAINDER       reduce using rule 51 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    PLUS            reduce using rule 51 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    MINUS           reduce using rule 51 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    R_BRACKET       reduce using rule 51 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    LESS            reduce using rule 51 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    GREATER         reduce using rule 51 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    LESS_EQ         reduce using rule 51 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    GREATER_EQ      reduce using rule 51 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    EQUIVALENT      reduce using rule 51 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    DIFFERENT       reduce using rule 51 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    OR              reduce using rule 51 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    AND             reduce using rule 51 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    R_PAR           reduce using rule 51 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    COMMA           reduce using rule 51 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    SEMICOLON       reduce using rule 51 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    TO              reduce using rule 51 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    L_BRACE         reduce using rule 51 (predef_func -> VARIANCE L_PAR vector R_PAR .)


state 265

    (52) predef_func -> DOT L_PAR vector COMMA . vector R_PAR
    (20) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 209

    vector                         shift and go to state 294

state 266

    (53) predef_func -> SUM L_PAR vector R_PAR .

    EXP             reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    MULT            reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    DIV             reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    REMAINDER       reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    PLUS            reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    MINUS           reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    R_BRACKET       reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    LESS            reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    GREATER         reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    LESS_EQ         reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    GREATER_EQ      reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    EQUIVALENT      reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    DIFFERENT       reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    OR              reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    AND             reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    R_PAR           reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    COMMA           reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    SEMICOLON       reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    TO              reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    L_BRACE         reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)


state 267

    (54) predef_func -> ABS L_PAR CTE_INT R_PAR .

    EXP             reduce using rule 54 (predef_func -> ABS L_PAR CTE_INT R_PAR .)
    MULT            reduce using rule 54 (predef_func -> ABS L_PAR CTE_INT R_PAR .)
    DIV             reduce using rule 54 (predef_func -> ABS L_PAR CTE_INT R_PAR .)
    REMAINDER       reduce using rule 54 (predef_func -> ABS L_PAR CTE_INT R_PAR .)
    PLUS            reduce using rule 54 (predef_func -> ABS L_PAR CTE_INT R_PAR .)
    MINUS           reduce using rule 54 (predef_func -> ABS L_PAR CTE_INT R_PAR .)
    R_BRACKET       reduce using rule 54 (predef_func -> ABS L_PAR CTE_INT R_PAR .)
    LESS            reduce using rule 54 (predef_func -> ABS L_PAR CTE_INT R_PAR .)
    GREATER         reduce using rule 54 (predef_func -> ABS L_PAR CTE_INT R_PAR .)
    LESS_EQ         reduce using rule 54 (predef_func -> ABS L_PAR CTE_INT R_PAR .)
    GREATER_EQ      reduce using rule 54 (predef_func -> ABS L_PAR CTE_INT R_PAR .)
    EQUIVALENT      reduce using rule 54 (predef_func -> ABS L_PAR CTE_INT R_PAR .)
    DIFFERENT       reduce using rule 54 (predef_func -> ABS L_PAR CTE_INT R_PAR .)
    OR              reduce using rule 54 (predef_func -> ABS L_PAR CTE_INT R_PAR .)
    AND             reduce using rule 54 (predef_func -> ABS L_PAR CTE_INT R_PAR .)
    R_PAR           reduce using rule 54 (predef_func -> ABS L_PAR CTE_INT R_PAR .)
    COMMA           reduce using rule 54 (predef_func -> ABS L_PAR CTE_INT R_PAR .)
    SEMICOLON       reduce using rule 54 (predef_func -> ABS L_PAR CTE_INT R_PAR .)
    TO              reduce using rule 54 (predef_func -> ABS L_PAR CTE_INT R_PAR .)
    L_BRACE         reduce using rule 54 (predef_func -> ABS L_PAR CTE_INT R_PAR .)


state 268

    (55) predef_func -> ROOF L_PAR CTE_FLOAT R_PAR .

    EXP             reduce using rule 55 (predef_func -> ROOF L_PAR CTE_FLOAT R_PAR .)
    MULT            reduce using rule 55 (predef_func -> ROOF L_PAR CTE_FLOAT R_PAR .)
    DIV             reduce using rule 55 (predef_func -> ROOF L_PAR CTE_FLOAT R_PAR .)
    REMAINDER       reduce using rule 55 (predef_func -> ROOF L_PAR CTE_FLOAT R_PAR .)
    PLUS            reduce using rule 55 (predef_func -> ROOF L_PAR CTE_FLOAT R_PAR .)
    MINUS           reduce using rule 55 (predef_func -> ROOF L_PAR CTE_FLOAT R_PAR .)
    R_BRACKET       reduce using rule 55 (predef_func -> ROOF L_PAR CTE_FLOAT R_PAR .)
    LESS            reduce using rule 55 (predef_func -> ROOF L_PAR CTE_FLOAT R_PAR .)
    GREATER         reduce using rule 55 (predef_func -> ROOF L_PAR CTE_FLOAT R_PAR .)
    LESS_EQ         reduce using rule 55 (predef_func -> ROOF L_PAR CTE_FLOAT R_PAR .)
    GREATER_EQ      reduce using rule 55 (predef_func -> ROOF L_PAR CTE_FLOAT R_PAR .)
    EQUIVALENT      reduce using rule 55 (predef_func -> ROOF L_PAR CTE_FLOAT R_PAR .)
    DIFFERENT       reduce using rule 55 (predef_func -> ROOF L_PAR CTE_FLOAT R_PAR .)
    OR              reduce using rule 55 (predef_func -> ROOF L_PAR CTE_FLOAT R_PAR .)
    AND             reduce using rule 55 (predef_func -> ROOF L_PAR CTE_FLOAT R_PAR .)
    R_PAR           reduce using rule 55 (predef_func -> ROOF L_PAR CTE_FLOAT R_PAR .)
    COMMA           reduce using rule 55 (predef_func -> ROOF L_PAR CTE_FLOAT R_PAR .)
    SEMICOLON       reduce using rule 55 (predef_func -> ROOF L_PAR CTE_FLOAT R_PAR .)
    TO              reduce using rule 55 (predef_func -> ROOF L_PAR CTE_FLOAT R_PAR .)
    L_BRACE         reduce using rule 55 (predef_func -> ROOF L_PAR CTE_FLOAT R_PAR .)


state 269

    (56) predef_func -> FLOOR L_PAR CTE_FLOAT R_PAR .

    EXP             reduce using rule 56 (predef_func -> FLOOR L_PAR CTE_FLOAT R_PAR .)
    MULT            reduce using rule 56 (predef_func -> FLOOR L_PAR CTE_FLOAT R_PAR .)
    DIV             reduce using rule 56 (predef_func -> FLOOR L_PAR CTE_FLOAT R_PAR .)
    REMAINDER       reduce using rule 56 (predef_func -> FLOOR L_PAR CTE_FLOAT R_PAR .)
    PLUS            reduce using rule 56 (predef_func -> FLOOR L_PAR CTE_FLOAT R_PAR .)
    MINUS           reduce using rule 56 (predef_func -> FLOOR L_PAR CTE_FLOAT R_PAR .)
    R_BRACKET       reduce using rule 56 (predef_func -> FLOOR L_PAR CTE_FLOAT R_PAR .)
    LESS            reduce using rule 56 (predef_func -> FLOOR L_PAR CTE_FLOAT R_PAR .)
    GREATER         reduce using rule 56 (predef_func -> FLOOR L_PAR CTE_FLOAT R_PAR .)
    LESS_EQ         reduce using rule 56 (predef_func -> FLOOR L_PAR CTE_FLOAT R_PAR .)
    GREATER_EQ      reduce using rule 56 (predef_func -> FLOOR L_PAR CTE_FLOAT R_PAR .)
    EQUIVALENT      reduce using rule 56 (predef_func -> FLOOR L_PAR CTE_FLOAT R_PAR .)
    DIFFERENT       reduce using rule 56 (predef_func -> FLOOR L_PAR CTE_FLOAT R_PAR .)
    OR              reduce using rule 56 (predef_func -> FLOOR L_PAR CTE_FLOAT R_PAR .)
    AND             reduce using rule 56 (predef_func -> FLOOR L_PAR CTE_FLOAT R_PAR .)
    R_PAR           reduce using rule 56 (predef_func -> FLOOR L_PAR CTE_FLOAT R_PAR .)
    COMMA           reduce using rule 56 (predef_func -> FLOOR L_PAR CTE_FLOAT R_PAR .)
    SEMICOLON       reduce using rule 56 (predef_func -> FLOOR L_PAR CTE_FLOAT R_PAR .)
    TO              reduce using rule 56 (predef_func -> FLOOR L_PAR CTE_FLOAT R_PAR .)
    L_BRACE         reduce using rule 56 (predef_func -> FLOOR L_PAR CTE_FLOAT R_PAR .)


state 270

    (42) assign -> var np_push_operand oper_assign np_push_operator expression np_end . SEMICOLON

    SEMICOLON       shift and go to state 295


state 271

    (57) condicional -> IF L_PAR expression np_end np_GOTOF R_PAR . block cond2 np_GOTO_END
    (23) block -> . L_BRACE blockB R_BRACE

    L_BRACE         shift and go to state 297

    block                          shift and go to state 296

state 272

    (76) expressionB -> OR np_push_operator . expression
    (75) expression -> . not logic expressionB
    (84) not -> . NOT np_push_operator
    (85) not -> . empty
    (118) empty -> .

    NOT             shift and go to state 136
    L_PAR           reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    CTE_INT         reduce using rule 118 (empty -> .)
    CTE_FLOAT       reduce using rule 118 (empty -> .)
    CTE_CHAR        reduce using rule 118 (empty -> .)
    CTE_STRING      reduce using rule 118 (empty -> .)
    CTE_BOOL        reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    LENGTH          reduce using rule 118 (empty -> .)
    MIN             reduce using rule 118 (empty -> .)
    MAX             reduce using rule 118 (empty -> .)
    MEAN            reduce using rule 118 (empty -> .)
    MEDIAN          reduce using rule 118 (empty -> .)
    MODE            reduce using rule 118 (empty -> .)
    PLOT_XY         reduce using rule 118 (empty -> .)
    REGRESSION      reduce using rule 118 (empty -> .)
    VARIANCE        reduce using rule 118 (empty -> .)
    DOT             reduce using rule 118 (empty -> .)
    SUM             reduce using rule 118 (empty -> .)
    ABS             reduce using rule 118 (empty -> .)
    ROOF            reduce using rule 118 (empty -> .)
    FLOOR           reduce using rule 118 (empty -> .)

    expression                     shift and go to state 298
    not                            shift and go to state 135
    empty                          shift and go to state 137

state 273

    (77) expressionB -> AND np_push_operator . expression
    (75) expression -> . not logic expressionB
    (84) not -> . NOT np_push_operator
    (85) not -> . empty
    (118) empty -> .

    NOT             shift and go to state 136
    L_PAR           reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    CTE_INT         reduce using rule 118 (empty -> .)
    CTE_FLOAT       reduce using rule 118 (empty -> .)
    CTE_CHAR        reduce using rule 118 (empty -> .)
    CTE_STRING      reduce using rule 118 (empty -> .)
    CTE_BOOL        reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    LENGTH          reduce using rule 118 (empty -> .)
    MIN             reduce using rule 118 (empty -> .)
    MAX             reduce using rule 118 (empty -> .)
    MEAN            reduce using rule 118 (empty -> .)
    MEDIAN          reduce using rule 118 (empty -> .)
    MODE            reduce using rule 118 (empty -> .)
    PLOT_XY         reduce using rule 118 (empty -> .)
    REGRESSION      reduce using rule 118 (empty -> .)
    VARIANCE        reduce using rule 118 (empty -> .)
    DOT             reduce using rule 118 (empty -> .)
    SUM             reduce using rule 118 (empty -> .)
    ABS             reduce using rule 118 (empty -> .)
    ROOF            reduce using rule 118 (empty -> .)
    FLOOR           reduce using rule 118 (empty -> .)

    expression                     shift and go to state 299
    not                            shift and go to state 135
    empty                          shift and go to state 137

state 274

    (87) logic2 -> LESS np_push_operator . exp
    (94) exp -> . term exp2
    (98) term -> . factor term2
    (103) factor -> . exponent factorB
    (106) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (107) exponent -> . exponentB
    (108) exponentB -> . MINUS var_cte
    (109) exponentB -> . var_cte
    (110) var_cte -> . var np_push_operand
    (111) var_cte -> . predef_func
    (112) var_cte -> . func_call
    (113) var_cte -> . CTE_INT np_push_cte_int
    (114) var_cte -> . CTE_FLOAT np_push_cte_float
    (115) var_cte -> . CTE_CHAR np_push_cte_char
    (116) var_cte -> . CTE_STRING np_push_cte_str
    (117) var_cte -> . CTE_BOOL np_push_cte_bool
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (43) predef_func -> . LENGTH L_PAR vector R_PAR
    (44) predef_func -> . MIN L_PAR vector R_PAR
    (45) predef_func -> . MAX L_PAR vector R_PAR
    (46) predef_func -> . MEAN L_PAR vector R_PAR
    (47) predef_func -> . MEDIAN L_PAR vector R_PAR
    (48) predef_func -> . MODE L_PAR vector R_PAR
    (49) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (50) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . VARIANCE L_PAR vector R_PAR
    (52) predef_func -> . DOT L_PAR vector COMMA vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (54) predef_func -> . ABS L_PAR CTE_INT R_PAR
    (55) predef_func -> . ROOF L_PAR CTE_FLOAT R_PAR
    (56) predef_func -> . FLOOR L_PAR CTE_FLOAT R_PAR
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 98
    MINUS           shift and go to state 100
    CTE_INT         shift and go to state 105
    CTE_FLOAT       shift and go to state 106
    CTE_CHAR        shift and go to state 107
    CTE_STRING      shift and go to state 108
    CTE_BOOL        shift and go to state 109
    ID              shift and go to state 73
    LENGTH          shift and go to state 110
    MIN             shift and go to state 111
    MAX             shift and go to state 112
    MEAN            shift and go to state 113
    MEDIAN          shift and go to state 114
    MODE            shift and go to state 115
    PLOT_XY         shift and go to state 116
    REGRESSION      shift and go to state 117
    VARIANCE        shift and go to state 118
    DOT             shift and go to state 119
    SUM             shift and go to state 120
    ABS             shift and go to state 121
    ROOF            shift and go to state 122
    FLOOR           shift and go to state 123

    exp                            shift and go to state 300
    term                           shift and go to state 95
    factor                         shift and go to state 96
    exponent                       shift and go to state 97
    exponentB                      shift and go to state 99
    var_cte                        shift and go to state 101
    var                            shift and go to state 102
    predef_func                    shift and go to state 103
    func_call                      shift and go to state 104

state 275

    (88) logic2 -> GREATER np_push_operator . exp
    (94) exp -> . term exp2
    (98) term -> . factor term2
    (103) factor -> . exponent factorB
    (106) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (107) exponent -> . exponentB
    (108) exponentB -> . MINUS var_cte
    (109) exponentB -> . var_cte
    (110) var_cte -> . var np_push_operand
    (111) var_cte -> . predef_func
    (112) var_cte -> . func_call
    (113) var_cte -> . CTE_INT np_push_cte_int
    (114) var_cte -> . CTE_FLOAT np_push_cte_float
    (115) var_cte -> . CTE_CHAR np_push_cte_char
    (116) var_cte -> . CTE_STRING np_push_cte_str
    (117) var_cte -> . CTE_BOOL np_push_cte_bool
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (43) predef_func -> . LENGTH L_PAR vector R_PAR
    (44) predef_func -> . MIN L_PAR vector R_PAR
    (45) predef_func -> . MAX L_PAR vector R_PAR
    (46) predef_func -> . MEAN L_PAR vector R_PAR
    (47) predef_func -> . MEDIAN L_PAR vector R_PAR
    (48) predef_func -> . MODE L_PAR vector R_PAR
    (49) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (50) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . VARIANCE L_PAR vector R_PAR
    (52) predef_func -> . DOT L_PAR vector COMMA vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (54) predef_func -> . ABS L_PAR CTE_INT R_PAR
    (55) predef_func -> . ROOF L_PAR CTE_FLOAT R_PAR
    (56) predef_func -> . FLOOR L_PAR CTE_FLOAT R_PAR
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 98
    MINUS           shift and go to state 100
    CTE_INT         shift and go to state 105
    CTE_FLOAT       shift and go to state 106
    CTE_CHAR        shift and go to state 107
    CTE_STRING      shift and go to state 108
    CTE_BOOL        shift and go to state 109
    ID              shift and go to state 73
    LENGTH          shift and go to state 110
    MIN             shift and go to state 111
    MAX             shift and go to state 112
    MEAN            shift and go to state 113
    MEDIAN          shift and go to state 114
    MODE            shift and go to state 115
    PLOT_XY         shift and go to state 116
    REGRESSION      shift and go to state 117
    VARIANCE        shift and go to state 118
    DOT             shift and go to state 119
    SUM             shift and go to state 120
    ABS             shift and go to state 121
    ROOF            shift and go to state 122
    FLOOR           shift and go to state 123

    exp                            shift and go to state 301
    term                           shift and go to state 95
    factor                         shift and go to state 96
    exponent                       shift and go to state 97
    exponentB                      shift and go to state 99
    var_cte                        shift and go to state 101
    var                            shift and go to state 102
    predef_func                    shift and go to state 103
    func_call                      shift and go to state 104

state 276

    (89) logic2 -> LESS_EQ np_push_operator . exp
    (94) exp -> . term exp2
    (98) term -> . factor term2
    (103) factor -> . exponent factorB
    (106) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (107) exponent -> . exponentB
    (108) exponentB -> . MINUS var_cte
    (109) exponentB -> . var_cte
    (110) var_cte -> . var np_push_operand
    (111) var_cte -> . predef_func
    (112) var_cte -> . func_call
    (113) var_cte -> . CTE_INT np_push_cte_int
    (114) var_cte -> . CTE_FLOAT np_push_cte_float
    (115) var_cte -> . CTE_CHAR np_push_cte_char
    (116) var_cte -> . CTE_STRING np_push_cte_str
    (117) var_cte -> . CTE_BOOL np_push_cte_bool
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (43) predef_func -> . LENGTH L_PAR vector R_PAR
    (44) predef_func -> . MIN L_PAR vector R_PAR
    (45) predef_func -> . MAX L_PAR vector R_PAR
    (46) predef_func -> . MEAN L_PAR vector R_PAR
    (47) predef_func -> . MEDIAN L_PAR vector R_PAR
    (48) predef_func -> . MODE L_PAR vector R_PAR
    (49) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (50) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . VARIANCE L_PAR vector R_PAR
    (52) predef_func -> . DOT L_PAR vector COMMA vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (54) predef_func -> . ABS L_PAR CTE_INT R_PAR
    (55) predef_func -> . ROOF L_PAR CTE_FLOAT R_PAR
    (56) predef_func -> . FLOOR L_PAR CTE_FLOAT R_PAR
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 98
    MINUS           shift and go to state 100
    CTE_INT         shift and go to state 105
    CTE_FLOAT       shift and go to state 106
    CTE_CHAR        shift and go to state 107
    CTE_STRING      shift and go to state 108
    CTE_BOOL        shift and go to state 109
    ID              shift and go to state 73
    LENGTH          shift and go to state 110
    MIN             shift and go to state 111
    MAX             shift and go to state 112
    MEAN            shift and go to state 113
    MEDIAN          shift and go to state 114
    MODE            shift and go to state 115
    PLOT_XY         shift and go to state 116
    REGRESSION      shift and go to state 117
    VARIANCE        shift and go to state 118
    DOT             shift and go to state 119
    SUM             shift and go to state 120
    ABS             shift and go to state 121
    ROOF            shift and go to state 122
    FLOOR           shift and go to state 123

    exp                            shift and go to state 302
    term                           shift and go to state 95
    factor                         shift and go to state 96
    exponent                       shift and go to state 97
    exponentB                      shift and go to state 99
    var_cte                        shift and go to state 101
    var                            shift and go to state 102
    predef_func                    shift and go to state 103
    func_call                      shift and go to state 104

state 277

    (90) logic2 -> GREATER_EQ np_push_operator . exp
    (94) exp -> . term exp2
    (98) term -> . factor term2
    (103) factor -> . exponent factorB
    (106) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (107) exponent -> . exponentB
    (108) exponentB -> . MINUS var_cte
    (109) exponentB -> . var_cte
    (110) var_cte -> . var np_push_operand
    (111) var_cte -> . predef_func
    (112) var_cte -> . func_call
    (113) var_cte -> . CTE_INT np_push_cte_int
    (114) var_cte -> . CTE_FLOAT np_push_cte_float
    (115) var_cte -> . CTE_CHAR np_push_cte_char
    (116) var_cte -> . CTE_STRING np_push_cte_str
    (117) var_cte -> . CTE_BOOL np_push_cte_bool
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (43) predef_func -> . LENGTH L_PAR vector R_PAR
    (44) predef_func -> . MIN L_PAR vector R_PAR
    (45) predef_func -> . MAX L_PAR vector R_PAR
    (46) predef_func -> . MEAN L_PAR vector R_PAR
    (47) predef_func -> . MEDIAN L_PAR vector R_PAR
    (48) predef_func -> . MODE L_PAR vector R_PAR
    (49) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (50) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . VARIANCE L_PAR vector R_PAR
    (52) predef_func -> . DOT L_PAR vector COMMA vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (54) predef_func -> . ABS L_PAR CTE_INT R_PAR
    (55) predef_func -> . ROOF L_PAR CTE_FLOAT R_PAR
    (56) predef_func -> . FLOOR L_PAR CTE_FLOAT R_PAR
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 98
    MINUS           shift and go to state 100
    CTE_INT         shift and go to state 105
    CTE_FLOAT       shift and go to state 106
    CTE_CHAR        shift and go to state 107
    CTE_STRING      shift and go to state 108
    CTE_BOOL        shift and go to state 109
    ID              shift and go to state 73
    LENGTH          shift and go to state 110
    MIN             shift and go to state 111
    MAX             shift and go to state 112
    MEAN            shift and go to state 113
    MEDIAN          shift and go to state 114
    MODE            shift and go to state 115
    PLOT_XY         shift and go to state 116
    REGRESSION      shift and go to state 117
    VARIANCE        shift and go to state 118
    DOT             shift and go to state 119
    SUM             shift and go to state 120
    ABS             shift and go to state 121
    ROOF            shift and go to state 122
    FLOOR           shift and go to state 123

    exp                            shift and go to state 303
    term                           shift and go to state 95
    factor                         shift and go to state 96
    exponent                       shift and go to state 97
    exponentB                      shift and go to state 99
    var_cte                        shift and go to state 101
    var                            shift and go to state 102
    predef_func                    shift and go to state 103
    func_call                      shift and go to state 104

state 278

    (91) logic2 -> EQUIVALENT np_push_operator . exp
    (94) exp -> . term exp2
    (98) term -> . factor term2
    (103) factor -> . exponent factorB
    (106) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (107) exponent -> . exponentB
    (108) exponentB -> . MINUS var_cte
    (109) exponentB -> . var_cte
    (110) var_cte -> . var np_push_operand
    (111) var_cte -> . predef_func
    (112) var_cte -> . func_call
    (113) var_cte -> . CTE_INT np_push_cte_int
    (114) var_cte -> . CTE_FLOAT np_push_cte_float
    (115) var_cte -> . CTE_CHAR np_push_cte_char
    (116) var_cte -> . CTE_STRING np_push_cte_str
    (117) var_cte -> . CTE_BOOL np_push_cte_bool
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (43) predef_func -> . LENGTH L_PAR vector R_PAR
    (44) predef_func -> . MIN L_PAR vector R_PAR
    (45) predef_func -> . MAX L_PAR vector R_PAR
    (46) predef_func -> . MEAN L_PAR vector R_PAR
    (47) predef_func -> . MEDIAN L_PAR vector R_PAR
    (48) predef_func -> . MODE L_PAR vector R_PAR
    (49) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (50) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . VARIANCE L_PAR vector R_PAR
    (52) predef_func -> . DOT L_PAR vector COMMA vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (54) predef_func -> . ABS L_PAR CTE_INT R_PAR
    (55) predef_func -> . ROOF L_PAR CTE_FLOAT R_PAR
    (56) predef_func -> . FLOOR L_PAR CTE_FLOAT R_PAR
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 98
    MINUS           shift and go to state 100
    CTE_INT         shift and go to state 105
    CTE_FLOAT       shift and go to state 106
    CTE_CHAR        shift and go to state 107
    CTE_STRING      shift and go to state 108
    CTE_BOOL        shift and go to state 109
    ID              shift and go to state 73
    LENGTH          shift and go to state 110
    MIN             shift and go to state 111
    MAX             shift and go to state 112
    MEAN            shift and go to state 113
    MEDIAN          shift and go to state 114
    MODE            shift and go to state 115
    PLOT_XY         shift and go to state 116
    REGRESSION      shift and go to state 117
    VARIANCE        shift and go to state 118
    DOT             shift and go to state 119
    SUM             shift and go to state 120
    ABS             shift and go to state 121
    ROOF            shift and go to state 122
    FLOOR           shift and go to state 123

    exp                            shift and go to state 304
    term                           shift and go to state 95
    factor                         shift and go to state 96
    exponent                       shift and go to state 97
    exponentB                      shift and go to state 99
    var_cte                        shift and go to state 101
    var                            shift and go to state 102
    predef_func                    shift and go to state 103
    func_call                      shift and go to state 104

state 279

    (92) logic2 -> DIFFERENT np_push_operator . exp
    (94) exp -> . term exp2
    (98) term -> . factor term2
    (103) factor -> . exponent factorB
    (106) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (107) exponent -> . exponentB
    (108) exponentB -> . MINUS var_cte
    (109) exponentB -> . var_cte
    (110) var_cte -> . var np_push_operand
    (111) var_cte -> . predef_func
    (112) var_cte -> . func_call
    (113) var_cte -> . CTE_INT np_push_cte_int
    (114) var_cte -> . CTE_FLOAT np_push_cte_float
    (115) var_cte -> . CTE_CHAR np_push_cte_char
    (116) var_cte -> . CTE_STRING np_push_cte_str
    (117) var_cte -> . CTE_BOOL np_push_cte_bool
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (43) predef_func -> . LENGTH L_PAR vector R_PAR
    (44) predef_func -> . MIN L_PAR vector R_PAR
    (45) predef_func -> . MAX L_PAR vector R_PAR
    (46) predef_func -> . MEAN L_PAR vector R_PAR
    (47) predef_func -> . MEDIAN L_PAR vector R_PAR
    (48) predef_func -> . MODE L_PAR vector R_PAR
    (49) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (50) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . VARIANCE L_PAR vector R_PAR
    (52) predef_func -> . DOT L_PAR vector COMMA vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (54) predef_func -> . ABS L_PAR CTE_INT R_PAR
    (55) predef_func -> . ROOF L_PAR CTE_FLOAT R_PAR
    (56) predef_func -> . FLOOR L_PAR CTE_FLOAT R_PAR
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 98
    MINUS           shift and go to state 100
    CTE_INT         shift and go to state 105
    CTE_FLOAT       shift and go to state 106
    CTE_CHAR        shift and go to state 107
    CTE_STRING      shift and go to state 108
    CTE_BOOL        shift and go to state 109
    ID              shift and go to state 73
    LENGTH          shift and go to state 110
    MIN             shift and go to state 111
    MAX             shift and go to state 112
    MEAN            shift and go to state 113
    MEDIAN          shift and go to state 114
    MODE            shift and go to state 115
    PLOT_XY         shift and go to state 116
    REGRESSION      shift and go to state 117
    VARIANCE        shift and go to state 118
    DOT             shift and go to state 119
    SUM             shift and go to state 120
    ABS             shift and go to state 121
    ROOF            shift and go to state 122
    FLOOR           shift and go to state 123

    exp                            shift and go to state 305
    term                           shift and go to state 95
    factor                         shift and go to state 96
    exponent                       shift and go to state 97
    exponentB                      shift and go to state 99
    var_cte                        shift and go to state 101
    var                            shift and go to state 102
    predef_func                    shift and go to state 103
    func_call                      shift and go to state 104

state 280

    (62) read2 -> var np_read COMMA read2 .

    R_PAR           reduce using rule 62 (read2 -> var np_read COMMA read2 .)


state 281

    (64) writeB -> expression np_end np_write writeC .

    R_PAR           reduce using rule 64 (writeB -> expression np_end np_write writeC .)


state 282

    (66) writeC -> COMMA . writeB
    (64) writeB -> . expression np_end np_write writeC
    (65) writeB -> . CTE_STRING np_push_cte_str np_write writeC
    (75) expression -> . not logic expressionB
    (84) not -> . NOT np_push_operator
    (85) not -> . empty
    (118) empty -> .

  ! shift/reduce conflict for CTE_STRING resolved as shift
    CTE_STRING      shift and go to state 142
    NOT             shift and go to state 136
    L_PAR           reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    CTE_INT         reduce using rule 118 (empty -> .)
    CTE_FLOAT       reduce using rule 118 (empty -> .)
    CTE_CHAR        reduce using rule 118 (empty -> .)
    CTE_BOOL        reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    LENGTH          reduce using rule 118 (empty -> .)
    MIN             reduce using rule 118 (empty -> .)
    MAX             reduce using rule 118 (empty -> .)
    MEAN            reduce using rule 118 (empty -> .)
    MEDIAN          reduce using rule 118 (empty -> .)
    MODE            reduce using rule 118 (empty -> .)
    PLOT_XY         reduce using rule 118 (empty -> .)
    REGRESSION      reduce using rule 118 (empty -> .)
    VARIANCE        reduce using rule 118 (empty -> .)
    DOT             reduce using rule 118 (empty -> .)
    SUM             reduce using rule 118 (empty -> .)
    ABS             reduce using rule 118 (empty -> .)
    ROOF            reduce using rule 118 (empty -> .)
    FLOOR           reduce using rule 118 (empty -> .)

  ! CTE_STRING      [ reduce using rule 118 (empty -> .) ]

    writeB                         shift and go to state 306
    expression                     shift and go to state 141
    not                            shift and go to state 135
    empty                          shift and go to state 137

state 283

    (67) writeC -> empty .

    R_PAR           reduce using rule 67 (writeC -> empty .)


state 284

    (65) writeB -> CTE_STRING np_push_cte_str np_write writeC .

    R_PAR           reduce using rule 65 (writeB -> CTE_STRING np_push_cte_str np_write writeC .)


state 285

    (68) loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end . np_GOTOF block np_GOTO_WHILE
    (139) np_GOTOF -> .

    L_BRACE         reduce using rule 139 (np_GOTOF -> .)

    np_GOTOF                       shift and go to state 307

state 286

    (69) loop_range -> FOR var np_push_operand EQUAL np_push_operator exp . np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR
    (136) np_set_VC -> .

    TO              reduce using rule 136 (np_set_VC -> .)

    np_set_VC                      shift and go to state 308

state 287

    (70) return -> RETURN L_PAR np_stop exp np_end np_set_return . R_PAR SEMICOLON

    R_PAR           shift and go to state 309


state 288

    (71) func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .

    SEMICOLON       reduce using rule 71 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    EXP             reduce using rule 71 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    MULT            reduce using rule 71 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    DIV             reduce using rule 71 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    REMAINDER       reduce using rule 71 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    PLUS            reduce using rule 71 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    MINUS           reduce using rule 71 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    R_BRACKET       reduce using rule 71 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    LESS            reduce using rule 71 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    GREATER         reduce using rule 71 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    LESS_EQ         reduce using rule 71 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    GREATER_EQ      reduce using rule 71 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    EQUIVALENT      reduce using rule 71 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    DIFFERENT       reduce using rule 71 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    OR              reduce using rule 71 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    AND             reduce using rule 71 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    R_PAR           reduce using rule 71 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    COMMA           reduce using rule 71 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    TO              reduce using rule 71 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    L_BRACE         reduce using rule 71 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)


state 289

    (72) func_call_arguments -> np_stop exp np_end . np_param
    (73) func_call_arguments -> np_stop exp np_end . np_param COMMA func_call_arguments
    (149) np_param -> .

    COMMA           reduce using rule 149 (np_param -> .)
    R_PAR           reduce using rule 149 (np_param -> .)

    np_param                       shift and go to state 310

state 290

    (106) exponent -> L_PAR np_push_operator expression R_PAR np_rpar .

    EXP             reduce using rule 106 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    MULT            reduce using rule 106 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    DIV             reduce using rule 106 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    REMAINDER       reduce using rule 106 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    PLUS            reduce using rule 106 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    MINUS           reduce using rule 106 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    R_BRACKET       reduce using rule 106 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    LESS            reduce using rule 106 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    GREATER         reduce using rule 106 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    LESS_EQ         reduce using rule 106 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    GREATER_EQ      reduce using rule 106 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    EQUIVALENT      reduce using rule 106 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    DIFFERENT       reduce using rule 106 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    OR              reduce using rule 106 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    AND             reduce using rule 106 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    R_PAR           reduce using rule 106 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    COMMA           reduce using rule 106 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    SEMICOLON       reduce using rule 106 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    TO              reduce using rule 106 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    L_BRACE         reduce using rule 106 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)


state 291

    (20) vector -> ID L_BRACKET R_BRACKET .

    R_PAR           reduce using rule 20 (vector -> ID L_BRACKET R_BRACKET .)
    COMMA           reduce using rule 20 (vector -> ID L_BRACKET R_BRACKET .)


state 292

    (49) predef_func -> PLOT_XY L_PAR vector COMMA vector . R_PAR

    R_PAR           shift and go to state 311


state 293

    (50) predef_func -> REGRESSION L_PAR vector COMMA vector . R_PAR

    R_PAR           shift and go to state 312


state 294

    (52) predef_func -> DOT L_PAR vector COMMA vector . R_PAR

    R_PAR           shift and go to state 313


state 295

    (42) assign -> var np_push_operand oper_assign np_push_operator expression np_end SEMICOLON .

    IF              reduce using rule 42 (assign -> var np_push_operand oper_assign np_push_operator expression np_end SEMICOLON .)
    READ            reduce using rule 42 (assign -> var np_push_operand oper_assign np_push_operator expression np_end SEMICOLON .)
    WRITE           reduce using rule 42 (assign -> var np_push_operand oper_assign np_push_operator expression np_end SEMICOLON .)
    WHILE           reduce using rule 42 (assign -> var np_push_operand oper_assign np_push_operator expression np_end SEMICOLON .)
    FOR             reduce using rule 42 (assign -> var np_push_operand oper_assign np_push_operator expression np_end SEMICOLON .)
    RETURN          reduce using rule 42 (assign -> var np_push_operand oper_assign np_push_operator expression np_end SEMICOLON .)
    ID              reduce using rule 42 (assign -> var np_push_operand oper_assign np_push_operator expression np_end SEMICOLON .)
    R_BRACE         reduce using rule 42 (assign -> var np_push_operand oper_assign np_push_operator expression np_end SEMICOLON .)


state 296

    (57) condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block . cond2 np_GOTO_END
    (58) cond2 -> . np_GOTO_ELSE ELSE block
    (59) cond2 -> . empty
    (140) np_GOTO_ELSE -> .
    (118) empty -> .

    ELSE            reduce using rule 140 (np_GOTO_ELSE -> .)
    IF              reduce using rule 118 (empty -> .)
    READ            reduce using rule 118 (empty -> .)
    WRITE           reduce using rule 118 (empty -> .)
    WHILE           reduce using rule 118 (empty -> .)
    FOR             reduce using rule 118 (empty -> .)
    RETURN          reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    R_BRACE         reduce using rule 118 (empty -> .)

    cond2                          shift and go to state 314
    np_GOTO_ELSE                   shift and go to state 315
    empty                          shift and go to state 316

state 297

    (23) block -> L_BRACE . blockB R_BRACE
    (24) blockB -> . statement blockB
    (25) blockB -> . empty
    (33) statement -> . assign
    (34) statement -> . condicional
    (35) statement -> . read
    (36) statement -> . write
    (37) statement -> . loop_cond
    (38) statement -> . loop_range
    (39) statement -> . return
    (40) statement -> . void_func
    (118) empty -> .
    (42) assign -> . var np_push_operand oper_assign np_push_operator expression np_end SEMICOLON
    (57) condicional -> . IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END
    (60) read -> . READ L_PAR read2 R_PAR SEMICOLON
    (63) write -> . WRITE L_PAR writeB R_PAR SEMICOLON
    (68) loop_cond -> . WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE
    (69) loop_range -> . FOR var np_push_operand EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR
    (70) return -> . RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON
    (41) void_func -> . func_call SEMICOLON
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    R_BRACE         reduce using rule 118 (empty -> .)
    IF              shift and go to state 66
    READ            shift and go to state 67
    WRITE           shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70
    RETURN          shift and go to state 71
    ID              shift and go to state 73

    blockB                         shift and go to state 54
    statement                      shift and go to state 55
    empty                          shift and go to state 56
    assign                         shift and go to state 57
    condicional                    shift and go to state 58
    read                           shift and go to state 59
    write                          shift and go to state 60
    loop_cond                      shift and go to state 61
    loop_range                     shift and go to state 62
    return                         shift and go to state 63
    void_func                      shift and go to state 64
    var                            shift and go to state 65
    func_call                      shift and go to state 72

state 298

    (76) expressionB -> OR np_push_operator expression .

    R_PAR           reduce using rule 76 (expressionB -> OR np_push_operator expression .)
    COMMA           reduce using rule 76 (expressionB -> OR np_push_operator expression .)
    SEMICOLON       reduce using rule 76 (expressionB -> OR np_push_operator expression .)


state 299

    (77) expressionB -> AND np_push_operator expression .

    R_PAR           reduce using rule 77 (expressionB -> AND np_push_operator expression .)
    COMMA           reduce using rule 77 (expressionB -> AND np_push_operator expression .)
    SEMICOLON       reduce using rule 77 (expressionB -> AND np_push_operator expression .)


state 300

    (87) logic2 -> LESS np_push_operator exp .

    OR              reduce using rule 87 (logic2 -> LESS np_push_operator exp .)
    AND             reduce using rule 87 (logic2 -> LESS np_push_operator exp .)
    R_PAR           reduce using rule 87 (logic2 -> LESS np_push_operator exp .)
    COMMA           reduce using rule 87 (logic2 -> LESS np_push_operator exp .)
    SEMICOLON       reduce using rule 87 (logic2 -> LESS np_push_operator exp .)


state 301

    (88) logic2 -> GREATER np_push_operator exp .

    OR              reduce using rule 88 (logic2 -> GREATER np_push_operator exp .)
    AND             reduce using rule 88 (logic2 -> GREATER np_push_operator exp .)
    R_PAR           reduce using rule 88 (logic2 -> GREATER np_push_operator exp .)
    COMMA           reduce using rule 88 (logic2 -> GREATER np_push_operator exp .)
    SEMICOLON       reduce using rule 88 (logic2 -> GREATER np_push_operator exp .)


state 302

    (89) logic2 -> LESS_EQ np_push_operator exp .

    OR              reduce using rule 89 (logic2 -> LESS_EQ np_push_operator exp .)
    AND             reduce using rule 89 (logic2 -> LESS_EQ np_push_operator exp .)
    R_PAR           reduce using rule 89 (logic2 -> LESS_EQ np_push_operator exp .)
    COMMA           reduce using rule 89 (logic2 -> LESS_EQ np_push_operator exp .)
    SEMICOLON       reduce using rule 89 (logic2 -> LESS_EQ np_push_operator exp .)


state 303

    (90) logic2 -> GREATER_EQ np_push_operator exp .

    OR              reduce using rule 90 (logic2 -> GREATER_EQ np_push_operator exp .)
    AND             reduce using rule 90 (logic2 -> GREATER_EQ np_push_operator exp .)
    R_PAR           reduce using rule 90 (logic2 -> GREATER_EQ np_push_operator exp .)
    COMMA           reduce using rule 90 (logic2 -> GREATER_EQ np_push_operator exp .)
    SEMICOLON       reduce using rule 90 (logic2 -> GREATER_EQ np_push_operator exp .)


state 304

    (91) logic2 -> EQUIVALENT np_push_operator exp .

    OR              reduce using rule 91 (logic2 -> EQUIVALENT np_push_operator exp .)
    AND             reduce using rule 91 (logic2 -> EQUIVALENT np_push_operator exp .)
    R_PAR           reduce using rule 91 (logic2 -> EQUIVALENT np_push_operator exp .)
    COMMA           reduce using rule 91 (logic2 -> EQUIVALENT np_push_operator exp .)
    SEMICOLON       reduce using rule 91 (logic2 -> EQUIVALENT np_push_operator exp .)


state 305

    (92) logic2 -> DIFFERENT np_push_operator exp .

    OR              reduce using rule 92 (logic2 -> DIFFERENT np_push_operator exp .)
    AND             reduce using rule 92 (logic2 -> DIFFERENT np_push_operator exp .)
    R_PAR           reduce using rule 92 (logic2 -> DIFFERENT np_push_operator exp .)
    COMMA           reduce using rule 92 (logic2 -> DIFFERENT np_push_operator exp .)
    SEMICOLON       reduce using rule 92 (logic2 -> DIFFERENT np_push_operator exp .)


state 306

    (66) writeC -> COMMA writeB .

    R_PAR           reduce using rule 66 (writeC -> COMMA writeB .)


state 307

    (68) loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF . block np_GOTO_WHILE
    (23) block -> . L_BRACE blockB R_BRACE

    L_BRACE         shift and go to state 297

    block                          shift and go to state 317

state 308

    (69) loop_range -> FOR var np_push_operand EQUAL np_push_operator exp np_set_VC . TO exp np_end np_comp_VC_VF block np_GOTO_FOR

    TO              shift and go to state 318


state 309

    (70) return -> RETURN L_PAR np_stop exp np_end np_set_return R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 319


state 310

    (72) func_call_arguments -> np_stop exp np_end np_param .
    (73) func_call_arguments -> np_stop exp np_end np_param . COMMA func_call_arguments

    R_PAR           reduce using rule 72 (func_call_arguments -> np_stop exp np_end np_param .)
    COMMA           shift and go to state 320


state 311

    (49) predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .

    EXP             reduce using rule 49 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    MULT            reduce using rule 49 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    DIV             reduce using rule 49 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    REMAINDER       reduce using rule 49 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    PLUS            reduce using rule 49 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    MINUS           reduce using rule 49 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    R_BRACKET       reduce using rule 49 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    LESS            reduce using rule 49 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    GREATER         reduce using rule 49 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    LESS_EQ         reduce using rule 49 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    GREATER_EQ      reduce using rule 49 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    EQUIVALENT      reduce using rule 49 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    DIFFERENT       reduce using rule 49 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    OR              reduce using rule 49 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    AND             reduce using rule 49 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    R_PAR           reduce using rule 49 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    COMMA           reduce using rule 49 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    SEMICOLON       reduce using rule 49 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    TO              reduce using rule 49 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    L_BRACE         reduce using rule 49 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)


state 312

    (50) predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .

    EXP             reduce using rule 50 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    MULT            reduce using rule 50 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    DIV             reduce using rule 50 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    REMAINDER       reduce using rule 50 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    PLUS            reduce using rule 50 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    MINUS           reduce using rule 50 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    R_BRACKET       reduce using rule 50 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    LESS            reduce using rule 50 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    GREATER         reduce using rule 50 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    LESS_EQ         reduce using rule 50 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    GREATER_EQ      reduce using rule 50 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    EQUIVALENT      reduce using rule 50 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    DIFFERENT       reduce using rule 50 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    OR              reduce using rule 50 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    AND             reduce using rule 50 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    R_PAR           reduce using rule 50 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    COMMA           reduce using rule 50 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    SEMICOLON       reduce using rule 50 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    TO              reduce using rule 50 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    L_BRACE         reduce using rule 50 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)


state 313

    (52) predef_func -> DOT L_PAR vector COMMA vector R_PAR .

    EXP             reduce using rule 52 (predef_func -> DOT L_PAR vector COMMA vector R_PAR .)
    MULT            reduce using rule 52 (predef_func -> DOT L_PAR vector COMMA vector R_PAR .)
    DIV             reduce using rule 52 (predef_func -> DOT L_PAR vector COMMA vector R_PAR .)
    REMAINDER       reduce using rule 52 (predef_func -> DOT L_PAR vector COMMA vector R_PAR .)
    PLUS            reduce using rule 52 (predef_func -> DOT L_PAR vector COMMA vector R_PAR .)
    MINUS           reduce using rule 52 (predef_func -> DOT L_PAR vector COMMA vector R_PAR .)
    R_BRACKET       reduce using rule 52 (predef_func -> DOT L_PAR vector COMMA vector R_PAR .)
    LESS            reduce using rule 52 (predef_func -> DOT L_PAR vector COMMA vector R_PAR .)
    GREATER         reduce using rule 52 (predef_func -> DOT L_PAR vector COMMA vector R_PAR .)
    LESS_EQ         reduce using rule 52 (predef_func -> DOT L_PAR vector COMMA vector R_PAR .)
    GREATER_EQ      reduce using rule 52 (predef_func -> DOT L_PAR vector COMMA vector R_PAR .)
    EQUIVALENT      reduce using rule 52 (predef_func -> DOT L_PAR vector COMMA vector R_PAR .)
    DIFFERENT       reduce using rule 52 (predef_func -> DOT L_PAR vector COMMA vector R_PAR .)
    OR              reduce using rule 52 (predef_func -> DOT L_PAR vector COMMA vector R_PAR .)
    AND             reduce using rule 52 (predef_func -> DOT L_PAR vector COMMA vector R_PAR .)
    R_PAR           reduce using rule 52 (predef_func -> DOT L_PAR vector COMMA vector R_PAR .)
    COMMA           reduce using rule 52 (predef_func -> DOT L_PAR vector COMMA vector R_PAR .)
    SEMICOLON       reduce using rule 52 (predef_func -> DOT L_PAR vector COMMA vector R_PAR .)
    TO              reduce using rule 52 (predef_func -> DOT L_PAR vector COMMA vector R_PAR .)
    L_BRACE         reduce using rule 52 (predef_func -> DOT L_PAR vector COMMA vector R_PAR .)


state 314

    (57) condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block cond2 . np_GOTO_END
    (141) np_GOTO_END -> .

    IF              reduce using rule 141 (np_GOTO_END -> .)
    READ            reduce using rule 141 (np_GOTO_END -> .)
    WRITE           reduce using rule 141 (np_GOTO_END -> .)
    WHILE           reduce using rule 141 (np_GOTO_END -> .)
    FOR             reduce using rule 141 (np_GOTO_END -> .)
    RETURN          reduce using rule 141 (np_GOTO_END -> .)
    ID              reduce using rule 141 (np_GOTO_END -> .)
    R_BRACE         reduce using rule 141 (np_GOTO_END -> .)

    np_GOTO_END                    shift and go to state 321

state 315

    (58) cond2 -> np_GOTO_ELSE . ELSE block

    ELSE            shift and go to state 322


state 316

    (59) cond2 -> empty .

    IF              reduce using rule 59 (cond2 -> empty .)
    READ            reduce using rule 59 (cond2 -> empty .)
    WRITE           reduce using rule 59 (cond2 -> empty .)
    WHILE           reduce using rule 59 (cond2 -> empty .)
    FOR             reduce using rule 59 (cond2 -> empty .)
    RETURN          reduce using rule 59 (cond2 -> empty .)
    ID              reduce using rule 59 (cond2 -> empty .)
    R_BRACE         reduce using rule 59 (cond2 -> empty .)


state 317

    (68) loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block . np_GOTO_WHILE
    (142) np_GOTO_WHILE -> .

    IF              reduce using rule 142 (np_GOTO_WHILE -> .)
    READ            reduce using rule 142 (np_GOTO_WHILE -> .)
    WRITE           reduce using rule 142 (np_GOTO_WHILE -> .)
    WHILE           reduce using rule 142 (np_GOTO_WHILE -> .)
    FOR             reduce using rule 142 (np_GOTO_WHILE -> .)
    RETURN          reduce using rule 142 (np_GOTO_WHILE -> .)
    ID              reduce using rule 142 (np_GOTO_WHILE -> .)
    R_BRACE         reduce using rule 142 (np_GOTO_WHILE -> .)

    np_GOTO_WHILE                  shift and go to state 323

state 318

    (69) loop_range -> FOR var np_push_operand EQUAL np_push_operator exp np_set_VC TO . exp np_end np_comp_VC_VF block np_GOTO_FOR
    (94) exp -> . term exp2
    (98) term -> . factor term2
    (103) factor -> . exponent factorB
    (106) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (107) exponent -> . exponentB
    (108) exponentB -> . MINUS var_cte
    (109) exponentB -> . var_cte
    (110) var_cte -> . var np_push_operand
    (111) var_cte -> . predef_func
    (112) var_cte -> . func_call
    (113) var_cte -> . CTE_INT np_push_cte_int
    (114) var_cte -> . CTE_FLOAT np_push_cte_float
    (115) var_cte -> . CTE_CHAR np_push_cte_char
    (116) var_cte -> . CTE_STRING np_push_cte_str
    (117) var_cte -> . CTE_BOOL np_push_cte_bool
    (18) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (19) var -> . ID
    (43) predef_func -> . LENGTH L_PAR vector R_PAR
    (44) predef_func -> . MIN L_PAR vector R_PAR
    (45) predef_func -> . MAX L_PAR vector R_PAR
    (46) predef_func -> . MEAN L_PAR vector R_PAR
    (47) predef_func -> . MEDIAN L_PAR vector R_PAR
    (48) predef_func -> . MODE L_PAR vector R_PAR
    (49) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (50) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . VARIANCE L_PAR vector R_PAR
    (52) predef_func -> . DOT L_PAR vector COMMA vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (54) predef_func -> . ABS L_PAR CTE_INT R_PAR
    (55) predef_func -> . ROOF L_PAR CTE_FLOAT R_PAR
    (56) predef_func -> . FLOOR L_PAR CTE_FLOAT R_PAR
    (71) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 98
    MINUS           shift and go to state 100
    CTE_INT         shift and go to state 105
    CTE_FLOAT       shift and go to state 106
    CTE_CHAR        shift and go to state 107
    CTE_STRING      shift and go to state 108
    CTE_BOOL        shift and go to state 109
    ID              shift and go to state 73
    LENGTH          shift and go to state 110
    MIN             shift and go to state 111
    MAX             shift and go to state 112
    MEAN            shift and go to state 113
    MEDIAN          shift and go to state 114
    MODE            shift and go to state 115
    PLOT_XY         shift and go to state 116
    REGRESSION      shift and go to state 117
    VARIANCE        shift and go to state 118
    DOT             shift and go to state 119
    SUM             shift and go to state 120
    ABS             shift and go to state 121
    ROOF            shift and go to state 122
    FLOOR           shift and go to state 123

    var                            shift and go to state 102
    exp                            shift and go to state 324
    term                           shift and go to state 95
    factor                         shift and go to state 96
    exponent                       shift and go to state 97
    exponentB                      shift and go to state 99
    var_cte                        shift and go to state 101
    predef_func                    shift and go to state 103
    func_call                      shift and go to state 104

state 319

    (70) return -> RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON .

    IF              reduce using rule 70 (return -> RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON .)
    READ            reduce using rule 70 (return -> RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON .)
    WRITE           reduce using rule 70 (return -> RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON .)
    WHILE           reduce using rule 70 (return -> RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON .)
    FOR             reduce using rule 70 (return -> RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON .)
    RETURN          reduce using rule 70 (return -> RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON .)
    ID              reduce using rule 70 (return -> RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON .)
    R_BRACE         reduce using rule 70 (return -> RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON .)


state 320

    (73) func_call_arguments -> np_stop exp np_end np_param COMMA . func_call_arguments
    (72) func_call_arguments -> . np_stop exp np_end np_param
    (73) func_call_arguments -> . np_stop exp np_end np_param COMMA func_call_arguments
    (74) func_call_arguments -> . empty
    (153) np_stop -> .
    (118) empty -> .

    L_PAR           reduce using rule 153 (np_stop -> .)
    MINUS           reduce using rule 153 (np_stop -> .)
    CTE_INT         reduce using rule 153 (np_stop -> .)
    CTE_FLOAT       reduce using rule 153 (np_stop -> .)
    CTE_CHAR        reduce using rule 153 (np_stop -> .)
    CTE_STRING      reduce using rule 153 (np_stop -> .)
    CTE_BOOL        reduce using rule 153 (np_stop -> .)
    ID              reduce using rule 153 (np_stop -> .)
    LENGTH          reduce using rule 153 (np_stop -> .)
    MIN             reduce using rule 153 (np_stop -> .)
    MAX             reduce using rule 153 (np_stop -> .)
    MEAN            reduce using rule 153 (np_stop -> .)
    MEDIAN          reduce using rule 153 (np_stop -> .)
    MODE            reduce using rule 153 (np_stop -> .)
    PLOT_XY         reduce using rule 153 (np_stop -> .)
    REGRESSION      reduce using rule 153 (np_stop -> .)
    VARIANCE        reduce using rule 153 (np_stop -> .)
    DOT             reduce using rule 153 (np_stop -> .)
    SUM             reduce using rule 153 (np_stop -> .)
    ABS             reduce using rule 153 (np_stop -> .)
    ROOF            reduce using rule 153 (np_stop -> .)
    FLOOR           reduce using rule 153 (np_stop -> .)
    R_PAR           reduce using rule 118 (empty -> .)

    np_stop                        shift and go to state 198
    func_call_arguments            shift and go to state 325
    empty                          shift and go to state 199

state 321

    (57) condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END .

    IF              reduce using rule 57 (condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END .)
    READ            reduce using rule 57 (condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END .)
    WRITE           reduce using rule 57 (condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END .)
    WHILE           reduce using rule 57 (condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END .)
    FOR             reduce using rule 57 (condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END .)
    RETURN          reduce using rule 57 (condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END .)
    ID              reduce using rule 57 (condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END .)
    R_BRACE         reduce using rule 57 (condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END .)


state 322

    (58) cond2 -> np_GOTO_ELSE ELSE . block
    (23) block -> . L_BRACE blockB R_BRACE

    L_BRACE         shift and go to state 297

    block                          shift and go to state 326

state 323

    (68) loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE .

    IF              reduce using rule 68 (loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE .)
    READ            reduce using rule 68 (loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE .)
    WRITE           reduce using rule 68 (loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE .)
    WHILE           reduce using rule 68 (loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE .)
    FOR             reduce using rule 68 (loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE .)
    RETURN          reduce using rule 68 (loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE .)
    ID              reduce using rule 68 (loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE .)
    R_BRACE         reduce using rule 68 (loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE .)


state 324

    (69) loop_range -> FOR var np_push_operand EQUAL np_push_operator exp np_set_VC TO exp . np_end np_comp_VC_VF block np_GOTO_FOR
    (133) np_end -> .

    L_BRACE         reduce using rule 133 (np_end -> .)

    np_end                         shift and go to state 327

state 325

    (73) func_call_arguments -> np_stop exp np_end np_param COMMA func_call_arguments .

    R_PAR           reduce using rule 73 (func_call_arguments -> np_stop exp np_end np_param COMMA func_call_arguments .)


state 326

    (58) cond2 -> np_GOTO_ELSE ELSE block .

    IF              reduce using rule 58 (cond2 -> np_GOTO_ELSE ELSE block .)
    READ            reduce using rule 58 (cond2 -> np_GOTO_ELSE ELSE block .)
    WRITE           reduce using rule 58 (cond2 -> np_GOTO_ELSE ELSE block .)
    WHILE           reduce using rule 58 (cond2 -> np_GOTO_ELSE ELSE block .)
    FOR             reduce using rule 58 (cond2 -> np_GOTO_ELSE ELSE block .)
    RETURN          reduce using rule 58 (cond2 -> np_GOTO_ELSE ELSE block .)
    ID              reduce using rule 58 (cond2 -> np_GOTO_ELSE ELSE block .)
    R_BRACE         reduce using rule 58 (cond2 -> np_GOTO_ELSE ELSE block .)


state 327

    (69) loop_range -> FOR var np_push_operand EQUAL np_push_operator exp np_set_VC TO exp np_end . np_comp_VC_VF block np_GOTO_FOR
    (137) np_comp_VC_VF -> .

    L_BRACE         reduce using rule 137 (np_comp_VC_VF -> .)

    np_comp_VC_VF                  shift and go to state 328

state 328

    (69) loop_range -> FOR var np_push_operand EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF . block np_GOTO_FOR
    (23) block -> . L_BRACE blockB R_BRACE

    L_BRACE         shift and go to state 297

    block                          shift and go to state 329

state 329

    (69) loop_range -> FOR var np_push_operand EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block . np_GOTO_FOR
    (143) np_GOTO_FOR -> .

    IF              reduce using rule 143 (np_GOTO_FOR -> .)
    READ            reduce using rule 143 (np_GOTO_FOR -> .)
    WRITE           reduce using rule 143 (np_GOTO_FOR -> .)
    WHILE           reduce using rule 143 (np_GOTO_FOR -> .)
    FOR             reduce using rule 143 (np_GOTO_FOR -> .)
    RETURN          reduce using rule 143 (np_GOTO_FOR -> .)
    ID              reduce using rule 143 (np_GOTO_FOR -> .)
    R_BRACE         reduce using rule 143 (np_GOTO_FOR -> .)

    np_GOTO_FOR                    shift and go to state 330

state 330

    (69) loop_range -> FOR var np_push_operand EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR .

    IF              reduce using rule 69 (loop_range -> FOR var np_push_operand EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR .)
    READ            reduce using rule 69 (loop_range -> FOR var np_push_operand EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR .)
    WRITE           reduce using rule 69 (loop_range -> FOR var np_push_operand EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR .)
    WHILE           reduce using rule 69 (loop_range -> FOR var np_push_operand EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR .)
    FOR             reduce using rule 69 (loop_range -> FOR var np_push_operand EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR .)
    RETURN          reduce using rule 69 (loop_range -> FOR var np_push_operand EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR .)
    ID              reduce using rule 69 (loop_range -> FOR var np_push_operand EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR .)
    R_BRACE         reduce using rule 69 (loop_range -> FOR var np_push_operand EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for CTE_STRING in state 87 resolved as shift
WARNING: shift/reduce conflict for CTE_STRING in state 282 resolved as shift
