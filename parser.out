Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM np_set_curr_proc ID np_GOTO SEMICOLON programB np_prog_end
Rule 2     programB -> vars programC
Rule 3     programB -> programC
Rule 4     programC -> function programC
Rule 5     programC -> main
Rule 6     vars -> VARS L_BRACE varsB R_BRACE
Rule 7     varsB -> type np_set_curr_datatype COLON varsC SEMICOLON
Rule 8     varsB -> type np_set_curr_datatype COLON varsC SEMICOLON varsB
Rule 9     varsC -> varsD
Rule 10    varsC -> varsD COMMA varsC
Rule 11    varsD -> ID np_add_var
Rule 12    varsD -> ID L_BRACKET CTE_INT R_BRACKET np_add_arr
Rule 13    function -> FUNCTION func_type ID np_set_curr_proc L_PAR params R_PAR np_set_quad_start vblock np_ENDFunc
Rule 14    main -> MAIN np_set_curr_proc np_GOTO_END L_PAR R_PAR vblock
Rule 15    type -> INT np_add_datatype
Rule 16    type -> FLOAT np_add_datatype
Rule 17    type -> BOOL np_add_datatype
Rule 18    type -> CHAR np_add_datatype
Rule 19    type -> STRING np_add_datatype
Rule 20    var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
Rule 21    var -> ID np_push_operand
Rule 22    vector -> ID L_BRACKET R_BRACKET
Rule 23    func_type -> VOID np_add_datatype
Rule 24    func_type -> type
Rule 25    block -> L_BRACE blockB R_BRACE
Rule 26    blockB -> statement blockB
Rule 27    blockB -> empty
Rule 28    vblock -> L_BRACE vars vblockB R_BRACE
Rule 29    vblock -> block
Rule 30    vblockB -> statement vblockB
Rule 31    vblockB -> empty
Rule 32    params -> type COLON ID np_add_param
Rule 33    params -> type COLON ID np_add_param COMMA params
Rule 34    params -> empty
Rule 35    statement -> assign
Rule 36    statement -> condicional
Rule 37    statement -> read
Rule 38    statement -> write
Rule 39    statement -> loop_cond
Rule 40    statement -> loop_range
Rule 41    statement -> return
Rule 42    statement -> void_func
Rule 43    void_func -> func_call SEMICOLON
Rule 44    assign -> var oper_assign np_push_operator expression np_end SEMICOLON
Rule 45    predef_func -> MIN L_PAR vector R_PAR
Rule 46    predef_func -> MAX L_PAR vector R_PAR
Rule 47    predef_func -> MEAN L_PAR vector R_PAR
Rule 48    predef_func -> MEDIAN L_PAR vector R_PAR
Rule 49    predef_func -> MODE L_PAR vector R_PAR
Rule 50    predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR
Rule 51    predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR
Rule 52    predef_func -> VARIANCE L_PAR vector R_PAR
Rule 53    predef_func -> SUM L_PAR vector R_PAR
Rule 54    condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END
Rule 55    cond2 -> np_GOTO_ELSE ELSE block
Rule 56    cond2 -> empty
Rule 57    read -> READ L_PAR read2 R_PAR SEMICOLON
Rule 58    read2 -> var np_read
Rule 59    read2 -> var np_read COMMA read2
Rule 60    write -> WRITE L_PAR writeB R_PAR SEMICOLON
Rule 61    writeB -> expression np_end np_write writeC
Rule 62    writeB -> CTE_STRING np_push_cte_str np_write writeC
Rule 63    writeC -> COMMA writeB
Rule 64    writeC -> empty
Rule 65    loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE
Rule 66    loop_range -> FOR var EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR
Rule 67    return -> RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON
Rule 68    func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB
Rule 69    func_call_arguments -> np_stop exp np_end np_param
Rule 70    func_call_arguments -> np_stop exp np_end np_param COMMA func_call_arguments
Rule 71    func_call_arguments -> empty
Rule 72    expression -> logic expressionB
Rule 73    expressionB -> OR np_push_operator expression
Rule 74    expressionB -> AND np_push_operator expression
Rule 75    expressionB -> empty
Rule 76    oper_assign -> EQUAL
Rule 77    oper_assign -> MULT_EQ
Rule 78    oper_assign -> DIV_EQ
Rule 79    oper_assign -> PLUS_EQ
Rule 80    oper_assign -> MINUS_EQ
Rule 81    logic -> exp logic2
Rule 82    logic2 -> LESS np_push_operator exp
Rule 83    logic2 -> GREATER np_push_operator exp
Rule 84    logic2 -> LESS_EQ np_push_operator exp
Rule 85    logic2 -> GREATER_EQ np_push_operator exp
Rule 86    logic2 -> EQUIVALENT np_push_operator exp
Rule 87    logic2 -> DIFFERENT np_push_operator exp
Rule 88    logic2 -> empty
Rule 89    exp -> term exp2
Rule 90    exp2 -> PLUS np_push_operator exp
Rule 91    exp2 -> MINUS np_push_operator exp
Rule 92    exp2 -> empty
Rule 93    term -> factor term2
Rule 94    term2 -> MULT np_push_operator term
Rule 95    term2 -> DIV np_push_operator term
Rule 96    term2 -> REMAINDER np_push_operator term
Rule 97    term2 -> empty
Rule 98    factor -> exponent factorB
Rule 99    factorB -> EXP factor
Rule 100   factorB -> empty
Rule 101   exponent -> L_PAR np_push_operator expression R_PAR np_rpar
Rule 102   exponent -> exponentB
Rule 103   exponentB -> MINUS var_cte
Rule 104   exponentB -> var_cte
Rule 105   var_cte -> var
Rule 106   var_cte -> predef_func
Rule 107   var_cte -> func_call
Rule 108   var_cte -> CTE_INT np_push_cte_int
Rule 109   var_cte -> CTE_FLOAT np_push_cte_float
Rule 110   var_cte -> CTE_CHAR np_push_cte_char
Rule 111   var_cte -> CTE_STRING np_push_cte_str
Rule 112   var_cte -> CTE_BOOL np_push_cte_bool
Rule 113   empty -> <empty>
Rule 114   np_set_curr_proc -> <empty>
Rule 115   np_push_operator -> <empty>
Rule 116   np_push_operand -> <empty>
Rule 117   np_push_cte_int -> <empty>
Rule 118   np_push_cte_float -> <empty>
Rule 119   np_push_cte_char -> <empty>
Rule 120   np_push_cte_str -> <empty>
Rule 121   np_push_cte_bool -> <empty>
Rule 122   np_set_curr_datatype -> <empty>
Rule 123   np_add_datatype -> <empty>
Rule 124   np_add_var -> <empty>
Rule 125   np_add_arr -> <empty>
Rule 126   np_rpar -> <empty>
Rule 127   np_set_return -> <empty>
Rule 128   np_end -> <empty>
Rule 129   np_read -> <empty>
Rule 130   np_write -> <empty>
Rule 131   np_set_VC -> <empty>
Rule 132   np_comp_VC_VF -> <empty>
Rule 133   np_GOTO -> <empty>
Rule 134   np_GOTOF -> <empty>
Rule 135   np_GOTO_ELSE -> <empty>
Rule 136   np_GOTO_END -> <empty>
Rule 137   np_GOTO_WHILE -> <empty>
Rule 138   np_GOTO_FOR -> <empty>
Rule 139   np_CHECKPOINT -> <empty>
Rule 140   np_add_param -> <empty>
Rule 141   np_set_quad_start -> <empty>
Rule 142   np_GOSUB -> <empty>
Rule 143   np_ERA -> <empty>
Rule 144   np_param -> <empty>
Rule 145   np_ENDFunc -> <empty>
Rule 146   np_arr_start -> <empty>
Rule 147   np_arr_end -> <empty>
Rule 148   np_stop -> <empty>
Rule 149   np_prog_end -> <empty>

Terminals, with rules where they appear

AND                  : 74
BOOL                 : 17
CHAR                 : 18
COLON                : 7 8 32 33
COMMA                : 10 33 50 51 59 63 70
CTE_BOOL             : 112
CTE_CHAR             : 110
CTE_FLOAT            : 109
CTE_INT              : 12 108
CTE_STRING           : 62 111
DIFFERENT            : 87
DIV                  : 95
DIV_EQ               : 78
ELSE                 : 55
EQUAL                : 66 76
EQUIVALENT           : 86
EXP                  : 99
FLOAT                : 16
FOR                  : 66
FUNCTION             : 13
GREATER              : 83
GREATER_EQ           : 85
ID                   : 1 11 12 13 20 21 22 32 33 68
IF                   : 54
INT                  : 15
LESS                 : 82
LESS_EQ              : 84
L_BRACE              : 6 25 28
L_BRACKET            : 12 20 22
L_PAR                : 13 14 45 46 47 48 49 50 51 52 53 54 57 60 65 67 68 101
MAIN                 : 14
MAX                  : 46
MEAN                 : 47
MEDIAN               : 48
MIN                  : 45
MINUS                : 91 103
MINUS_EQ             : 80
MODE                 : 49
MULT                 : 94
MULT_EQ              : 77
OR                   : 73
PLOT_XY              : 50
PLUS                 : 90
PLUS_EQ              : 79
PROGRAM              : 1
READ                 : 57
REGRESSION           : 51
REMAINDER            : 96
RETURN               : 67
R_BRACE              : 6 25 28
R_BRACKET            : 12 20 22
R_PAR                : 13 14 45 46 47 48 49 50 51 52 53 54 57 60 65 67 68 101
SEMICOLON            : 1 7 8 43 44 57 60 67
STRING               : 19
SUM                  : 53
TO                   : 66
VARIANCE             : 52
VARS                 : 6
VOID                 : 23
WHILE                : 65
WRITE                : 60
error                : 

Nonterminals, with rules where they appear

assign               : 35
block                : 29 54 55 65 66
blockB               : 25 26
cond2                : 54
condicional          : 36
empty                : 27 31 34 56 64 71 75 88 92 97 100
exp                  : 20 66 66 67 69 70 81 82 83 84 85 86 87 90 91
exp2                 : 89
exponent             : 98
exponentB            : 102
expression           : 44 54 61 65 73 74 101
expressionB          : 72
factor               : 93 99
factorB              : 98
func_call            : 43 107
func_call_arguments  : 68 70
func_type            : 13
function             : 4
logic                : 72
logic2               : 81
loop_cond            : 39
loop_range           : 40
main                 : 5
np_CHECKPOINT        : 65
np_ENDFunc           : 13
np_ERA               : 68
np_GOSUB             : 68
np_GOTO              : 1
np_GOTOF             : 54 65
np_GOTO_ELSE         : 55
np_GOTO_END          : 14 54
np_GOTO_FOR          : 66
np_GOTO_WHILE        : 65
np_add_arr           : 12
np_add_datatype      : 15 16 17 18 19 23
np_add_param         : 32 33
np_add_var           : 11
np_arr_end           : 20
np_arr_start         : 20
np_comp_VC_VF        : 66
np_end               : 20 44 54 61 65 66 67 69 70
np_param             : 69 70
np_prog_end          : 1
np_push_cte_bool     : 112
np_push_cte_char     : 110
np_push_cte_float    : 109
np_push_cte_int      : 108
np_push_cte_str      : 62 111
np_push_operand      : 21
np_push_operator     : 44 66 73 74 82 83 84 85 86 87 90 91 94 95 96 101
np_read              : 58 59
np_rpar              : 101
np_set_VC            : 66
np_set_curr_datatype : 7 8
np_set_curr_proc     : 1 13 14
np_set_quad_start    : 13
np_set_return        : 67
np_stop              : 67 69 70
np_write             : 61 62
oper_assign          : 44
params               : 13 33
predef_func          : 106
program              : 0
programB             : 1
programC             : 2 3 4
read                 : 37
read2                : 57 59
return               : 41
statement            : 26 30
term                 : 89 94 95 96
term2                : 93
type                 : 7 8 24 32 33
var                  : 44 58 59 66 105
var_cte              : 103 104
vars                 : 2 28
varsB                : 6 8
varsC                : 7 8 10
varsD                : 9 10
vblock               : 13 14
vblockB              : 28 30
vector               : 45 46 47 48 49 50 50 51 51 52 53
void_func            : 42
write                : 38
writeB               : 60 63
writeC               : 61 62

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM np_set_curr_proc ID np_GOTO SEMICOLON programB np_prog_end

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . np_set_curr_proc ID np_GOTO SEMICOLON programB np_prog_end
    (114) np_set_curr_proc -> .

    ID              reduce using rule 114 (np_set_curr_proc -> .)

    np_set_curr_proc               shift and go to state 3

state 3

    (1) program -> PROGRAM np_set_curr_proc . ID np_GOTO SEMICOLON programB np_prog_end

    ID              shift and go to state 4


state 4

    (1) program -> PROGRAM np_set_curr_proc ID . np_GOTO SEMICOLON programB np_prog_end
    (133) np_GOTO -> .

    SEMICOLON       reduce using rule 133 (np_GOTO -> .)

    np_GOTO                        shift and go to state 5

state 5

    (1) program -> PROGRAM np_set_curr_proc ID np_GOTO . SEMICOLON programB np_prog_end

    SEMICOLON       shift and go to state 6


state 6

    (1) program -> PROGRAM np_set_curr_proc ID np_GOTO SEMICOLON . programB np_prog_end
    (2) programB -> . vars programC
    (3) programB -> . programC
    (6) vars -> . VARS L_BRACE varsB R_BRACE
    (4) programC -> . function programC
    (5) programC -> . main
    (13) function -> . FUNCTION func_type ID np_set_curr_proc L_PAR params R_PAR np_set_quad_start vblock np_ENDFunc
    (14) main -> . MAIN np_set_curr_proc np_GOTO_END L_PAR R_PAR vblock

    VARS            shift and go to state 10
    FUNCTION        shift and go to state 13
    MAIN            shift and go to state 14

    programB                       shift and go to state 7
    vars                           shift and go to state 8
    programC                       shift and go to state 9
    function                       shift and go to state 11
    main                           shift and go to state 12

state 7

    (1) program -> PROGRAM np_set_curr_proc ID np_GOTO SEMICOLON programB . np_prog_end
    (149) np_prog_end -> .

    $end            reduce using rule 149 (np_prog_end -> .)

    np_prog_end                    shift and go to state 15

state 8

    (2) programB -> vars . programC
    (4) programC -> . function programC
    (5) programC -> . main
    (13) function -> . FUNCTION func_type ID np_set_curr_proc L_PAR params R_PAR np_set_quad_start vblock np_ENDFunc
    (14) main -> . MAIN np_set_curr_proc np_GOTO_END L_PAR R_PAR vblock

    FUNCTION        shift and go to state 13
    MAIN            shift and go to state 14

    programC                       shift and go to state 16
    function                       shift and go to state 11
    main                           shift and go to state 12

state 9

    (3) programB -> programC .

    $end            reduce using rule 3 (programB -> programC .)


state 10

    (6) vars -> VARS . L_BRACE varsB R_BRACE

    L_BRACE         shift and go to state 17


state 11

    (4) programC -> function . programC
    (4) programC -> . function programC
    (5) programC -> . main
    (13) function -> . FUNCTION func_type ID np_set_curr_proc L_PAR params R_PAR np_set_quad_start vblock np_ENDFunc
    (14) main -> . MAIN np_set_curr_proc np_GOTO_END L_PAR R_PAR vblock

    FUNCTION        shift and go to state 13
    MAIN            shift and go to state 14

    function                       shift and go to state 11
    programC                       shift and go to state 18
    main                           shift and go to state 12

state 12

    (5) programC -> main .

    $end            reduce using rule 5 (programC -> main .)


state 13

    (13) function -> FUNCTION . func_type ID np_set_curr_proc L_PAR params R_PAR np_set_quad_start vblock np_ENDFunc
    (23) func_type -> . VOID np_add_datatype
    (24) func_type -> . type
    (15) type -> . INT np_add_datatype
    (16) type -> . FLOAT np_add_datatype
    (17) type -> . BOOL np_add_datatype
    (18) type -> . CHAR np_add_datatype
    (19) type -> . STRING np_add_datatype

    VOID            shift and go to state 20
    INT             shift and go to state 22
    FLOAT           shift and go to state 23
    BOOL            shift and go to state 24
    CHAR            shift and go to state 25
    STRING          shift and go to state 26

    func_type                      shift and go to state 19
    type                           shift and go to state 21

state 14

    (14) main -> MAIN . np_set_curr_proc np_GOTO_END L_PAR R_PAR vblock
    (114) np_set_curr_proc -> .

    L_PAR           reduce using rule 114 (np_set_curr_proc -> .)

    np_set_curr_proc               shift and go to state 27

state 15

    (1) program -> PROGRAM np_set_curr_proc ID np_GOTO SEMICOLON programB np_prog_end .

    $end            reduce using rule 1 (program -> PROGRAM np_set_curr_proc ID np_GOTO SEMICOLON programB np_prog_end .)


state 16

    (2) programB -> vars programC .

    $end            reduce using rule 2 (programB -> vars programC .)


state 17

    (6) vars -> VARS L_BRACE . varsB R_BRACE
    (7) varsB -> . type np_set_curr_datatype COLON varsC SEMICOLON
    (8) varsB -> . type np_set_curr_datatype COLON varsC SEMICOLON varsB
    (15) type -> . INT np_add_datatype
    (16) type -> . FLOAT np_add_datatype
    (17) type -> . BOOL np_add_datatype
    (18) type -> . CHAR np_add_datatype
    (19) type -> . STRING np_add_datatype

    INT             shift and go to state 22
    FLOAT           shift and go to state 23
    BOOL            shift and go to state 24
    CHAR            shift and go to state 25
    STRING          shift and go to state 26

    varsB                          shift and go to state 28
    type                           shift and go to state 29

state 18

    (4) programC -> function programC .

    $end            reduce using rule 4 (programC -> function programC .)


state 19

    (13) function -> FUNCTION func_type . ID np_set_curr_proc L_PAR params R_PAR np_set_quad_start vblock np_ENDFunc

    ID              shift and go to state 30


state 20

    (23) func_type -> VOID . np_add_datatype
    (123) np_add_datatype -> .

    ID              reduce using rule 123 (np_add_datatype -> .)

    np_add_datatype                shift and go to state 31

state 21

    (24) func_type -> type .

    ID              reduce using rule 24 (func_type -> type .)


state 22

    (15) type -> INT . np_add_datatype
    (123) np_add_datatype -> .

    ID              reduce using rule 123 (np_add_datatype -> .)
    COLON           reduce using rule 123 (np_add_datatype -> .)

    np_add_datatype                shift and go to state 32

state 23

    (16) type -> FLOAT . np_add_datatype
    (123) np_add_datatype -> .

    ID              reduce using rule 123 (np_add_datatype -> .)
    COLON           reduce using rule 123 (np_add_datatype -> .)

    np_add_datatype                shift and go to state 33

state 24

    (17) type -> BOOL . np_add_datatype
    (123) np_add_datatype -> .

    ID              reduce using rule 123 (np_add_datatype -> .)
    COLON           reduce using rule 123 (np_add_datatype -> .)

    np_add_datatype                shift and go to state 34

state 25

    (18) type -> CHAR . np_add_datatype
    (123) np_add_datatype -> .

    ID              reduce using rule 123 (np_add_datatype -> .)
    COLON           reduce using rule 123 (np_add_datatype -> .)

    np_add_datatype                shift and go to state 35

state 26

    (19) type -> STRING . np_add_datatype
    (123) np_add_datatype -> .

    ID              reduce using rule 123 (np_add_datatype -> .)
    COLON           reduce using rule 123 (np_add_datatype -> .)

    np_add_datatype                shift and go to state 36

state 27

    (14) main -> MAIN np_set_curr_proc . np_GOTO_END L_PAR R_PAR vblock
    (136) np_GOTO_END -> .

    L_PAR           reduce using rule 136 (np_GOTO_END -> .)

    np_GOTO_END                    shift and go to state 37

state 28

    (6) vars -> VARS L_BRACE varsB . R_BRACE

    R_BRACE         shift and go to state 38


state 29

    (7) varsB -> type . np_set_curr_datatype COLON varsC SEMICOLON
    (8) varsB -> type . np_set_curr_datatype COLON varsC SEMICOLON varsB
    (122) np_set_curr_datatype -> .

    COLON           reduce using rule 122 (np_set_curr_datatype -> .)

    np_set_curr_datatype           shift and go to state 39

state 30

    (13) function -> FUNCTION func_type ID . np_set_curr_proc L_PAR params R_PAR np_set_quad_start vblock np_ENDFunc
    (114) np_set_curr_proc -> .

    L_PAR           reduce using rule 114 (np_set_curr_proc -> .)

    np_set_curr_proc               shift and go to state 40

state 31

    (23) func_type -> VOID np_add_datatype .

    ID              reduce using rule 23 (func_type -> VOID np_add_datatype .)


state 32

    (15) type -> INT np_add_datatype .

    ID              reduce using rule 15 (type -> INT np_add_datatype .)
    COLON           reduce using rule 15 (type -> INT np_add_datatype .)


state 33

    (16) type -> FLOAT np_add_datatype .

    ID              reduce using rule 16 (type -> FLOAT np_add_datatype .)
    COLON           reduce using rule 16 (type -> FLOAT np_add_datatype .)


state 34

    (17) type -> BOOL np_add_datatype .

    ID              reduce using rule 17 (type -> BOOL np_add_datatype .)
    COLON           reduce using rule 17 (type -> BOOL np_add_datatype .)


state 35

    (18) type -> CHAR np_add_datatype .

    ID              reduce using rule 18 (type -> CHAR np_add_datatype .)
    COLON           reduce using rule 18 (type -> CHAR np_add_datatype .)


state 36

    (19) type -> STRING np_add_datatype .

    ID              reduce using rule 19 (type -> STRING np_add_datatype .)
    COLON           reduce using rule 19 (type -> STRING np_add_datatype .)


state 37

    (14) main -> MAIN np_set_curr_proc np_GOTO_END . L_PAR R_PAR vblock

    L_PAR           shift and go to state 41


state 38

    (6) vars -> VARS L_BRACE varsB R_BRACE .

    FUNCTION        reduce using rule 6 (vars -> VARS L_BRACE varsB R_BRACE .)
    MAIN            reduce using rule 6 (vars -> VARS L_BRACE varsB R_BRACE .)
    IF              reduce using rule 6 (vars -> VARS L_BRACE varsB R_BRACE .)
    READ            reduce using rule 6 (vars -> VARS L_BRACE varsB R_BRACE .)
    WRITE           reduce using rule 6 (vars -> VARS L_BRACE varsB R_BRACE .)
    WHILE           reduce using rule 6 (vars -> VARS L_BRACE varsB R_BRACE .)
    FOR             reduce using rule 6 (vars -> VARS L_BRACE varsB R_BRACE .)
    RETURN          reduce using rule 6 (vars -> VARS L_BRACE varsB R_BRACE .)
    ID              reduce using rule 6 (vars -> VARS L_BRACE varsB R_BRACE .)
    R_BRACE         reduce using rule 6 (vars -> VARS L_BRACE varsB R_BRACE .)


state 39

    (7) varsB -> type np_set_curr_datatype . COLON varsC SEMICOLON
    (8) varsB -> type np_set_curr_datatype . COLON varsC SEMICOLON varsB

    COLON           shift and go to state 42


state 40

    (13) function -> FUNCTION func_type ID np_set_curr_proc . L_PAR params R_PAR np_set_quad_start vblock np_ENDFunc

    L_PAR           shift and go to state 43


state 41

    (14) main -> MAIN np_set_curr_proc np_GOTO_END L_PAR . R_PAR vblock

    R_PAR           shift and go to state 44


state 42

    (7) varsB -> type np_set_curr_datatype COLON . varsC SEMICOLON
    (8) varsB -> type np_set_curr_datatype COLON . varsC SEMICOLON varsB
    (9) varsC -> . varsD
    (10) varsC -> . varsD COMMA varsC
    (11) varsD -> . ID np_add_var
    (12) varsD -> . ID L_BRACKET CTE_INT R_BRACKET np_add_arr

    ID              shift and go to state 47

    varsC                          shift and go to state 45
    varsD                          shift and go to state 46

state 43

    (13) function -> FUNCTION func_type ID np_set_curr_proc L_PAR . params R_PAR np_set_quad_start vblock np_ENDFunc
    (32) params -> . type COLON ID np_add_param
    (33) params -> . type COLON ID np_add_param COMMA params
    (34) params -> . empty
    (15) type -> . INT np_add_datatype
    (16) type -> . FLOAT np_add_datatype
    (17) type -> . BOOL np_add_datatype
    (18) type -> . CHAR np_add_datatype
    (19) type -> . STRING np_add_datatype
    (113) empty -> .

    INT             shift and go to state 22
    FLOAT           shift and go to state 23
    BOOL            shift and go to state 24
    CHAR            shift and go to state 25
    STRING          shift and go to state 26
    R_PAR           reduce using rule 113 (empty -> .)

    params                         shift and go to state 48
    type                           shift and go to state 49
    empty                          shift and go to state 50

state 44

    (14) main -> MAIN np_set_curr_proc np_GOTO_END L_PAR R_PAR . vblock
    (28) vblock -> . L_BRACE vars vblockB R_BRACE
    (29) vblock -> . block
    (25) block -> . L_BRACE blockB R_BRACE

    L_BRACE         shift and go to state 52

    vblock                         shift and go to state 51
    block                          shift and go to state 53

state 45

    (7) varsB -> type np_set_curr_datatype COLON varsC . SEMICOLON
    (8) varsB -> type np_set_curr_datatype COLON varsC . SEMICOLON varsB

    SEMICOLON       shift and go to state 54


state 46

    (9) varsC -> varsD .
    (10) varsC -> varsD . COMMA varsC

    SEMICOLON       reduce using rule 9 (varsC -> varsD .)
    COMMA           shift and go to state 55


state 47

    (11) varsD -> ID . np_add_var
    (12) varsD -> ID . L_BRACKET CTE_INT R_BRACKET np_add_arr
    (124) np_add_var -> .

    L_BRACKET       shift and go to state 57
    COMMA           reduce using rule 124 (np_add_var -> .)
    SEMICOLON       reduce using rule 124 (np_add_var -> .)

    np_add_var                     shift and go to state 56

state 48

    (13) function -> FUNCTION func_type ID np_set_curr_proc L_PAR params . R_PAR np_set_quad_start vblock np_ENDFunc

    R_PAR           shift and go to state 58


state 49

    (32) params -> type . COLON ID np_add_param
    (33) params -> type . COLON ID np_add_param COMMA params

    COLON           shift and go to state 59


state 50

    (34) params -> empty .

    R_PAR           reduce using rule 34 (params -> empty .)


state 51

    (14) main -> MAIN np_set_curr_proc np_GOTO_END L_PAR R_PAR vblock .

    $end            reduce using rule 14 (main -> MAIN np_set_curr_proc np_GOTO_END L_PAR R_PAR vblock .)


state 52

    (28) vblock -> L_BRACE . vars vblockB R_BRACE
    (25) block -> L_BRACE . blockB R_BRACE
    (6) vars -> . VARS L_BRACE varsB R_BRACE
    (26) blockB -> . statement blockB
    (27) blockB -> . empty
    (35) statement -> . assign
    (36) statement -> . condicional
    (37) statement -> . read
    (38) statement -> . write
    (39) statement -> . loop_cond
    (40) statement -> . loop_range
    (41) statement -> . return
    (42) statement -> . void_func
    (113) empty -> .
    (44) assign -> . var oper_assign np_push_operator expression np_end SEMICOLON
    (54) condicional -> . IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END
    (57) read -> . READ L_PAR read2 R_PAR SEMICOLON
    (60) write -> . WRITE L_PAR writeB R_PAR SEMICOLON
    (65) loop_cond -> . WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE
    (66) loop_range -> . FOR var EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR
    (67) return -> . RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON
    (43) void_func -> . func_call SEMICOLON
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    VARS            shift and go to state 10
    R_BRACE         reduce using rule 113 (empty -> .)
    IF              shift and go to state 73
    READ            shift and go to state 74
    WRITE           shift and go to state 75
    WHILE           shift and go to state 76
    FOR             shift and go to state 77
    RETURN          shift and go to state 78
    ID              shift and go to state 80

    vars                           shift and go to state 60
    blockB                         shift and go to state 61
    statement                      shift and go to state 62
    empty                          shift and go to state 63
    assign                         shift and go to state 64
    condicional                    shift and go to state 65
    read                           shift and go to state 66
    write                          shift and go to state 67
    loop_cond                      shift and go to state 68
    loop_range                     shift and go to state 69
    return                         shift and go to state 70
    void_func                      shift and go to state 71
    var                            shift and go to state 72
    func_call                      shift and go to state 79

state 53

    (29) vblock -> block .

    $end            reduce using rule 29 (vblock -> block .)
    FUNCTION        reduce using rule 29 (vblock -> block .)
    MAIN            reduce using rule 29 (vblock -> block .)


state 54

    (7) varsB -> type np_set_curr_datatype COLON varsC SEMICOLON .
    (8) varsB -> type np_set_curr_datatype COLON varsC SEMICOLON . varsB
    (7) varsB -> . type np_set_curr_datatype COLON varsC SEMICOLON
    (8) varsB -> . type np_set_curr_datatype COLON varsC SEMICOLON varsB
    (15) type -> . INT np_add_datatype
    (16) type -> . FLOAT np_add_datatype
    (17) type -> . BOOL np_add_datatype
    (18) type -> . CHAR np_add_datatype
    (19) type -> . STRING np_add_datatype

    R_BRACE         reduce using rule 7 (varsB -> type np_set_curr_datatype COLON varsC SEMICOLON .)
    INT             shift and go to state 22
    FLOAT           shift and go to state 23
    BOOL            shift and go to state 24
    CHAR            shift and go to state 25
    STRING          shift and go to state 26

    type                           shift and go to state 29
    varsB                          shift and go to state 81

state 55

    (10) varsC -> varsD COMMA . varsC
    (9) varsC -> . varsD
    (10) varsC -> . varsD COMMA varsC
    (11) varsD -> . ID np_add_var
    (12) varsD -> . ID L_BRACKET CTE_INT R_BRACKET np_add_arr

    ID              shift and go to state 47

    varsD                          shift and go to state 46
    varsC                          shift and go to state 82

state 56

    (11) varsD -> ID np_add_var .

    COMMA           reduce using rule 11 (varsD -> ID np_add_var .)
    SEMICOLON       reduce using rule 11 (varsD -> ID np_add_var .)


state 57

    (12) varsD -> ID L_BRACKET . CTE_INT R_BRACKET np_add_arr

    CTE_INT         shift and go to state 83


state 58

    (13) function -> FUNCTION func_type ID np_set_curr_proc L_PAR params R_PAR . np_set_quad_start vblock np_ENDFunc
    (141) np_set_quad_start -> .

    L_BRACE         reduce using rule 141 (np_set_quad_start -> .)

    np_set_quad_start              shift and go to state 84

state 59

    (32) params -> type COLON . ID np_add_param
    (33) params -> type COLON . ID np_add_param COMMA params

    ID              shift and go to state 85


state 60

    (28) vblock -> L_BRACE vars . vblockB R_BRACE
    (30) vblockB -> . statement vblockB
    (31) vblockB -> . empty
    (35) statement -> . assign
    (36) statement -> . condicional
    (37) statement -> . read
    (38) statement -> . write
    (39) statement -> . loop_cond
    (40) statement -> . loop_range
    (41) statement -> . return
    (42) statement -> . void_func
    (113) empty -> .
    (44) assign -> . var oper_assign np_push_operator expression np_end SEMICOLON
    (54) condicional -> . IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END
    (57) read -> . READ L_PAR read2 R_PAR SEMICOLON
    (60) write -> . WRITE L_PAR writeB R_PAR SEMICOLON
    (65) loop_cond -> . WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE
    (66) loop_range -> . FOR var EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR
    (67) return -> . RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON
    (43) void_func -> . func_call SEMICOLON
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    R_BRACE         reduce using rule 113 (empty -> .)
    IF              shift and go to state 73
    READ            shift and go to state 74
    WRITE           shift and go to state 75
    WHILE           shift and go to state 76
    FOR             shift and go to state 77
    RETURN          shift and go to state 78
    ID              shift and go to state 80

    vblockB                        shift and go to state 86
    statement                      shift and go to state 87
    empty                          shift and go to state 88
    assign                         shift and go to state 64
    condicional                    shift and go to state 65
    read                           shift and go to state 66
    write                          shift and go to state 67
    loop_cond                      shift and go to state 68
    loop_range                     shift and go to state 69
    return                         shift and go to state 70
    void_func                      shift and go to state 71
    var                            shift and go to state 72
    func_call                      shift and go to state 79

state 61

    (25) block -> L_BRACE blockB . R_BRACE

    R_BRACE         shift and go to state 89


state 62

    (26) blockB -> statement . blockB
    (26) blockB -> . statement blockB
    (27) blockB -> . empty
    (35) statement -> . assign
    (36) statement -> . condicional
    (37) statement -> . read
    (38) statement -> . write
    (39) statement -> . loop_cond
    (40) statement -> . loop_range
    (41) statement -> . return
    (42) statement -> . void_func
    (113) empty -> .
    (44) assign -> . var oper_assign np_push_operator expression np_end SEMICOLON
    (54) condicional -> . IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END
    (57) read -> . READ L_PAR read2 R_PAR SEMICOLON
    (60) write -> . WRITE L_PAR writeB R_PAR SEMICOLON
    (65) loop_cond -> . WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE
    (66) loop_range -> . FOR var EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR
    (67) return -> . RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON
    (43) void_func -> . func_call SEMICOLON
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    R_BRACE         reduce using rule 113 (empty -> .)
    IF              shift and go to state 73
    READ            shift and go to state 74
    WRITE           shift and go to state 75
    WHILE           shift and go to state 76
    FOR             shift and go to state 77
    RETURN          shift and go to state 78
    ID              shift and go to state 80

    statement                      shift and go to state 62
    blockB                         shift and go to state 90
    empty                          shift and go to state 63
    assign                         shift and go to state 64
    condicional                    shift and go to state 65
    read                           shift and go to state 66
    write                          shift and go to state 67
    loop_cond                      shift and go to state 68
    loop_range                     shift and go to state 69
    return                         shift and go to state 70
    void_func                      shift and go to state 71
    var                            shift and go to state 72
    func_call                      shift and go to state 79

state 63

    (27) blockB -> empty .

    R_BRACE         reduce using rule 27 (blockB -> empty .)


state 64

    (35) statement -> assign .

    IF              reduce using rule 35 (statement -> assign .)
    READ            reduce using rule 35 (statement -> assign .)
    WRITE           reduce using rule 35 (statement -> assign .)
    WHILE           reduce using rule 35 (statement -> assign .)
    FOR             reduce using rule 35 (statement -> assign .)
    RETURN          reduce using rule 35 (statement -> assign .)
    ID              reduce using rule 35 (statement -> assign .)
    R_BRACE         reduce using rule 35 (statement -> assign .)


state 65

    (36) statement -> condicional .

    IF              reduce using rule 36 (statement -> condicional .)
    READ            reduce using rule 36 (statement -> condicional .)
    WRITE           reduce using rule 36 (statement -> condicional .)
    WHILE           reduce using rule 36 (statement -> condicional .)
    FOR             reduce using rule 36 (statement -> condicional .)
    RETURN          reduce using rule 36 (statement -> condicional .)
    ID              reduce using rule 36 (statement -> condicional .)
    R_BRACE         reduce using rule 36 (statement -> condicional .)


state 66

    (37) statement -> read .

    IF              reduce using rule 37 (statement -> read .)
    READ            reduce using rule 37 (statement -> read .)
    WRITE           reduce using rule 37 (statement -> read .)
    WHILE           reduce using rule 37 (statement -> read .)
    FOR             reduce using rule 37 (statement -> read .)
    RETURN          reduce using rule 37 (statement -> read .)
    ID              reduce using rule 37 (statement -> read .)
    R_BRACE         reduce using rule 37 (statement -> read .)


state 67

    (38) statement -> write .

    IF              reduce using rule 38 (statement -> write .)
    READ            reduce using rule 38 (statement -> write .)
    WRITE           reduce using rule 38 (statement -> write .)
    WHILE           reduce using rule 38 (statement -> write .)
    FOR             reduce using rule 38 (statement -> write .)
    RETURN          reduce using rule 38 (statement -> write .)
    ID              reduce using rule 38 (statement -> write .)
    R_BRACE         reduce using rule 38 (statement -> write .)


state 68

    (39) statement -> loop_cond .

    IF              reduce using rule 39 (statement -> loop_cond .)
    READ            reduce using rule 39 (statement -> loop_cond .)
    WRITE           reduce using rule 39 (statement -> loop_cond .)
    WHILE           reduce using rule 39 (statement -> loop_cond .)
    FOR             reduce using rule 39 (statement -> loop_cond .)
    RETURN          reduce using rule 39 (statement -> loop_cond .)
    ID              reduce using rule 39 (statement -> loop_cond .)
    R_BRACE         reduce using rule 39 (statement -> loop_cond .)


state 69

    (40) statement -> loop_range .

    IF              reduce using rule 40 (statement -> loop_range .)
    READ            reduce using rule 40 (statement -> loop_range .)
    WRITE           reduce using rule 40 (statement -> loop_range .)
    WHILE           reduce using rule 40 (statement -> loop_range .)
    FOR             reduce using rule 40 (statement -> loop_range .)
    RETURN          reduce using rule 40 (statement -> loop_range .)
    ID              reduce using rule 40 (statement -> loop_range .)
    R_BRACE         reduce using rule 40 (statement -> loop_range .)


state 70

    (41) statement -> return .

    IF              reduce using rule 41 (statement -> return .)
    READ            reduce using rule 41 (statement -> return .)
    WRITE           reduce using rule 41 (statement -> return .)
    WHILE           reduce using rule 41 (statement -> return .)
    FOR             reduce using rule 41 (statement -> return .)
    RETURN          reduce using rule 41 (statement -> return .)
    ID              reduce using rule 41 (statement -> return .)
    R_BRACE         reduce using rule 41 (statement -> return .)


state 71

    (42) statement -> void_func .

    IF              reduce using rule 42 (statement -> void_func .)
    READ            reduce using rule 42 (statement -> void_func .)
    WRITE           reduce using rule 42 (statement -> void_func .)
    WHILE           reduce using rule 42 (statement -> void_func .)
    FOR             reduce using rule 42 (statement -> void_func .)
    RETURN          reduce using rule 42 (statement -> void_func .)
    ID              reduce using rule 42 (statement -> void_func .)
    R_BRACE         reduce using rule 42 (statement -> void_func .)


state 72

    (44) assign -> var . oper_assign np_push_operator expression np_end SEMICOLON
    (76) oper_assign -> . EQUAL
    (77) oper_assign -> . MULT_EQ
    (78) oper_assign -> . DIV_EQ
    (79) oper_assign -> . PLUS_EQ
    (80) oper_assign -> . MINUS_EQ

    EQUAL           shift and go to state 92
    MULT_EQ         shift and go to state 93
    DIV_EQ          shift and go to state 94
    PLUS_EQ         shift and go to state 95
    MINUS_EQ        shift and go to state 96

    oper_assign                    shift and go to state 91

state 73

    (54) condicional -> IF . L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END

    L_PAR           shift and go to state 97


state 74

    (57) read -> READ . L_PAR read2 R_PAR SEMICOLON

    L_PAR           shift and go to state 98


state 75

    (60) write -> WRITE . L_PAR writeB R_PAR SEMICOLON

    L_PAR           shift and go to state 99


state 76

    (65) loop_cond -> WHILE . L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE

    L_PAR           shift and go to state 100


state 77

    (66) loop_range -> FOR . var EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand

    ID              shift and go to state 102

    var                            shift and go to state 101

state 78

    (67) return -> RETURN . L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON

    L_PAR           shift and go to state 103


state 79

    (43) void_func -> func_call . SEMICOLON

    SEMICOLON       shift and go to state 104


state 80

    (20) var -> ID . L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> ID . np_push_operand
    (68) func_call -> ID . np_ERA L_PAR func_call_arguments R_PAR np_GOSUB
    (116) np_push_operand -> .
    (143) np_ERA -> .

    L_BRACKET       shift and go to state 105
    EQUAL           reduce using rule 116 (np_push_operand -> .)
    MULT_EQ         reduce using rule 116 (np_push_operand -> .)
    DIV_EQ          reduce using rule 116 (np_push_operand -> .)
    PLUS_EQ         reduce using rule 116 (np_push_operand -> .)
    MINUS_EQ        reduce using rule 116 (np_push_operand -> .)
    EXP             reduce using rule 116 (np_push_operand -> .)
    MULT            reduce using rule 116 (np_push_operand -> .)
    DIV             reduce using rule 116 (np_push_operand -> .)
    REMAINDER       reduce using rule 116 (np_push_operand -> .)
    PLUS            reduce using rule 116 (np_push_operand -> .)
    MINUS           reduce using rule 116 (np_push_operand -> .)
    LESS            reduce using rule 116 (np_push_operand -> .)
    GREATER         reduce using rule 116 (np_push_operand -> .)
    LESS_EQ         reduce using rule 116 (np_push_operand -> .)
    GREATER_EQ      reduce using rule 116 (np_push_operand -> .)
    EQUIVALENT      reduce using rule 116 (np_push_operand -> .)
    DIFFERENT       reduce using rule 116 (np_push_operand -> .)
    OR              reduce using rule 116 (np_push_operand -> .)
    AND             reduce using rule 116 (np_push_operand -> .)
    R_PAR           reduce using rule 116 (np_push_operand -> .)
    COMMA           reduce using rule 116 (np_push_operand -> .)
    SEMICOLON       reduce using rule 116 (np_push_operand -> .)
    R_BRACKET       reduce using rule 116 (np_push_operand -> .)
    TO              reduce using rule 116 (np_push_operand -> .)
    L_BRACE         reduce using rule 116 (np_push_operand -> .)
    L_PAR           reduce using rule 143 (np_ERA -> .)

    np_push_operand                shift and go to state 106
    np_ERA                         shift and go to state 107

state 81

    (8) varsB -> type np_set_curr_datatype COLON varsC SEMICOLON varsB .

    R_BRACE         reduce using rule 8 (varsB -> type np_set_curr_datatype COLON varsC SEMICOLON varsB .)


state 82

    (10) varsC -> varsD COMMA varsC .

    SEMICOLON       reduce using rule 10 (varsC -> varsD COMMA varsC .)


state 83

    (12) varsD -> ID L_BRACKET CTE_INT . R_BRACKET np_add_arr

    R_BRACKET       shift and go to state 108


state 84

    (13) function -> FUNCTION func_type ID np_set_curr_proc L_PAR params R_PAR np_set_quad_start . vblock np_ENDFunc
    (28) vblock -> . L_BRACE vars vblockB R_BRACE
    (29) vblock -> . block
    (25) block -> . L_BRACE blockB R_BRACE

    L_BRACE         shift and go to state 52

    vblock                         shift and go to state 109
    block                          shift and go to state 53

state 85

    (32) params -> type COLON ID . np_add_param
    (33) params -> type COLON ID . np_add_param COMMA params
    (140) np_add_param -> .

    COMMA           reduce using rule 140 (np_add_param -> .)
    R_PAR           reduce using rule 140 (np_add_param -> .)

    np_add_param                   shift and go to state 110

state 86

    (28) vblock -> L_BRACE vars vblockB . R_BRACE

    R_BRACE         shift and go to state 111


state 87

    (30) vblockB -> statement . vblockB
    (30) vblockB -> . statement vblockB
    (31) vblockB -> . empty
    (35) statement -> . assign
    (36) statement -> . condicional
    (37) statement -> . read
    (38) statement -> . write
    (39) statement -> . loop_cond
    (40) statement -> . loop_range
    (41) statement -> . return
    (42) statement -> . void_func
    (113) empty -> .
    (44) assign -> . var oper_assign np_push_operator expression np_end SEMICOLON
    (54) condicional -> . IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END
    (57) read -> . READ L_PAR read2 R_PAR SEMICOLON
    (60) write -> . WRITE L_PAR writeB R_PAR SEMICOLON
    (65) loop_cond -> . WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE
    (66) loop_range -> . FOR var EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR
    (67) return -> . RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON
    (43) void_func -> . func_call SEMICOLON
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    R_BRACE         reduce using rule 113 (empty -> .)
    IF              shift and go to state 73
    READ            shift and go to state 74
    WRITE           shift and go to state 75
    WHILE           shift and go to state 76
    FOR             shift and go to state 77
    RETURN          shift and go to state 78
    ID              shift and go to state 80

    statement                      shift and go to state 87
    vblockB                        shift and go to state 112
    empty                          shift and go to state 88
    assign                         shift and go to state 64
    condicional                    shift and go to state 65
    read                           shift and go to state 66
    write                          shift and go to state 67
    loop_cond                      shift and go to state 68
    loop_range                     shift and go to state 69
    return                         shift and go to state 70
    void_func                      shift and go to state 71
    var                            shift and go to state 72
    func_call                      shift and go to state 79

state 88

    (31) vblockB -> empty .

    R_BRACE         reduce using rule 31 (vblockB -> empty .)


state 89

    (25) block -> L_BRACE blockB R_BRACE .

    $end            reduce using rule 25 (block -> L_BRACE blockB R_BRACE .)
    FUNCTION        reduce using rule 25 (block -> L_BRACE blockB R_BRACE .)
    MAIN            reduce using rule 25 (block -> L_BRACE blockB R_BRACE .)
    ELSE            reduce using rule 25 (block -> L_BRACE blockB R_BRACE .)
    IF              reduce using rule 25 (block -> L_BRACE blockB R_BRACE .)
    READ            reduce using rule 25 (block -> L_BRACE blockB R_BRACE .)
    WRITE           reduce using rule 25 (block -> L_BRACE blockB R_BRACE .)
    WHILE           reduce using rule 25 (block -> L_BRACE blockB R_BRACE .)
    FOR             reduce using rule 25 (block -> L_BRACE blockB R_BRACE .)
    RETURN          reduce using rule 25 (block -> L_BRACE blockB R_BRACE .)
    ID              reduce using rule 25 (block -> L_BRACE blockB R_BRACE .)
    R_BRACE         reduce using rule 25 (block -> L_BRACE blockB R_BRACE .)


state 90

    (26) blockB -> statement blockB .

    R_BRACE         reduce using rule 26 (blockB -> statement blockB .)


state 91

    (44) assign -> var oper_assign . np_push_operator expression np_end SEMICOLON
    (115) np_push_operator -> .

    L_PAR           reduce using rule 115 (np_push_operator -> .)
    MINUS           reduce using rule 115 (np_push_operator -> .)
    CTE_INT         reduce using rule 115 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 115 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 115 (np_push_operator -> .)
    CTE_STRING      reduce using rule 115 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 115 (np_push_operator -> .)
    ID              reduce using rule 115 (np_push_operator -> .)
    MIN             reduce using rule 115 (np_push_operator -> .)
    MAX             reduce using rule 115 (np_push_operator -> .)
    MEAN            reduce using rule 115 (np_push_operator -> .)
    MEDIAN          reduce using rule 115 (np_push_operator -> .)
    MODE            reduce using rule 115 (np_push_operator -> .)
    PLOT_XY         reduce using rule 115 (np_push_operator -> .)
    REGRESSION      reduce using rule 115 (np_push_operator -> .)
    VARIANCE        reduce using rule 115 (np_push_operator -> .)
    SUM             reduce using rule 115 (np_push_operator -> .)

    np_push_operator               shift and go to state 113

state 92

    (76) oper_assign -> EQUAL .

    L_PAR           reduce using rule 76 (oper_assign -> EQUAL .)
    MINUS           reduce using rule 76 (oper_assign -> EQUAL .)
    CTE_INT         reduce using rule 76 (oper_assign -> EQUAL .)
    CTE_FLOAT       reduce using rule 76 (oper_assign -> EQUAL .)
    CTE_CHAR        reduce using rule 76 (oper_assign -> EQUAL .)
    CTE_STRING      reduce using rule 76 (oper_assign -> EQUAL .)
    CTE_BOOL        reduce using rule 76 (oper_assign -> EQUAL .)
    ID              reduce using rule 76 (oper_assign -> EQUAL .)
    MIN             reduce using rule 76 (oper_assign -> EQUAL .)
    MAX             reduce using rule 76 (oper_assign -> EQUAL .)
    MEAN            reduce using rule 76 (oper_assign -> EQUAL .)
    MEDIAN          reduce using rule 76 (oper_assign -> EQUAL .)
    MODE            reduce using rule 76 (oper_assign -> EQUAL .)
    PLOT_XY         reduce using rule 76 (oper_assign -> EQUAL .)
    REGRESSION      reduce using rule 76 (oper_assign -> EQUAL .)
    VARIANCE        reduce using rule 76 (oper_assign -> EQUAL .)
    SUM             reduce using rule 76 (oper_assign -> EQUAL .)


state 93

    (77) oper_assign -> MULT_EQ .

    L_PAR           reduce using rule 77 (oper_assign -> MULT_EQ .)
    MINUS           reduce using rule 77 (oper_assign -> MULT_EQ .)
    CTE_INT         reduce using rule 77 (oper_assign -> MULT_EQ .)
    CTE_FLOAT       reduce using rule 77 (oper_assign -> MULT_EQ .)
    CTE_CHAR        reduce using rule 77 (oper_assign -> MULT_EQ .)
    CTE_STRING      reduce using rule 77 (oper_assign -> MULT_EQ .)
    CTE_BOOL        reduce using rule 77 (oper_assign -> MULT_EQ .)
    ID              reduce using rule 77 (oper_assign -> MULT_EQ .)
    MIN             reduce using rule 77 (oper_assign -> MULT_EQ .)
    MAX             reduce using rule 77 (oper_assign -> MULT_EQ .)
    MEAN            reduce using rule 77 (oper_assign -> MULT_EQ .)
    MEDIAN          reduce using rule 77 (oper_assign -> MULT_EQ .)
    MODE            reduce using rule 77 (oper_assign -> MULT_EQ .)
    PLOT_XY         reduce using rule 77 (oper_assign -> MULT_EQ .)
    REGRESSION      reduce using rule 77 (oper_assign -> MULT_EQ .)
    VARIANCE        reduce using rule 77 (oper_assign -> MULT_EQ .)
    SUM             reduce using rule 77 (oper_assign -> MULT_EQ .)


state 94

    (78) oper_assign -> DIV_EQ .

    L_PAR           reduce using rule 78 (oper_assign -> DIV_EQ .)
    MINUS           reduce using rule 78 (oper_assign -> DIV_EQ .)
    CTE_INT         reduce using rule 78 (oper_assign -> DIV_EQ .)
    CTE_FLOAT       reduce using rule 78 (oper_assign -> DIV_EQ .)
    CTE_CHAR        reduce using rule 78 (oper_assign -> DIV_EQ .)
    CTE_STRING      reduce using rule 78 (oper_assign -> DIV_EQ .)
    CTE_BOOL        reduce using rule 78 (oper_assign -> DIV_EQ .)
    ID              reduce using rule 78 (oper_assign -> DIV_EQ .)
    MIN             reduce using rule 78 (oper_assign -> DIV_EQ .)
    MAX             reduce using rule 78 (oper_assign -> DIV_EQ .)
    MEAN            reduce using rule 78 (oper_assign -> DIV_EQ .)
    MEDIAN          reduce using rule 78 (oper_assign -> DIV_EQ .)
    MODE            reduce using rule 78 (oper_assign -> DIV_EQ .)
    PLOT_XY         reduce using rule 78 (oper_assign -> DIV_EQ .)
    REGRESSION      reduce using rule 78 (oper_assign -> DIV_EQ .)
    VARIANCE        reduce using rule 78 (oper_assign -> DIV_EQ .)
    SUM             reduce using rule 78 (oper_assign -> DIV_EQ .)


state 95

    (79) oper_assign -> PLUS_EQ .

    L_PAR           reduce using rule 79 (oper_assign -> PLUS_EQ .)
    MINUS           reduce using rule 79 (oper_assign -> PLUS_EQ .)
    CTE_INT         reduce using rule 79 (oper_assign -> PLUS_EQ .)
    CTE_FLOAT       reduce using rule 79 (oper_assign -> PLUS_EQ .)
    CTE_CHAR        reduce using rule 79 (oper_assign -> PLUS_EQ .)
    CTE_STRING      reduce using rule 79 (oper_assign -> PLUS_EQ .)
    CTE_BOOL        reduce using rule 79 (oper_assign -> PLUS_EQ .)
    ID              reduce using rule 79 (oper_assign -> PLUS_EQ .)
    MIN             reduce using rule 79 (oper_assign -> PLUS_EQ .)
    MAX             reduce using rule 79 (oper_assign -> PLUS_EQ .)
    MEAN            reduce using rule 79 (oper_assign -> PLUS_EQ .)
    MEDIAN          reduce using rule 79 (oper_assign -> PLUS_EQ .)
    MODE            reduce using rule 79 (oper_assign -> PLUS_EQ .)
    PLOT_XY         reduce using rule 79 (oper_assign -> PLUS_EQ .)
    REGRESSION      reduce using rule 79 (oper_assign -> PLUS_EQ .)
    VARIANCE        reduce using rule 79 (oper_assign -> PLUS_EQ .)
    SUM             reduce using rule 79 (oper_assign -> PLUS_EQ .)


state 96

    (80) oper_assign -> MINUS_EQ .

    L_PAR           reduce using rule 80 (oper_assign -> MINUS_EQ .)
    MINUS           reduce using rule 80 (oper_assign -> MINUS_EQ .)
    CTE_INT         reduce using rule 80 (oper_assign -> MINUS_EQ .)
    CTE_FLOAT       reduce using rule 80 (oper_assign -> MINUS_EQ .)
    CTE_CHAR        reduce using rule 80 (oper_assign -> MINUS_EQ .)
    CTE_STRING      reduce using rule 80 (oper_assign -> MINUS_EQ .)
    CTE_BOOL        reduce using rule 80 (oper_assign -> MINUS_EQ .)
    ID              reduce using rule 80 (oper_assign -> MINUS_EQ .)
    MIN             reduce using rule 80 (oper_assign -> MINUS_EQ .)
    MAX             reduce using rule 80 (oper_assign -> MINUS_EQ .)
    MEAN            reduce using rule 80 (oper_assign -> MINUS_EQ .)
    MEDIAN          reduce using rule 80 (oper_assign -> MINUS_EQ .)
    MODE            reduce using rule 80 (oper_assign -> MINUS_EQ .)
    PLOT_XY         reduce using rule 80 (oper_assign -> MINUS_EQ .)
    REGRESSION      reduce using rule 80 (oper_assign -> MINUS_EQ .)
    VARIANCE        reduce using rule 80 (oper_assign -> MINUS_EQ .)
    SUM             reduce using rule 80 (oper_assign -> MINUS_EQ .)


state 97

    (54) condicional -> IF L_PAR . expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END
    (72) expression -> . logic expressionB
    (81) logic -> . exp logic2
    (89) exp -> . term exp2
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    expression                     shift and go to state 115
    logic                          shift and go to state 116
    exp                            shift and go to state 117
    term                           shift and go to state 118
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 98

    (57) read -> READ L_PAR . read2 R_PAR SEMICOLON
    (58) read2 -> . var np_read
    (59) read2 -> . var np_read COMMA read2
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand

    ID              shift and go to state 102

    read2                          shift and go to state 141
    var                            shift and go to state 142

state 99

    (60) write -> WRITE L_PAR . writeB R_PAR SEMICOLON
    (61) writeB -> . expression np_end np_write writeC
    (62) writeB -> . CTE_STRING np_push_cte_str np_write writeC
    (72) expression -> . logic expressionB
    (81) logic -> . exp logic2
    (89) exp -> . term exp2
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    CTE_STRING      shift and go to state 145
    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    writeB                         shift and go to state 143
    expression                     shift and go to state 144
    logic                          shift and go to state 116
    exp                            shift and go to state 117
    term                           shift and go to state 118
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 100

    (65) loop_cond -> WHILE L_PAR . np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE
    (139) np_CHECKPOINT -> .

    L_PAR           reduce using rule 139 (np_CHECKPOINT -> .)
    MINUS           reduce using rule 139 (np_CHECKPOINT -> .)
    CTE_INT         reduce using rule 139 (np_CHECKPOINT -> .)
    CTE_FLOAT       reduce using rule 139 (np_CHECKPOINT -> .)
    CTE_CHAR        reduce using rule 139 (np_CHECKPOINT -> .)
    CTE_STRING      reduce using rule 139 (np_CHECKPOINT -> .)
    CTE_BOOL        reduce using rule 139 (np_CHECKPOINT -> .)
    ID              reduce using rule 139 (np_CHECKPOINT -> .)
    MIN             reduce using rule 139 (np_CHECKPOINT -> .)
    MAX             reduce using rule 139 (np_CHECKPOINT -> .)
    MEAN            reduce using rule 139 (np_CHECKPOINT -> .)
    MEDIAN          reduce using rule 139 (np_CHECKPOINT -> .)
    MODE            reduce using rule 139 (np_CHECKPOINT -> .)
    PLOT_XY         reduce using rule 139 (np_CHECKPOINT -> .)
    REGRESSION      reduce using rule 139 (np_CHECKPOINT -> .)
    VARIANCE        reduce using rule 139 (np_CHECKPOINT -> .)
    SUM             reduce using rule 139 (np_CHECKPOINT -> .)

    np_CHECKPOINT                  shift and go to state 146

state 101

    (66) loop_range -> FOR var . EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR

    EQUAL           shift and go to state 147


state 102

    (20) var -> ID . L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> ID . np_push_operand
    (116) np_push_operand -> .

    L_BRACKET       shift and go to state 105
    EQUAL           reduce using rule 116 (np_push_operand -> .)
    COMMA           reduce using rule 116 (np_push_operand -> .)
    R_PAR           reduce using rule 116 (np_push_operand -> .)

    np_push_operand                shift and go to state 106

state 103

    (67) return -> RETURN L_PAR . np_stop exp np_end np_set_return R_PAR SEMICOLON
    (148) np_stop -> .

    L_PAR           reduce using rule 148 (np_stop -> .)
    MINUS           reduce using rule 148 (np_stop -> .)
    CTE_INT         reduce using rule 148 (np_stop -> .)
    CTE_FLOAT       reduce using rule 148 (np_stop -> .)
    CTE_CHAR        reduce using rule 148 (np_stop -> .)
    CTE_STRING      reduce using rule 148 (np_stop -> .)
    CTE_BOOL        reduce using rule 148 (np_stop -> .)
    ID              reduce using rule 148 (np_stop -> .)
    MIN             reduce using rule 148 (np_stop -> .)
    MAX             reduce using rule 148 (np_stop -> .)
    MEAN            reduce using rule 148 (np_stop -> .)
    MEDIAN          reduce using rule 148 (np_stop -> .)
    MODE            reduce using rule 148 (np_stop -> .)
    PLOT_XY         reduce using rule 148 (np_stop -> .)
    REGRESSION      reduce using rule 148 (np_stop -> .)
    VARIANCE        reduce using rule 148 (np_stop -> .)
    SUM             reduce using rule 148 (np_stop -> .)

    np_stop                        shift and go to state 148

state 104

    (43) void_func -> func_call SEMICOLON .

    IF              reduce using rule 43 (void_func -> func_call SEMICOLON .)
    READ            reduce using rule 43 (void_func -> func_call SEMICOLON .)
    WRITE           reduce using rule 43 (void_func -> func_call SEMICOLON .)
    WHILE           reduce using rule 43 (void_func -> func_call SEMICOLON .)
    FOR             reduce using rule 43 (void_func -> func_call SEMICOLON .)
    RETURN          reduce using rule 43 (void_func -> func_call SEMICOLON .)
    ID              reduce using rule 43 (void_func -> func_call SEMICOLON .)
    R_BRACE         reduce using rule 43 (void_func -> func_call SEMICOLON .)


state 105

    (20) var -> ID L_BRACKET . np_arr_start exp np_end np_arr_end R_BRACKET
    (146) np_arr_start -> .

    L_PAR           reduce using rule 146 (np_arr_start -> .)
    MINUS           reduce using rule 146 (np_arr_start -> .)
    CTE_INT         reduce using rule 146 (np_arr_start -> .)
    CTE_FLOAT       reduce using rule 146 (np_arr_start -> .)
    CTE_CHAR        reduce using rule 146 (np_arr_start -> .)
    CTE_STRING      reduce using rule 146 (np_arr_start -> .)
    CTE_BOOL        reduce using rule 146 (np_arr_start -> .)
    ID              reduce using rule 146 (np_arr_start -> .)
    MIN             reduce using rule 146 (np_arr_start -> .)
    MAX             reduce using rule 146 (np_arr_start -> .)
    MEAN            reduce using rule 146 (np_arr_start -> .)
    MEDIAN          reduce using rule 146 (np_arr_start -> .)
    MODE            reduce using rule 146 (np_arr_start -> .)
    PLOT_XY         reduce using rule 146 (np_arr_start -> .)
    REGRESSION      reduce using rule 146 (np_arr_start -> .)
    VARIANCE        reduce using rule 146 (np_arr_start -> .)
    SUM             reduce using rule 146 (np_arr_start -> .)

    np_arr_start                   shift and go to state 149

state 106

    (21) var -> ID np_push_operand .

    EQUAL           reduce using rule 21 (var -> ID np_push_operand .)
    MULT_EQ         reduce using rule 21 (var -> ID np_push_operand .)
    DIV_EQ          reduce using rule 21 (var -> ID np_push_operand .)
    PLUS_EQ         reduce using rule 21 (var -> ID np_push_operand .)
    MINUS_EQ        reduce using rule 21 (var -> ID np_push_operand .)
    EXP             reduce using rule 21 (var -> ID np_push_operand .)
    MULT            reduce using rule 21 (var -> ID np_push_operand .)
    DIV             reduce using rule 21 (var -> ID np_push_operand .)
    REMAINDER       reduce using rule 21 (var -> ID np_push_operand .)
    PLUS            reduce using rule 21 (var -> ID np_push_operand .)
    MINUS           reduce using rule 21 (var -> ID np_push_operand .)
    LESS            reduce using rule 21 (var -> ID np_push_operand .)
    GREATER         reduce using rule 21 (var -> ID np_push_operand .)
    LESS_EQ         reduce using rule 21 (var -> ID np_push_operand .)
    GREATER_EQ      reduce using rule 21 (var -> ID np_push_operand .)
    EQUIVALENT      reduce using rule 21 (var -> ID np_push_operand .)
    DIFFERENT       reduce using rule 21 (var -> ID np_push_operand .)
    OR              reduce using rule 21 (var -> ID np_push_operand .)
    AND             reduce using rule 21 (var -> ID np_push_operand .)
    R_PAR           reduce using rule 21 (var -> ID np_push_operand .)
    COMMA           reduce using rule 21 (var -> ID np_push_operand .)
    SEMICOLON       reduce using rule 21 (var -> ID np_push_operand .)
    R_BRACKET       reduce using rule 21 (var -> ID np_push_operand .)
    TO              reduce using rule 21 (var -> ID np_push_operand .)
    L_BRACE         reduce using rule 21 (var -> ID np_push_operand .)


state 107

    (68) func_call -> ID np_ERA . L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 150


state 108

    (12) varsD -> ID L_BRACKET CTE_INT R_BRACKET . np_add_arr
    (125) np_add_arr -> .

    COMMA           reduce using rule 125 (np_add_arr -> .)
    SEMICOLON       reduce using rule 125 (np_add_arr -> .)

    np_add_arr                     shift and go to state 151

state 109

    (13) function -> FUNCTION func_type ID np_set_curr_proc L_PAR params R_PAR np_set_quad_start vblock . np_ENDFunc
    (145) np_ENDFunc -> .

    FUNCTION        reduce using rule 145 (np_ENDFunc -> .)
    MAIN            reduce using rule 145 (np_ENDFunc -> .)

    np_ENDFunc                     shift and go to state 152

state 110

    (32) params -> type COLON ID np_add_param .
    (33) params -> type COLON ID np_add_param . COMMA params

    R_PAR           reduce using rule 32 (params -> type COLON ID np_add_param .)
    COMMA           shift and go to state 153


state 111

    (28) vblock -> L_BRACE vars vblockB R_BRACE .

    $end            reduce using rule 28 (vblock -> L_BRACE vars vblockB R_BRACE .)
    FUNCTION        reduce using rule 28 (vblock -> L_BRACE vars vblockB R_BRACE .)
    MAIN            reduce using rule 28 (vblock -> L_BRACE vars vblockB R_BRACE .)


state 112

    (30) vblockB -> statement vblockB .

    R_BRACE         reduce using rule 30 (vblockB -> statement vblockB .)


state 113

    (44) assign -> var oper_assign np_push_operator . expression np_end SEMICOLON
    (72) expression -> . logic expressionB
    (81) logic -> . exp logic2
    (89) exp -> . term exp2
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    var                            shift and go to state 124
    expression                     shift and go to state 154
    logic                          shift and go to state 116
    exp                            shift and go to state 117
    term                           shift and go to state 118
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 114

    (101) exponent -> L_PAR . np_push_operator expression R_PAR np_rpar
    (115) np_push_operator -> .

    L_PAR           reduce using rule 115 (np_push_operator -> .)
    MINUS           reduce using rule 115 (np_push_operator -> .)
    CTE_INT         reduce using rule 115 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 115 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 115 (np_push_operator -> .)
    CTE_STRING      reduce using rule 115 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 115 (np_push_operator -> .)
    ID              reduce using rule 115 (np_push_operator -> .)
    MIN             reduce using rule 115 (np_push_operator -> .)
    MAX             reduce using rule 115 (np_push_operator -> .)
    MEAN            reduce using rule 115 (np_push_operator -> .)
    MEDIAN          reduce using rule 115 (np_push_operator -> .)
    MODE            reduce using rule 115 (np_push_operator -> .)
    PLOT_XY         reduce using rule 115 (np_push_operator -> .)
    REGRESSION      reduce using rule 115 (np_push_operator -> .)
    VARIANCE        reduce using rule 115 (np_push_operator -> .)
    SUM             reduce using rule 115 (np_push_operator -> .)

    np_push_operator               shift and go to state 155

state 115

    (54) condicional -> IF L_PAR expression . np_end np_GOTOF R_PAR block cond2 np_GOTO_END
    (128) np_end -> .

    R_PAR           reduce using rule 128 (np_end -> .)

    np_end                         shift and go to state 156

state 116

    (72) expression -> logic . expressionB
    (73) expressionB -> . OR np_push_operator expression
    (74) expressionB -> . AND np_push_operator expression
    (75) expressionB -> . empty
    (113) empty -> .

    OR              shift and go to state 158
    AND             shift and go to state 159
    R_PAR           reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)

    expressionB                    shift and go to state 157
    empty                          shift and go to state 160

state 117

    (81) logic -> exp . logic2
    (82) logic2 -> . LESS np_push_operator exp
    (83) logic2 -> . GREATER np_push_operator exp
    (84) logic2 -> . LESS_EQ np_push_operator exp
    (85) logic2 -> . GREATER_EQ np_push_operator exp
    (86) logic2 -> . EQUIVALENT np_push_operator exp
    (87) logic2 -> . DIFFERENT np_push_operator exp
    (88) logic2 -> . empty
    (113) empty -> .

    LESS            shift and go to state 162
    GREATER         shift and go to state 163
    LESS_EQ         shift and go to state 164
    GREATER_EQ      shift and go to state 165
    EQUIVALENT      shift and go to state 166
    DIFFERENT       shift and go to state 167
    OR              reduce using rule 113 (empty -> .)
    AND             reduce using rule 113 (empty -> .)
    R_PAR           reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)

    logic2                         shift and go to state 161
    empty                          shift and go to state 168

state 118

    (89) exp -> term . exp2
    (90) exp2 -> . PLUS np_push_operator exp
    (91) exp2 -> . MINUS np_push_operator exp
    (92) exp2 -> . empty
    (113) empty -> .

    PLUS            shift and go to state 170
    MINUS           shift and go to state 171
    LESS            reduce using rule 113 (empty -> .)
    GREATER         reduce using rule 113 (empty -> .)
    LESS_EQ         reduce using rule 113 (empty -> .)
    GREATER_EQ      reduce using rule 113 (empty -> .)
    EQUIVALENT      reduce using rule 113 (empty -> .)
    DIFFERENT       reduce using rule 113 (empty -> .)
    OR              reduce using rule 113 (empty -> .)
    AND             reduce using rule 113 (empty -> .)
    R_PAR           reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    R_BRACKET       reduce using rule 113 (empty -> .)
    TO              reduce using rule 113 (empty -> .)
    L_BRACE         reduce using rule 113 (empty -> .)

    exp2                           shift and go to state 169
    empty                          shift and go to state 172

state 119

    (93) term -> factor . term2
    (94) term2 -> . MULT np_push_operator term
    (95) term2 -> . DIV np_push_operator term
    (96) term2 -> . REMAINDER np_push_operator term
    (97) term2 -> . empty
    (113) empty -> .

    MULT            shift and go to state 174
    DIV             shift and go to state 175
    REMAINDER       shift and go to state 176
    PLUS            reduce using rule 113 (empty -> .)
    MINUS           reduce using rule 113 (empty -> .)
    LESS            reduce using rule 113 (empty -> .)
    GREATER         reduce using rule 113 (empty -> .)
    LESS_EQ         reduce using rule 113 (empty -> .)
    GREATER_EQ      reduce using rule 113 (empty -> .)
    EQUIVALENT      reduce using rule 113 (empty -> .)
    DIFFERENT       reduce using rule 113 (empty -> .)
    OR              reduce using rule 113 (empty -> .)
    AND             reduce using rule 113 (empty -> .)
    R_PAR           reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    R_BRACKET       reduce using rule 113 (empty -> .)
    TO              reduce using rule 113 (empty -> .)
    L_BRACE         reduce using rule 113 (empty -> .)

    term2                          shift and go to state 173
    empty                          shift and go to state 177

state 120

    (98) factor -> exponent . factorB
    (99) factorB -> . EXP factor
    (100) factorB -> . empty
    (113) empty -> .

    EXP             shift and go to state 179
    MULT            reduce using rule 113 (empty -> .)
    DIV             reduce using rule 113 (empty -> .)
    REMAINDER       reduce using rule 113 (empty -> .)
    PLUS            reduce using rule 113 (empty -> .)
    MINUS           reduce using rule 113 (empty -> .)
    LESS            reduce using rule 113 (empty -> .)
    GREATER         reduce using rule 113 (empty -> .)
    LESS_EQ         reduce using rule 113 (empty -> .)
    GREATER_EQ      reduce using rule 113 (empty -> .)
    EQUIVALENT      reduce using rule 113 (empty -> .)
    DIFFERENT       reduce using rule 113 (empty -> .)
    OR              reduce using rule 113 (empty -> .)
    AND             reduce using rule 113 (empty -> .)
    R_PAR           reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    R_BRACKET       reduce using rule 113 (empty -> .)
    TO              reduce using rule 113 (empty -> .)
    L_BRACE         reduce using rule 113 (empty -> .)

    factorB                        shift and go to state 178
    empty                          shift and go to state 180

state 121

    (102) exponent -> exponentB .

    EXP             reduce using rule 102 (exponent -> exponentB .)
    MULT            reduce using rule 102 (exponent -> exponentB .)
    DIV             reduce using rule 102 (exponent -> exponentB .)
    REMAINDER       reduce using rule 102 (exponent -> exponentB .)
    PLUS            reduce using rule 102 (exponent -> exponentB .)
    MINUS           reduce using rule 102 (exponent -> exponentB .)
    LESS            reduce using rule 102 (exponent -> exponentB .)
    GREATER         reduce using rule 102 (exponent -> exponentB .)
    LESS_EQ         reduce using rule 102 (exponent -> exponentB .)
    GREATER_EQ      reduce using rule 102 (exponent -> exponentB .)
    EQUIVALENT      reduce using rule 102 (exponent -> exponentB .)
    DIFFERENT       reduce using rule 102 (exponent -> exponentB .)
    OR              reduce using rule 102 (exponent -> exponentB .)
    AND             reduce using rule 102 (exponent -> exponentB .)
    R_PAR           reduce using rule 102 (exponent -> exponentB .)
    COMMA           reduce using rule 102 (exponent -> exponentB .)
    SEMICOLON       reduce using rule 102 (exponent -> exponentB .)
    R_BRACKET       reduce using rule 102 (exponent -> exponentB .)
    TO              reduce using rule 102 (exponent -> exponentB .)
    L_BRACE         reduce using rule 102 (exponent -> exponentB .)


state 122

    (103) exponentB -> MINUS . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    var_cte                        shift and go to state 181
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 123

    (104) exponentB -> var_cte .

    EXP             reduce using rule 104 (exponentB -> var_cte .)
    MULT            reduce using rule 104 (exponentB -> var_cte .)
    DIV             reduce using rule 104 (exponentB -> var_cte .)
    REMAINDER       reduce using rule 104 (exponentB -> var_cte .)
    PLUS            reduce using rule 104 (exponentB -> var_cte .)
    MINUS           reduce using rule 104 (exponentB -> var_cte .)
    LESS            reduce using rule 104 (exponentB -> var_cte .)
    GREATER         reduce using rule 104 (exponentB -> var_cte .)
    LESS_EQ         reduce using rule 104 (exponentB -> var_cte .)
    GREATER_EQ      reduce using rule 104 (exponentB -> var_cte .)
    EQUIVALENT      reduce using rule 104 (exponentB -> var_cte .)
    DIFFERENT       reduce using rule 104 (exponentB -> var_cte .)
    OR              reduce using rule 104 (exponentB -> var_cte .)
    AND             reduce using rule 104 (exponentB -> var_cte .)
    R_PAR           reduce using rule 104 (exponentB -> var_cte .)
    COMMA           reduce using rule 104 (exponentB -> var_cte .)
    SEMICOLON       reduce using rule 104 (exponentB -> var_cte .)
    R_BRACKET       reduce using rule 104 (exponentB -> var_cte .)
    TO              reduce using rule 104 (exponentB -> var_cte .)
    L_BRACE         reduce using rule 104 (exponentB -> var_cte .)


state 124

    (105) var_cte -> var .

    EXP             reduce using rule 105 (var_cte -> var .)
    MULT            reduce using rule 105 (var_cte -> var .)
    DIV             reduce using rule 105 (var_cte -> var .)
    REMAINDER       reduce using rule 105 (var_cte -> var .)
    PLUS            reduce using rule 105 (var_cte -> var .)
    MINUS           reduce using rule 105 (var_cte -> var .)
    LESS            reduce using rule 105 (var_cte -> var .)
    GREATER         reduce using rule 105 (var_cte -> var .)
    LESS_EQ         reduce using rule 105 (var_cte -> var .)
    GREATER_EQ      reduce using rule 105 (var_cte -> var .)
    EQUIVALENT      reduce using rule 105 (var_cte -> var .)
    DIFFERENT       reduce using rule 105 (var_cte -> var .)
    OR              reduce using rule 105 (var_cte -> var .)
    AND             reduce using rule 105 (var_cte -> var .)
    R_PAR           reduce using rule 105 (var_cte -> var .)
    COMMA           reduce using rule 105 (var_cte -> var .)
    SEMICOLON       reduce using rule 105 (var_cte -> var .)
    R_BRACKET       reduce using rule 105 (var_cte -> var .)
    TO              reduce using rule 105 (var_cte -> var .)
    L_BRACE         reduce using rule 105 (var_cte -> var .)


state 125

    (106) var_cte -> predef_func .

    EXP             reduce using rule 106 (var_cte -> predef_func .)
    MULT            reduce using rule 106 (var_cte -> predef_func .)
    DIV             reduce using rule 106 (var_cte -> predef_func .)
    REMAINDER       reduce using rule 106 (var_cte -> predef_func .)
    PLUS            reduce using rule 106 (var_cte -> predef_func .)
    MINUS           reduce using rule 106 (var_cte -> predef_func .)
    LESS            reduce using rule 106 (var_cte -> predef_func .)
    GREATER         reduce using rule 106 (var_cte -> predef_func .)
    LESS_EQ         reduce using rule 106 (var_cte -> predef_func .)
    GREATER_EQ      reduce using rule 106 (var_cte -> predef_func .)
    EQUIVALENT      reduce using rule 106 (var_cte -> predef_func .)
    DIFFERENT       reduce using rule 106 (var_cte -> predef_func .)
    OR              reduce using rule 106 (var_cte -> predef_func .)
    AND             reduce using rule 106 (var_cte -> predef_func .)
    R_PAR           reduce using rule 106 (var_cte -> predef_func .)
    COMMA           reduce using rule 106 (var_cte -> predef_func .)
    SEMICOLON       reduce using rule 106 (var_cte -> predef_func .)
    R_BRACKET       reduce using rule 106 (var_cte -> predef_func .)
    TO              reduce using rule 106 (var_cte -> predef_func .)
    L_BRACE         reduce using rule 106 (var_cte -> predef_func .)


state 126

    (107) var_cte -> func_call .

    EXP             reduce using rule 107 (var_cte -> func_call .)
    MULT            reduce using rule 107 (var_cte -> func_call .)
    DIV             reduce using rule 107 (var_cte -> func_call .)
    REMAINDER       reduce using rule 107 (var_cte -> func_call .)
    PLUS            reduce using rule 107 (var_cte -> func_call .)
    MINUS           reduce using rule 107 (var_cte -> func_call .)
    LESS            reduce using rule 107 (var_cte -> func_call .)
    GREATER         reduce using rule 107 (var_cte -> func_call .)
    LESS_EQ         reduce using rule 107 (var_cte -> func_call .)
    GREATER_EQ      reduce using rule 107 (var_cte -> func_call .)
    EQUIVALENT      reduce using rule 107 (var_cte -> func_call .)
    DIFFERENT       reduce using rule 107 (var_cte -> func_call .)
    OR              reduce using rule 107 (var_cte -> func_call .)
    AND             reduce using rule 107 (var_cte -> func_call .)
    R_PAR           reduce using rule 107 (var_cte -> func_call .)
    COMMA           reduce using rule 107 (var_cte -> func_call .)
    SEMICOLON       reduce using rule 107 (var_cte -> func_call .)
    R_BRACKET       reduce using rule 107 (var_cte -> func_call .)
    TO              reduce using rule 107 (var_cte -> func_call .)
    L_BRACE         reduce using rule 107 (var_cte -> func_call .)


state 127

    (108) var_cte -> CTE_INT . np_push_cte_int
    (117) np_push_cte_int -> .

    EXP             reduce using rule 117 (np_push_cte_int -> .)
    MULT            reduce using rule 117 (np_push_cte_int -> .)
    DIV             reduce using rule 117 (np_push_cte_int -> .)
    REMAINDER       reduce using rule 117 (np_push_cte_int -> .)
    PLUS            reduce using rule 117 (np_push_cte_int -> .)
    MINUS           reduce using rule 117 (np_push_cte_int -> .)
    LESS            reduce using rule 117 (np_push_cte_int -> .)
    GREATER         reduce using rule 117 (np_push_cte_int -> .)
    LESS_EQ         reduce using rule 117 (np_push_cte_int -> .)
    GREATER_EQ      reduce using rule 117 (np_push_cte_int -> .)
    EQUIVALENT      reduce using rule 117 (np_push_cte_int -> .)
    DIFFERENT       reduce using rule 117 (np_push_cte_int -> .)
    OR              reduce using rule 117 (np_push_cte_int -> .)
    AND             reduce using rule 117 (np_push_cte_int -> .)
    R_PAR           reduce using rule 117 (np_push_cte_int -> .)
    COMMA           reduce using rule 117 (np_push_cte_int -> .)
    SEMICOLON       reduce using rule 117 (np_push_cte_int -> .)
    R_BRACKET       reduce using rule 117 (np_push_cte_int -> .)
    TO              reduce using rule 117 (np_push_cte_int -> .)
    L_BRACE         reduce using rule 117 (np_push_cte_int -> .)

    np_push_cte_int                shift and go to state 182

state 128

    (109) var_cte -> CTE_FLOAT . np_push_cte_float
    (118) np_push_cte_float -> .

    EXP             reduce using rule 118 (np_push_cte_float -> .)
    MULT            reduce using rule 118 (np_push_cte_float -> .)
    DIV             reduce using rule 118 (np_push_cte_float -> .)
    REMAINDER       reduce using rule 118 (np_push_cte_float -> .)
    PLUS            reduce using rule 118 (np_push_cte_float -> .)
    MINUS           reduce using rule 118 (np_push_cte_float -> .)
    LESS            reduce using rule 118 (np_push_cte_float -> .)
    GREATER         reduce using rule 118 (np_push_cte_float -> .)
    LESS_EQ         reduce using rule 118 (np_push_cte_float -> .)
    GREATER_EQ      reduce using rule 118 (np_push_cte_float -> .)
    EQUIVALENT      reduce using rule 118 (np_push_cte_float -> .)
    DIFFERENT       reduce using rule 118 (np_push_cte_float -> .)
    OR              reduce using rule 118 (np_push_cte_float -> .)
    AND             reduce using rule 118 (np_push_cte_float -> .)
    R_PAR           reduce using rule 118 (np_push_cte_float -> .)
    COMMA           reduce using rule 118 (np_push_cte_float -> .)
    SEMICOLON       reduce using rule 118 (np_push_cte_float -> .)
    R_BRACKET       reduce using rule 118 (np_push_cte_float -> .)
    TO              reduce using rule 118 (np_push_cte_float -> .)
    L_BRACE         reduce using rule 118 (np_push_cte_float -> .)

    np_push_cte_float              shift and go to state 183

state 129

    (110) var_cte -> CTE_CHAR . np_push_cte_char
    (119) np_push_cte_char -> .

    EXP             reduce using rule 119 (np_push_cte_char -> .)
    MULT            reduce using rule 119 (np_push_cte_char -> .)
    DIV             reduce using rule 119 (np_push_cte_char -> .)
    REMAINDER       reduce using rule 119 (np_push_cte_char -> .)
    PLUS            reduce using rule 119 (np_push_cte_char -> .)
    MINUS           reduce using rule 119 (np_push_cte_char -> .)
    LESS            reduce using rule 119 (np_push_cte_char -> .)
    GREATER         reduce using rule 119 (np_push_cte_char -> .)
    LESS_EQ         reduce using rule 119 (np_push_cte_char -> .)
    GREATER_EQ      reduce using rule 119 (np_push_cte_char -> .)
    EQUIVALENT      reduce using rule 119 (np_push_cte_char -> .)
    DIFFERENT       reduce using rule 119 (np_push_cte_char -> .)
    OR              reduce using rule 119 (np_push_cte_char -> .)
    AND             reduce using rule 119 (np_push_cte_char -> .)
    R_PAR           reduce using rule 119 (np_push_cte_char -> .)
    COMMA           reduce using rule 119 (np_push_cte_char -> .)
    SEMICOLON       reduce using rule 119 (np_push_cte_char -> .)
    R_BRACKET       reduce using rule 119 (np_push_cte_char -> .)
    TO              reduce using rule 119 (np_push_cte_char -> .)
    L_BRACE         reduce using rule 119 (np_push_cte_char -> .)

    np_push_cte_char               shift and go to state 184

state 130

    (111) var_cte -> CTE_STRING . np_push_cte_str
    (120) np_push_cte_str -> .

    EXP             reduce using rule 120 (np_push_cte_str -> .)
    MULT            reduce using rule 120 (np_push_cte_str -> .)
    DIV             reduce using rule 120 (np_push_cte_str -> .)
    REMAINDER       reduce using rule 120 (np_push_cte_str -> .)
    PLUS            reduce using rule 120 (np_push_cte_str -> .)
    MINUS           reduce using rule 120 (np_push_cte_str -> .)
    LESS            reduce using rule 120 (np_push_cte_str -> .)
    GREATER         reduce using rule 120 (np_push_cte_str -> .)
    LESS_EQ         reduce using rule 120 (np_push_cte_str -> .)
    GREATER_EQ      reduce using rule 120 (np_push_cte_str -> .)
    EQUIVALENT      reduce using rule 120 (np_push_cte_str -> .)
    DIFFERENT       reduce using rule 120 (np_push_cte_str -> .)
    OR              reduce using rule 120 (np_push_cte_str -> .)
    AND             reduce using rule 120 (np_push_cte_str -> .)
    R_PAR           reduce using rule 120 (np_push_cte_str -> .)
    SEMICOLON       reduce using rule 120 (np_push_cte_str -> .)
    COMMA           reduce using rule 120 (np_push_cte_str -> .)
    R_BRACKET       reduce using rule 120 (np_push_cte_str -> .)
    TO              reduce using rule 120 (np_push_cte_str -> .)
    L_BRACE         reduce using rule 120 (np_push_cte_str -> .)

    np_push_cte_str                shift and go to state 185

state 131

    (112) var_cte -> CTE_BOOL . np_push_cte_bool
    (121) np_push_cte_bool -> .

    EXP             reduce using rule 121 (np_push_cte_bool -> .)
    MULT            reduce using rule 121 (np_push_cte_bool -> .)
    DIV             reduce using rule 121 (np_push_cte_bool -> .)
    REMAINDER       reduce using rule 121 (np_push_cte_bool -> .)
    PLUS            reduce using rule 121 (np_push_cte_bool -> .)
    MINUS           reduce using rule 121 (np_push_cte_bool -> .)
    LESS            reduce using rule 121 (np_push_cte_bool -> .)
    GREATER         reduce using rule 121 (np_push_cte_bool -> .)
    LESS_EQ         reduce using rule 121 (np_push_cte_bool -> .)
    GREATER_EQ      reduce using rule 121 (np_push_cte_bool -> .)
    EQUIVALENT      reduce using rule 121 (np_push_cte_bool -> .)
    DIFFERENT       reduce using rule 121 (np_push_cte_bool -> .)
    OR              reduce using rule 121 (np_push_cte_bool -> .)
    AND             reduce using rule 121 (np_push_cte_bool -> .)
    R_PAR           reduce using rule 121 (np_push_cte_bool -> .)
    COMMA           reduce using rule 121 (np_push_cte_bool -> .)
    SEMICOLON       reduce using rule 121 (np_push_cte_bool -> .)
    R_BRACKET       reduce using rule 121 (np_push_cte_bool -> .)
    TO              reduce using rule 121 (np_push_cte_bool -> .)
    L_BRACE         reduce using rule 121 (np_push_cte_bool -> .)

    np_push_cte_bool               shift and go to state 186

state 132

    (45) predef_func -> MIN . L_PAR vector R_PAR

    L_PAR           shift and go to state 187


state 133

    (46) predef_func -> MAX . L_PAR vector R_PAR

    L_PAR           shift and go to state 188


state 134

    (47) predef_func -> MEAN . L_PAR vector R_PAR

    L_PAR           shift and go to state 189


state 135

    (48) predef_func -> MEDIAN . L_PAR vector R_PAR

    L_PAR           shift and go to state 190


state 136

    (49) predef_func -> MODE . L_PAR vector R_PAR

    L_PAR           shift and go to state 191


state 137

    (50) predef_func -> PLOT_XY . L_PAR vector COMMA vector R_PAR

    L_PAR           shift and go to state 192


state 138

    (51) predef_func -> REGRESSION . L_PAR vector COMMA vector R_PAR

    L_PAR           shift and go to state 193


state 139

    (52) predef_func -> VARIANCE . L_PAR vector R_PAR

    L_PAR           shift and go to state 194


state 140

    (53) predef_func -> SUM . L_PAR vector R_PAR

    L_PAR           shift and go to state 195


state 141

    (57) read -> READ L_PAR read2 . R_PAR SEMICOLON

    R_PAR           shift and go to state 196


state 142

    (58) read2 -> var . np_read
    (59) read2 -> var . np_read COMMA read2
    (129) np_read -> .

    COMMA           reduce using rule 129 (np_read -> .)
    R_PAR           reduce using rule 129 (np_read -> .)

    np_read                        shift and go to state 197

state 143

    (60) write -> WRITE L_PAR writeB . R_PAR SEMICOLON

    R_PAR           shift and go to state 198


state 144

    (61) writeB -> expression . np_end np_write writeC
    (128) np_end -> .

    COMMA           reduce using rule 128 (np_end -> .)
    R_PAR           reduce using rule 128 (np_end -> .)

    np_end                         shift and go to state 199

state 145

    (62) writeB -> CTE_STRING . np_push_cte_str np_write writeC
    (111) var_cte -> CTE_STRING . np_push_cte_str
    (120) np_push_cte_str -> .

    COMMA           reduce using rule 120 (np_push_cte_str -> .)
    R_PAR           reduce using rule 120 (np_push_cte_str -> .)
    EXP             reduce using rule 120 (np_push_cte_str -> .)
    MULT            reduce using rule 120 (np_push_cte_str -> .)
    DIV             reduce using rule 120 (np_push_cte_str -> .)
    REMAINDER       reduce using rule 120 (np_push_cte_str -> .)
    PLUS            reduce using rule 120 (np_push_cte_str -> .)
    MINUS           reduce using rule 120 (np_push_cte_str -> .)
    LESS            reduce using rule 120 (np_push_cte_str -> .)
    GREATER         reduce using rule 120 (np_push_cte_str -> .)
    LESS_EQ         reduce using rule 120 (np_push_cte_str -> .)
    GREATER_EQ      reduce using rule 120 (np_push_cte_str -> .)
    EQUIVALENT      reduce using rule 120 (np_push_cte_str -> .)
    DIFFERENT       reduce using rule 120 (np_push_cte_str -> .)
    OR              reduce using rule 120 (np_push_cte_str -> .)
    AND             reduce using rule 120 (np_push_cte_str -> .)

    np_push_cte_str                shift and go to state 200

state 146

    (65) loop_cond -> WHILE L_PAR np_CHECKPOINT . expression R_PAR np_end np_GOTOF block np_GOTO_WHILE
    (72) expression -> . logic expressionB
    (81) logic -> . exp logic2
    (89) exp -> . term exp2
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    expression                     shift and go to state 201
    logic                          shift and go to state 116
    exp                            shift and go to state 117
    term                           shift and go to state 118
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 147

    (66) loop_range -> FOR var EQUAL . np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR
    (115) np_push_operator -> .

    L_PAR           reduce using rule 115 (np_push_operator -> .)
    MINUS           reduce using rule 115 (np_push_operator -> .)
    CTE_INT         reduce using rule 115 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 115 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 115 (np_push_operator -> .)
    CTE_STRING      reduce using rule 115 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 115 (np_push_operator -> .)
    ID              reduce using rule 115 (np_push_operator -> .)
    MIN             reduce using rule 115 (np_push_operator -> .)
    MAX             reduce using rule 115 (np_push_operator -> .)
    MEAN            reduce using rule 115 (np_push_operator -> .)
    MEDIAN          reduce using rule 115 (np_push_operator -> .)
    MODE            reduce using rule 115 (np_push_operator -> .)
    PLOT_XY         reduce using rule 115 (np_push_operator -> .)
    REGRESSION      reduce using rule 115 (np_push_operator -> .)
    VARIANCE        reduce using rule 115 (np_push_operator -> .)
    SUM             reduce using rule 115 (np_push_operator -> .)

    np_push_operator               shift and go to state 202

state 148

    (67) return -> RETURN L_PAR np_stop . exp np_end np_set_return R_PAR SEMICOLON
    (89) exp -> . term exp2
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    exp                            shift and go to state 203
    term                           shift and go to state 118
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 149

    (20) var -> ID L_BRACKET np_arr_start . exp np_end np_arr_end R_BRACKET
    (89) exp -> . term exp2
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    exp                            shift and go to state 204
    term                           shift and go to state 118
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 150

    (68) func_call -> ID np_ERA L_PAR . func_call_arguments R_PAR np_GOSUB
    (69) func_call_arguments -> . np_stop exp np_end np_param
    (70) func_call_arguments -> . np_stop exp np_end np_param COMMA func_call_arguments
    (71) func_call_arguments -> . empty
    (148) np_stop -> .
    (113) empty -> .

    L_PAR           reduce using rule 148 (np_stop -> .)
    MINUS           reduce using rule 148 (np_stop -> .)
    CTE_INT         reduce using rule 148 (np_stop -> .)
    CTE_FLOAT       reduce using rule 148 (np_stop -> .)
    CTE_CHAR        reduce using rule 148 (np_stop -> .)
    CTE_STRING      reduce using rule 148 (np_stop -> .)
    CTE_BOOL        reduce using rule 148 (np_stop -> .)
    ID              reduce using rule 148 (np_stop -> .)
    MIN             reduce using rule 148 (np_stop -> .)
    MAX             reduce using rule 148 (np_stop -> .)
    MEAN            reduce using rule 148 (np_stop -> .)
    MEDIAN          reduce using rule 148 (np_stop -> .)
    MODE            reduce using rule 148 (np_stop -> .)
    PLOT_XY         reduce using rule 148 (np_stop -> .)
    REGRESSION      reduce using rule 148 (np_stop -> .)
    VARIANCE        reduce using rule 148 (np_stop -> .)
    SUM             reduce using rule 148 (np_stop -> .)
    R_PAR           reduce using rule 113 (empty -> .)

    func_call_arguments            shift and go to state 205
    np_stop                        shift and go to state 206
    empty                          shift and go to state 207

state 151

    (12) varsD -> ID L_BRACKET CTE_INT R_BRACKET np_add_arr .

    COMMA           reduce using rule 12 (varsD -> ID L_BRACKET CTE_INT R_BRACKET np_add_arr .)
    SEMICOLON       reduce using rule 12 (varsD -> ID L_BRACKET CTE_INT R_BRACKET np_add_arr .)


state 152

    (13) function -> FUNCTION func_type ID np_set_curr_proc L_PAR params R_PAR np_set_quad_start vblock np_ENDFunc .

    FUNCTION        reduce using rule 13 (function -> FUNCTION func_type ID np_set_curr_proc L_PAR params R_PAR np_set_quad_start vblock np_ENDFunc .)
    MAIN            reduce using rule 13 (function -> FUNCTION func_type ID np_set_curr_proc L_PAR params R_PAR np_set_quad_start vblock np_ENDFunc .)


state 153

    (33) params -> type COLON ID np_add_param COMMA . params
    (32) params -> . type COLON ID np_add_param
    (33) params -> . type COLON ID np_add_param COMMA params
    (34) params -> . empty
    (15) type -> . INT np_add_datatype
    (16) type -> . FLOAT np_add_datatype
    (17) type -> . BOOL np_add_datatype
    (18) type -> . CHAR np_add_datatype
    (19) type -> . STRING np_add_datatype
    (113) empty -> .

    INT             shift and go to state 22
    FLOAT           shift and go to state 23
    BOOL            shift and go to state 24
    CHAR            shift and go to state 25
    STRING          shift and go to state 26
    R_PAR           reduce using rule 113 (empty -> .)

    type                           shift and go to state 49
    params                         shift and go to state 208
    empty                          shift and go to state 50

state 154

    (44) assign -> var oper_assign np_push_operator expression . np_end SEMICOLON
    (128) np_end -> .

    SEMICOLON       reduce using rule 128 (np_end -> .)

    np_end                         shift and go to state 209

state 155

    (101) exponent -> L_PAR np_push_operator . expression R_PAR np_rpar
    (72) expression -> . logic expressionB
    (81) logic -> . exp logic2
    (89) exp -> . term exp2
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    expression                     shift and go to state 210
    logic                          shift and go to state 116
    exp                            shift and go to state 117
    term                           shift and go to state 118
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 156

    (54) condicional -> IF L_PAR expression np_end . np_GOTOF R_PAR block cond2 np_GOTO_END
    (134) np_GOTOF -> .

    R_PAR           reduce using rule 134 (np_GOTOF -> .)

    np_GOTOF                       shift and go to state 211

state 157

    (72) expression -> logic expressionB .

    R_PAR           reduce using rule 72 (expression -> logic expressionB .)
    COMMA           reduce using rule 72 (expression -> logic expressionB .)
    SEMICOLON       reduce using rule 72 (expression -> logic expressionB .)


state 158

    (73) expressionB -> OR . np_push_operator expression
    (115) np_push_operator -> .

    L_PAR           reduce using rule 115 (np_push_operator -> .)
    MINUS           reduce using rule 115 (np_push_operator -> .)
    CTE_INT         reduce using rule 115 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 115 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 115 (np_push_operator -> .)
    CTE_STRING      reduce using rule 115 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 115 (np_push_operator -> .)
    ID              reduce using rule 115 (np_push_operator -> .)
    MIN             reduce using rule 115 (np_push_operator -> .)
    MAX             reduce using rule 115 (np_push_operator -> .)
    MEAN            reduce using rule 115 (np_push_operator -> .)
    MEDIAN          reduce using rule 115 (np_push_operator -> .)
    MODE            reduce using rule 115 (np_push_operator -> .)
    PLOT_XY         reduce using rule 115 (np_push_operator -> .)
    REGRESSION      reduce using rule 115 (np_push_operator -> .)
    VARIANCE        reduce using rule 115 (np_push_operator -> .)
    SUM             reduce using rule 115 (np_push_operator -> .)

    np_push_operator               shift and go to state 212

state 159

    (74) expressionB -> AND . np_push_operator expression
    (115) np_push_operator -> .

    L_PAR           reduce using rule 115 (np_push_operator -> .)
    MINUS           reduce using rule 115 (np_push_operator -> .)
    CTE_INT         reduce using rule 115 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 115 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 115 (np_push_operator -> .)
    CTE_STRING      reduce using rule 115 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 115 (np_push_operator -> .)
    ID              reduce using rule 115 (np_push_operator -> .)
    MIN             reduce using rule 115 (np_push_operator -> .)
    MAX             reduce using rule 115 (np_push_operator -> .)
    MEAN            reduce using rule 115 (np_push_operator -> .)
    MEDIAN          reduce using rule 115 (np_push_operator -> .)
    MODE            reduce using rule 115 (np_push_operator -> .)
    PLOT_XY         reduce using rule 115 (np_push_operator -> .)
    REGRESSION      reduce using rule 115 (np_push_operator -> .)
    VARIANCE        reduce using rule 115 (np_push_operator -> .)
    SUM             reduce using rule 115 (np_push_operator -> .)

    np_push_operator               shift and go to state 213

state 160

    (75) expressionB -> empty .

    R_PAR           reduce using rule 75 (expressionB -> empty .)
    COMMA           reduce using rule 75 (expressionB -> empty .)
    SEMICOLON       reduce using rule 75 (expressionB -> empty .)


state 161

    (81) logic -> exp logic2 .

    OR              reduce using rule 81 (logic -> exp logic2 .)
    AND             reduce using rule 81 (logic -> exp logic2 .)
    R_PAR           reduce using rule 81 (logic -> exp logic2 .)
    COMMA           reduce using rule 81 (logic -> exp logic2 .)
    SEMICOLON       reduce using rule 81 (logic -> exp logic2 .)


state 162

    (82) logic2 -> LESS . np_push_operator exp
    (115) np_push_operator -> .

    L_PAR           reduce using rule 115 (np_push_operator -> .)
    MINUS           reduce using rule 115 (np_push_operator -> .)
    CTE_INT         reduce using rule 115 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 115 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 115 (np_push_operator -> .)
    CTE_STRING      reduce using rule 115 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 115 (np_push_operator -> .)
    ID              reduce using rule 115 (np_push_operator -> .)
    MIN             reduce using rule 115 (np_push_operator -> .)
    MAX             reduce using rule 115 (np_push_operator -> .)
    MEAN            reduce using rule 115 (np_push_operator -> .)
    MEDIAN          reduce using rule 115 (np_push_operator -> .)
    MODE            reduce using rule 115 (np_push_operator -> .)
    PLOT_XY         reduce using rule 115 (np_push_operator -> .)
    REGRESSION      reduce using rule 115 (np_push_operator -> .)
    VARIANCE        reduce using rule 115 (np_push_operator -> .)
    SUM             reduce using rule 115 (np_push_operator -> .)

    np_push_operator               shift and go to state 214

state 163

    (83) logic2 -> GREATER . np_push_operator exp
    (115) np_push_operator -> .

    L_PAR           reduce using rule 115 (np_push_operator -> .)
    MINUS           reduce using rule 115 (np_push_operator -> .)
    CTE_INT         reduce using rule 115 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 115 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 115 (np_push_operator -> .)
    CTE_STRING      reduce using rule 115 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 115 (np_push_operator -> .)
    ID              reduce using rule 115 (np_push_operator -> .)
    MIN             reduce using rule 115 (np_push_operator -> .)
    MAX             reduce using rule 115 (np_push_operator -> .)
    MEAN            reduce using rule 115 (np_push_operator -> .)
    MEDIAN          reduce using rule 115 (np_push_operator -> .)
    MODE            reduce using rule 115 (np_push_operator -> .)
    PLOT_XY         reduce using rule 115 (np_push_operator -> .)
    REGRESSION      reduce using rule 115 (np_push_operator -> .)
    VARIANCE        reduce using rule 115 (np_push_operator -> .)
    SUM             reduce using rule 115 (np_push_operator -> .)

    np_push_operator               shift and go to state 215

state 164

    (84) logic2 -> LESS_EQ . np_push_operator exp
    (115) np_push_operator -> .

    L_PAR           reduce using rule 115 (np_push_operator -> .)
    MINUS           reduce using rule 115 (np_push_operator -> .)
    CTE_INT         reduce using rule 115 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 115 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 115 (np_push_operator -> .)
    CTE_STRING      reduce using rule 115 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 115 (np_push_operator -> .)
    ID              reduce using rule 115 (np_push_operator -> .)
    MIN             reduce using rule 115 (np_push_operator -> .)
    MAX             reduce using rule 115 (np_push_operator -> .)
    MEAN            reduce using rule 115 (np_push_operator -> .)
    MEDIAN          reduce using rule 115 (np_push_operator -> .)
    MODE            reduce using rule 115 (np_push_operator -> .)
    PLOT_XY         reduce using rule 115 (np_push_operator -> .)
    REGRESSION      reduce using rule 115 (np_push_operator -> .)
    VARIANCE        reduce using rule 115 (np_push_operator -> .)
    SUM             reduce using rule 115 (np_push_operator -> .)

    np_push_operator               shift and go to state 216

state 165

    (85) logic2 -> GREATER_EQ . np_push_operator exp
    (115) np_push_operator -> .

    L_PAR           reduce using rule 115 (np_push_operator -> .)
    MINUS           reduce using rule 115 (np_push_operator -> .)
    CTE_INT         reduce using rule 115 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 115 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 115 (np_push_operator -> .)
    CTE_STRING      reduce using rule 115 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 115 (np_push_operator -> .)
    ID              reduce using rule 115 (np_push_operator -> .)
    MIN             reduce using rule 115 (np_push_operator -> .)
    MAX             reduce using rule 115 (np_push_operator -> .)
    MEAN            reduce using rule 115 (np_push_operator -> .)
    MEDIAN          reduce using rule 115 (np_push_operator -> .)
    MODE            reduce using rule 115 (np_push_operator -> .)
    PLOT_XY         reduce using rule 115 (np_push_operator -> .)
    REGRESSION      reduce using rule 115 (np_push_operator -> .)
    VARIANCE        reduce using rule 115 (np_push_operator -> .)
    SUM             reduce using rule 115 (np_push_operator -> .)

    np_push_operator               shift and go to state 217

state 166

    (86) logic2 -> EQUIVALENT . np_push_operator exp
    (115) np_push_operator -> .

    L_PAR           reduce using rule 115 (np_push_operator -> .)
    MINUS           reduce using rule 115 (np_push_operator -> .)
    CTE_INT         reduce using rule 115 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 115 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 115 (np_push_operator -> .)
    CTE_STRING      reduce using rule 115 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 115 (np_push_operator -> .)
    ID              reduce using rule 115 (np_push_operator -> .)
    MIN             reduce using rule 115 (np_push_operator -> .)
    MAX             reduce using rule 115 (np_push_operator -> .)
    MEAN            reduce using rule 115 (np_push_operator -> .)
    MEDIAN          reduce using rule 115 (np_push_operator -> .)
    MODE            reduce using rule 115 (np_push_operator -> .)
    PLOT_XY         reduce using rule 115 (np_push_operator -> .)
    REGRESSION      reduce using rule 115 (np_push_operator -> .)
    VARIANCE        reduce using rule 115 (np_push_operator -> .)
    SUM             reduce using rule 115 (np_push_operator -> .)

    np_push_operator               shift and go to state 218

state 167

    (87) logic2 -> DIFFERENT . np_push_operator exp
    (115) np_push_operator -> .

    L_PAR           reduce using rule 115 (np_push_operator -> .)
    MINUS           reduce using rule 115 (np_push_operator -> .)
    CTE_INT         reduce using rule 115 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 115 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 115 (np_push_operator -> .)
    CTE_STRING      reduce using rule 115 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 115 (np_push_operator -> .)
    ID              reduce using rule 115 (np_push_operator -> .)
    MIN             reduce using rule 115 (np_push_operator -> .)
    MAX             reduce using rule 115 (np_push_operator -> .)
    MEAN            reduce using rule 115 (np_push_operator -> .)
    MEDIAN          reduce using rule 115 (np_push_operator -> .)
    MODE            reduce using rule 115 (np_push_operator -> .)
    PLOT_XY         reduce using rule 115 (np_push_operator -> .)
    REGRESSION      reduce using rule 115 (np_push_operator -> .)
    VARIANCE        reduce using rule 115 (np_push_operator -> .)
    SUM             reduce using rule 115 (np_push_operator -> .)

    np_push_operator               shift and go to state 219

state 168

    (88) logic2 -> empty .

    OR              reduce using rule 88 (logic2 -> empty .)
    AND             reduce using rule 88 (logic2 -> empty .)
    R_PAR           reduce using rule 88 (logic2 -> empty .)
    COMMA           reduce using rule 88 (logic2 -> empty .)
    SEMICOLON       reduce using rule 88 (logic2 -> empty .)


state 169

    (89) exp -> term exp2 .

    LESS            reduce using rule 89 (exp -> term exp2 .)
    GREATER         reduce using rule 89 (exp -> term exp2 .)
    LESS_EQ         reduce using rule 89 (exp -> term exp2 .)
    GREATER_EQ      reduce using rule 89 (exp -> term exp2 .)
    EQUIVALENT      reduce using rule 89 (exp -> term exp2 .)
    DIFFERENT       reduce using rule 89 (exp -> term exp2 .)
    OR              reduce using rule 89 (exp -> term exp2 .)
    AND             reduce using rule 89 (exp -> term exp2 .)
    R_PAR           reduce using rule 89 (exp -> term exp2 .)
    COMMA           reduce using rule 89 (exp -> term exp2 .)
    SEMICOLON       reduce using rule 89 (exp -> term exp2 .)
    R_BRACKET       reduce using rule 89 (exp -> term exp2 .)
    TO              reduce using rule 89 (exp -> term exp2 .)
    L_BRACE         reduce using rule 89 (exp -> term exp2 .)


state 170

    (90) exp2 -> PLUS . np_push_operator exp
    (115) np_push_operator -> .

    L_PAR           reduce using rule 115 (np_push_operator -> .)
    MINUS           reduce using rule 115 (np_push_operator -> .)
    CTE_INT         reduce using rule 115 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 115 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 115 (np_push_operator -> .)
    CTE_STRING      reduce using rule 115 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 115 (np_push_operator -> .)
    ID              reduce using rule 115 (np_push_operator -> .)
    MIN             reduce using rule 115 (np_push_operator -> .)
    MAX             reduce using rule 115 (np_push_operator -> .)
    MEAN            reduce using rule 115 (np_push_operator -> .)
    MEDIAN          reduce using rule 115 (np_push_operator -> .)
    MODE            reduce using rule 115 (np_push_operator -> .)
    PLOT_XY         reduce using rule 115 (np_push_operator -> .)
    REGRESSION      reduce using rule 115 (np_push_operator -> .)
    VARIANCE        reduce using rule 115 (np_push_operator -> .)
    SUM             reduce using rule 115 (np_push_operator -> .)

    np_push_operator               shift and go to state 220

state 171

    (91) exp2 -> MINUS . np_push_operator exp
    (115) np_push_operator -> .

    L_PAR           reduce using rule 115 (np_push_operator -> .)
    MINUS           reduce using rule 115 (np_push_operator -> .)
    CTE_INT         reduce using rule 115 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 115 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 115 (np_push_operator -> .)
    CTE_STRING      reduce using rule 115 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 115 (np_push_operator -> .)
    ID              reduce using rule 115 (np_push_operator -> .)
    MIN             reduce using rule 115 (np_push_operator -> .)
    MAX             reduce using rule 115 (np_push_operator -> .)
    MEAN            reduce using rule 115 (np_push_operator -> .)
    MEDIAN          reduce using rule 115 (np_push_operator -> .)
    MODE            reduce using rule 115 (np_push_operator -> .)
    PLOT_XY         reduce using rule 115 (np_push_operator -> .)
    REGRESSION      reduce using rule 115 (np_push_operator -> .)
    VARIANCE        reduce using rule 115 (np_push_operator -> .)
    SUM             reduce using rule 115 (np_push_operator -> .)

    np_push_operator               shift and go to state 221

state 172

    (92) exp2 -> empty .

    LESS            reduce using rule 92 (exp2 -> empty .)
    GREATER         reduce using rule 92 (exp2 -> empty .)
    LESS_EQ         reduce using rule 92 (exp2 -> empty .)
    GREATER_EQ      reduce using rule 92 (exp2 -> empty .)
    EQUIVALENT      reduce using rule 92 (exp2 -> empty .)
    DIFFERENT       reduce using rule 92 (exp2 -> empty .)
    OR              reduce using rule 92 (exp2 -> empty .)
    AND             reduce using rule 92 (exp2 -> empty .)
    R_PAR           reduce using rule 92 (exp2 -> empty .)
    COMMA           reduce using rule 92 (exp2 -> empty .)
    SEMICOLON       reduce using rule 92 (exp2 -> empty .)
    R_BRACKET       reduce using rule 92 (exp2 -> empty .)
    TO              reduce using rule 92 (exp2 -> empty .)
    L_BRACE         reduce using rule 92 (exp2 -> empty .)


state 173

    (93) term -> factor term2 .

    PLUS            reduce using rule 93 (term -> factor term2 .)
    MINUS           reduce using rule 93 (term -> factor term2 .)
    LESS            reduce using rule 93 (term -> factor term2 .)
    GREATER         reduce using rule 93 (term -> factor term2 .)
    LESS_EQ         reduce using rule 93 (term -> factor term2 .)
    GREATER_EQ      reduce using rule 93 (term -> factor term2 .)
    EQUIVALENT      reduce using rule 93 (term -> factor term2 .)
    DIFFERENT       reduce using rule 93 (term -> factor term2 .)
    OR              reduce using rule 93 (term -> factor term2 .)
    AND             reduce using rule 93 (term -> factor term2 .)
    R_PAR           reduce using rule 93 (term -> factor term2 .)
    COMMA           reduce using rule 93 (term -> factor term2 .)
    SEMICOLON       reduce using rule 93 (term -> factor term2 .)
    R_BRACKET       reduce using rule 93 (term -> factor term2 .)
    TO              reduce using rule 93 (term -> factor term2 .)
    L_BRACE         reduce using rule 93 (term -> factor term2 .)


state 174

    (94) term2 -> MULT . np_push_operator term
    (115) np_push_operator -> .

    L_PAR           reduce using rule 115 (np_push_operator -> .)
    MINUS           reduce using rule 115 (np_push_operator -> .)
    CTE_INT         reduce using rule 115 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 115 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 115 (np_push_operator -> .)
    CTE_STRING      reduce using rule 115 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 115 (np_push_operator -> .)
    ID              reduce using rule 115 (np_push_operator -> .)
    MIN             reduce using rule 115 (np_push_operator -> .)
    MAX             reduce using rule 115 (np_push_operator -> .)
    MEAN            reduce using rule 115 (np_push_operator -> .)
    MEDIAN          reduce using rule 115 (np_push_operator -> .)
    MODE            reduce using rule 115 (np_push_operator -> .)
    PLOT_XY         reduce using rule 115 (np_push_operator -> .)
    REGRESSION      reduce using rule 115 (np_push_operator -> .)
    VARIANCE        reduce using rule 115 (np_push_operator -> .)
    SUM             reduce using rule 115 (np_push_operator -> .)

    np_push_operator               shift and go to state 222

state 175

    (95) term2 -> DIV . np_push_operator term
    (115) np_push_operator -> .

    L_PAR           reduce using rule 115 (np_push_operator -> .)
    MINUS           reduce using rule 115 (np_push_operator -> .)
    CTE_INT         reduce using rule 115 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 115 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 115 (np_push_operator -> .)
    CTE_STRING      reduce using rule 115 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 115 (np_push_operator -> .)
    ID              reduce using rule 115 (np_push_operator -> .)
    MIN             reduce using rule 115 (np_push_operator -> .)
    MAX             reduce using rule 115 (np_push_operator -> .)
    MEAN            reduce using rule 115 (np_push_operator -> .)
    MEDIAN          reduce using rule 115 (np_push_operator -> .)
    MODE            reduce using rule 115 (np_push_operator -> .)
    PLOT_XY         reduce using rule 115 (np_push_operator -> .)
    REGRESSION      reduce using rule 115 (np_push_operator -> .)
    VARIANCE        reduce using rule 115 (np_push_operator -> .)
    SUM             reduce using rule 115 (np_push_operator -> .)

    np_push_operator               shift and go to state 223

state 176

    (96) term2 -> REMAINDER . np_push_operator term
    (115) np_push_operator -> .

    L_PAR           reduce using rule 115 (np_push_operator -> .)
    MINUS           reduce using rule 115 (np_push_operator -> .)
    CTE_INT         reduce using rule 115 (np_push_operator -> .)
    CTE_FLOAT       reduce using rule 115 (np_push_operator -> .)
    CTE_CHAR        reduce using rule 115 (np_push_operator -> .)
    CTE_STRING      reduce using rule 115 (np_push_operator -> .)
    CTE_BOOL        reduce using rule 115 (np_push_operator -> .)
    ID              reduce using rule 115 (np_push_operator -> .)
    MIN             reduce using rule 115 (np_push_operator -> .)
    MAX             reduce using rule 115 (np_push_operator -> .)
    MEAN            reduce using rule 115 (np_push_operator -> .)
    MEDIAN          reduce using rule 115 (np_push_operator -> .)
    MODE            reduce using rule 115 (np_push_operator -> .)
    PLOT_XY         reduce using rule 115 (np_push_operator -> .)
    REGRESSION      reduce using rule 115 (np_push_operator -> .)
    VARIANCE        reduce using rule 115 (np_push_operator -> .)
    SUM             reduce using rule 115 (np_push_operator -> .)

    np_push_operator               shift and go to state 224

state 177

    (97) term2 -> empty .

    PLUS            reduce using rule 97 (term2 -> empty .)
    MINUS           reduce using rule 97 (term2 -> empty .)
    LESS            reduce using rule 97 (term2 -> empty .)
    GREATER         reduce using rule 97 (term2 -> empty .)
    LESS_EQ         reduce using rule 97 (term2 -> empty .)
    GREATER_EQ      reduce using rule 97 (term2 -> empty .)
    EQUIVALENT      reduce using rule 97 (term2 -> empty .)
    DIFFERENT       reduce using rule 97 (term2 -> empty .)
    OR              reduce using rule 97 (term2 -> empty .)
    AND             reduce using rule 97 (term2 -> empty .)
    R_PAR           reduce using rule 97 (term2 -> empty .)
    COMMA           reduce using rule 97 (term2 -> empty .)
    SEMICOLON       reduce using rule 97 (term2 -> empty .)
    R_BRACKET       reduce using rule 97 (term2 -> empty .)
    TO              reduce using rule 97 (term2 -> empty .)
    L_BRACE         reduce using rule 97 (term2 -> empty .)


state 178

    (98) factor -> exponent factorB .

    MULT            reduce using rule 98 (factor -> exponent factorB .)
    DIV             reduce using rule 98 (factor -> exponent factorB .)
    REMAINDER       reduce using rule 98 (factor -> exponent factorB .)
    PLUS            reduce using rule 98 (factor -> exponent factorB .)
    MINUS           reduce using rule 98 (factor -> exponent factorB .)
    LESS            reduce using rule 98 (factor -> exponent factorB .)
    GREATER         reduce using rule 98 (factor -> exponent factorB .)
    LESS_EQ         reduce using rule 98 (factor -> exponent factorB .)
    GREATER_EQ      reduce using rule 98 (factor -> exponent factorB .)
    EQUIVALENT      reduce using rule 98 (factor -> exponent factorB .)
    DIFFERENT       reduce using rule 98 (factor -> exponent factorB .)
    OR              reduce using rule 98 (factor -> exponent factorB .)
    AND             reduce using rule 98 (factor -> exponent factorB .)
    R_PAR           reduce using rule 98 (factor -> exponent factorB .)
    COMMA           reduce using rule 98 (factor -> exponent factorB .)
    SEMICOLON       reduce using rule 98 (factor -> exponent factorB .)
    R_BRACKET       reduce using rule 98 (factor -> exponent factorB .)
    TO              reduce using rule 98 (factor -> exponent factorB .)
    L_BRACE         reduce using rule 98 (factor -> exponent factorB .)


state 179

    (99) factorB -> EXP . factor
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    factor                         shift and go to state 225
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 180

    (100) factorB -> empty .

    MULT            reduce using rule 100 (factorB -> empty .)
    DIV             reduce using rule 100 (factorB -> empty .)
    REMAINDER       reduce using rule 100 (factorB -> empty .)
    PLUS            reduce using rule 100 (factorB -> empty .)
    MINUS           reduce using rule 100 (factorB -> empty .)
    LESS            reduce using rule 100 (factorB -> empty .)
    GREATER         reduce using rule 100 (factorB -> empty .)
    LESS_EQ         reduce using rule 100 (factorB -> empty .)
    GREATER_EQ      reduce using rule 100 (factorB -> empty .)
    EQUIVALENT      reduce using rule 100 (factorB -> empty .)
    DIFFERENT       reduce using rule 100 (factorB -> empty .)
    OR              reduce using rule 100 (factorB -> empty .)
    AND             reduce using rule 100 (factorB -> empty .)
    R_PAR           reduce using rule 100 (factorB -> empty .)
    COMMA           reduce using rule 100 (factorB -> empty .)
    SEMICOLON       reduce using rule 100 (factorB -> empty .)
    R_BRACKET       reduce using rule 100 (factorB -> empty .)
    TO              reduce using rule 100 (factorB -> empty .)
    L_BRACE         reduce using rule 100 (factorB -> empty .)


state 181

    (103) exponentB -> MINUS var_cte .

    EXP             reduce using rule 103 (exponentB -> MINUS var_cte .)
    MULT            reduce using rule 103 (exponentB -> MINUS var_cte .)
    DIV             reduce using rule 103 (exponentB -> MINUS var_cte .)
    REMAINDER       reduce using rule 103 (exponentB -> MINUS var_cte .)
    PLUS            reduce using rule 103 (exponentB -> MINUS var_cte .)
    MINUS           reduce using rule 103 (exponentB -> MINUS var_cte .)
    LESS            reduce using rule 103 (exponentB -> MINUS var_cte .)
    GREATER         reduce using rule 103 (exponentB -> MINUS var_cte .)
    LESS_EQ         reduce using rule 103 (exponentB -> MINUS var_cte .)
    GREATER_EQ      reduce using rule 103 (exponentB -> MINUS var_cte .)
    EQUIVALENT      reduce using rule 103 (exponentB -> MINUS var_cte .)
    DIFFERENT       reduce using rule 103 (exponentB -> MINUS var_cte .)
    OR              reduce using rule 103 (exponentB -> MINUS var_cte .)
    AND             reduce using rule 103 (exponentB -> MINUS var_cte .)
    R_PAR           reduce using rule 103 (exponentB -> MINUS var_cte .)
    COMMA           reduce using rule 103 (exponentB -> MINUS var_cte .)
    SEMICOLON       reduce using rule 103 (exponentB -> MINUS var_cte .)
    R_BRACKET       reduce using rule 103 (exponentB -> MINUS var_cte .)
    TO              reduce using rule 103 (exponentB -> MINUS var_cte .)
    L_BRACE         reduce using rule 103 (exponentB -> MINUS var_cte .)


state 182

    (108) var_cte -> CTE_INT np_push_cte_int .

    EXP             reduce using rule 108 (var_cte -> CTE_INT np_push_cte_int .)
    MULT            reduce using rule 108 (var_cte -> CTE_INT np_push_cte_int .)
    DIV             reduce using rule 108 (var_cte -> CTE_INT np_push_cte_int .)
    REMAINDER       reduce using rule 108 (var_cte -> CTE_INT np_push_cte_int .)
    PLUS            reduce using rule 108 (var_cte -> CTE_INT np_push_cte_int .)
    MINUS           reduce using rule 108 (var_cte -> CTE_INT np_push_cte_int .)
    LESS            reduce using rule 108 (var_cte -> CTE_INT np_push_cte_int .)
    GREATER         reduce using rule 108 (var_cte -> CTE_INT np_push_cte_int .)
    LESS_EQ         reduce using rule 108 (var_cte -> CTE_INT np_push_cte_int .)
    GREATER_EQ      reduce using rule 108 (var_cte -> CTE_INT np_push_cte_int .)
    EQUIVALENT      reduce using rule 108 (var_cte -> CTE_INT np_push_cte_int .)
    DIFFERENT       reduce using rule 108 (var_cte -> CTE_INT np_push_cte_int .)
    OR              reduce using rule 108 (var_cte -> CTE_INT np_push_cte_int .)
    AND             reduce using rule 108 (var_cte -> CTE_INT np_push_cte_int .)
    R_PAR           reduce using rule 108 (var_cte -> CTE_INT np_push_cte_int .)
    COMMA           reduce using rule 108 (var_cte -> CTE_INT np_push_cte_int .)
    SEMICOLON       reduce using rule 108 (var_cte -> CTE_INT np_push_cte_int .)
    R_BRACKET       reduce using rule 108 (var_cte -> CTE_INT np_push_cte_int .)
    TO              reduce using rule 108 (var_cte -> CTE_INT np_push_cte_int .)
    L_BRACE         reduce using rule 108 (var_cte -> CTE_INT np_push_cte_int .)


state 183

    (109) var_cte -> CTE_FLOAT np_push_cte_float .

    EXP             reduce using rule 109 (var_cte -> CTE_FLOAT np_push_cte_float .)
    MULT            reduce using rule 109 (var_cte -> CTE_FLOAT np_push_cte_float .)
    DIV             reduce using rule 109 (var_cte -> CTE_FLOAT np_push_cte_float .)
    REMAINDER       reduce using rule 109 (var_cte -> CTE_FLOAT np_push_cte_float .)
    PLUS            reduce using rule 109 (var_cte -> CTE_FLOAT np_push_cte_float .)
    MINUS           reduce using rule 109 (var_cte -> CTE_FLOAT np_push_cte_float .)
    LESS            reduce using rule 109 (var_cte -> CTE_FLOAT np_push_cte_float .)
    GREATER         reduce using rule 109 (var_cte -> CTE_FLOAT np_push_cte_float .)
    LESS_EQ         reduce using rule 109 (var_cte -> CTE_FLOAT np_push_cte_float .)
    GREATER_EQ      reduce using rule 109 (var_cte -> CTE_FLOAT np_push_cte_float .)
    EQUIVALENT      reduce using rule 109 (var_cte -> CTE_FLOAT np_push_cte_float .)
    DIFFERENT       reduce using rule 109 (var_cte -> CTE_FLOAT np_push_cte_float .)
    OR              reduce using rule 109 (var_cte -> CTE_FLOAT np_push_cte_float .)
    AND             reduce using rule 109 (var_cte -> CTE_FLOAT np_push_cte_float .)
    R_PAR           reduce using rule 109 (var_cte -> CTE_FLOAT np_push_cte_float .)
    COMMA           reduce using rule 109 (var_cte -> CTE_FLOAT np_push_cte_float .)
    SEMICOLON       reduce using rule 109 (var_cte -> CTE_FLOAT np_push_cte_float .)
    R_BRACKET       reduce using rule 109 (var_cte -> CTE_FLOAT np_push_cte_float .)
    TO              reduce using rule 109 (var_cte -> CTE_FLOAT np_push_cte_float .)
    L_BRACE         reduce using rule 109 (var_cte -> CTE_FLOAT np_push_cte_float .)


state 184

    (110) var_cte -> CTE_CHAR np_push_cte_char .

    EXP             reduce using rule 110 (var_cte -> CTE_CHAR np_push_cte_char .)
    MULT            reduce using rule 110 (var_cte -> CTE_CHAR np_push_cte_char .)
    DIV             reduce using rule 110 (var_cte -> CTE_CHAR np_push_cte_char .)
    REMAINDER       reduce using rule 110 (var_cte -> CTE_CHAR np_push_cte_char .)
    PLUS            reduce using rule 110 (var_cte -> CTE_CHAR np_push_cte_char .)
    MINUS           reduce using rule 110 (var_cte -> CTE_CHAR np_push_cte_char .)
    LESS            reduce using rule 110 (var_cte -> CTE_CHAR np_push_cte_char .)
    GREATER         reduce using rule 110 (var_cte -> CTE_CHAR np_push_cte_char .)
    LESS_EQ         reduce using rule 110 (var_cte -> CTE_CHAR np_push_cte_char .)
    GREATER_EQ      reduce using rule 110 (var_cte -> CTE_CHAR np_push_cte_char .)
    EQUIVALENT      reduce using rule 110 (var_cte -> CTE_CHAR np_push_cte_char .)
    DIFFERENT       reduce using rule 110 (var_cte -> CTE_CHAR np_push_cte_char .)
    OR              reduce using rule 110 (var_cte -> CTE_CHAR np_push_cte_char .)
    AND             reduce using rule 110 (var_cte -> CTE_CHAR np_push_cte_char .)
    R_PAR           reduce using rule 110 (var_cte -> CTE_CHAR np_push_cte_char .)
    COMMA           reduce using rule 110 (var_cte -> CTE_CHAR np_push_cte_char .)
    SEMICOLON       reduce using rule 110 (var_cte -> CTE_CHAR np_push_cte_char .)
    R_BRACKET       reduce using rule 110 (var_cte -> CTE_CHAR np_push_cte_char .)
    TO              reduce using rule 110 (var_cte -> CTE_CHAR np_push_cte_char .)
    L_BRACE         reduce using rule 110 (var_cte -> CTE_CHAR np_push_cte_char .)


state 185

    (111) var_cte -> CTE_STRING np_push_cte_str .

    EXP             reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    MULT            reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    DIV             reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    REMAINDER       reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    PLUS            reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    MINUS           reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    LESS            reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    GREATER         reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    LESS_EQ         reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    GREATER_EQ      reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    EQUIVALENT      reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    DIFFERENT       reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    OR              reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    AND             reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    R_PAR           reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    SEMICOLON       reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    COMMA           reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    R_BRACKET       reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    TO              reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    L_BRACE         reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)


state 186

    (112) var_cte -> CTE_BOOL np_push_cte_bool .

    EXP             reduce using rule 112 (var_cte -> CTE_BOOL np_push_cte_bool .)
    MULT            reduce using rule 112 (var_cte -> CTE_BOOL np_push_cte_bool .)
    DIV             reduce using rule 112 (var_cte -> CTE_BOOL np_push_cte_bool .)
    REMAINDER       reduce using rule 112 (var_cte -> CTE_BOOL np_push_cte_bool .)
    PLUS            reduce using rule 112 (var_cte -> CTE_BOOL np_push_cte_bool .)
    MINUS           reduce using rule 112 (var_cte -> CTE_BOOL np_push_cte_bool .)
    LESS            reduce using rule 112 (var_cte -> CTE_BOOL np_push_cte_bool .)
    GREATER         reduce using rule 112 (var_cte -> CTE_BOOL np_push_cte_bool .)
    LESS_EQ         reduce using rule 112 (var_cte -> CTE_BOOL np_push_cte_bool .)
    GREATER_EQ      reduce using rule 112 (var_cte -> CTE_BOOL np_push_cte_bool .)
    EQUIVALENT      reduce using rule 112 (var_cte -> CTE_BOOL np_push_cte_bool .)
    DIFFERENT       reduce using rule 112 (var_cte -> CTE_BOOL np_push_cte_bool .)
    OR              reduce using rule 112 (var_cte -> CTE_BOOL np_push_cte_bool .)
    AND             reduce using rule 112 (var_cte -> CTE_BOOL np_push_cte_bool .)
    R_PAR           reduce using rule 112 (var_cte -> CTE_BOOL np_push_cte_bool .)
    COMMA           reduce using rule 112 (var_cte -> CTE_BOOL np_push_cte_bool .)
    SEMICOLON       reduce using rule 112 (var_cte -> CTE_BOOL np_push_cte_bool .)
    R_BRACKET       reduce using rule 112 (var_cte -> CTE_BOOL np_push_cte_bool .)
    TO              reduce using rule 112 (var_cte -> CTE_BOOL np_push_cte_bool .)
    L_BRACE         reduce using rule 112 (var_cte -> CTE_BOOL np_push_cte_bool .)


state 187

    (45) predef_func -> MIN L_PAR . vector R_PAR
    (22) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 227

    vector                         shift and go to state 226

state 188

    (46) predef_func -> MAX L_PAR . vector R_PAR
    (22) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 227

    vector                         shift and go to state 228

state 189

    (47) predef_func -> MEAN L_PAR . vector R_PAR
    (22) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 227

    vector                         shift and go to state 229

state 190

    (48) predef_func -> MEDIAN L_PAR . vector R_PAR
    (22) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 227

    vector                         shift and go to state 230

state 191

    (49) predef_func -> MODE L_PAR . vector R_PAR
    (22) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 227

    vector                         shift and go to state 231

state 192

    (50) predef_func -> PLOT_XY L_PAR . vector COMMA vector R_PAR
    (22) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 227

    vector                         shift and go to state 232

state 193

    (51) predef_func -> REGRESSION L_PAR . vector COMMA vector R_PAR
    (22) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 227

    vector                         shift and go to state 233

state 194

    (52) predef_func -> VARIANCE L_PAR . vector R_PAR
    (22) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 227

    vector                         shift and go to state 234

state 195

    (53) predef_func -> SUM L_PAR . vector R_PAR
    (22) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 227

    vector                         shift and go to state 235

state 196

    (57) read -> READ L_PAR read2 R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 236


state 197

    (58) read2 -> var np_read .
    (59) read2 -> var np_read . COMMA read2

    R_PAR           reduce using rule 58 (read2 -> var np_read .)
    COMMA           shift and go to state 237


state 198

    (60) write -> WRITE L_PAR writeB R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 238


state 199

    (61) writeB -> expression np_end . np_write writeC
    (130) np_write -> .

    COMMA           reduce using rule 130 (np_write -> .)
    R_PAR           reduce using rule 130 (np_write -> .)

    np_write                       shift and go to state 239

state 200

    (62) writeB -> CTE_STRING np_push_cte_str . np_write writeC
    (111) var_cte -> CTE_STRING np_push_cte_str .
    (130) np_write -> .

  ! reduce/reduce conflict for COMMA resolved using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
  ! reduce/reduce conflict for R_PAR resolved using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    EXP             reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    MULT            reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    DIV             reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    REMAINDER       reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    PLUS            reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    MINUS           reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    LESS            reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    GREATER         reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    LESS_EQ         reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    GREATER_EQ      reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    EQUIVALENT      reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    DIFFERENT       reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    OR              reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    AND             reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    COMMA           reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)
    R_PAR           reduce using rule 111 (var_cte -> CTE_STRING np_push_cte_str .)

  ! COMMA           [ reduce using rule 130 (np_write -> .) ]
  ! R_PAR           [ reduce using rule 130 (np_write -> .) ]

    np_write                       shift and go to state 240

state 201

    (65) loop_cond -> WHILE L_PAR np_CHECKPOINT expression . R_PAR np_end np_GOTOF block np_GOTO_WHILE

    R_PAR           shift and go to state 241


state 202

    (66) loop_range -> FOR var EQUAL np_push_operator . exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR
    (89) exp -> . term exp2
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    var                            shift and go to state 124
    exp                            shift and go to state 242
    term                           shift and go to state 118
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 203

    (67) return -> RETURN L_PAR np_stop exp . np_end np_set_return R_PAR SEMICOLON
    (128) np_end -> .

    R_PAR           reduce using rule 128 (np_end -> .)

    np_end                         shift and go to state 243

state 204

    (20) var -> ID L_BRACKET np_arr_start exp . np_end np_arr_end R_BRACKET
    (128) np_end -> .

    R_BRACKET       reduce using rule 128 (np_end -> .)

    np_end                         shift and go to state 244

state 205

    (68) func_call -> ID np_ERA L_PAR func_call_arguments . R_PAR np_GOSUB

    R_PAR           shift and go to state 245


state 206

    (69) func_call_arguments -> np_stop . exp np_end np_param
    (70) func_call_arguments -> np_stop . exp np_end np_param COMMA func_call_arguments
    (89) exp -> . term exp2
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    exp                            shift and go to state 246
    term                           shift and go to state 118
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 207

    (71) func_call_arguments -> empty .

    R_PAR           reduce using rule 71 (func_call_arguments -> empty .)


state 208

    (33) params -> type COLON ID np_add_param COMMA params .

    R_PAR           reduce using rule 33 (params -> type COLON ID np_add_param COMMA params .)


state 209

    (44) assign -> var oper_assign np_push_operator expression np_end . SEMICOLON

    SEMICOLON       shift and go to state 247


state 210

    (101) exponent -> L_PAR np_push_operator expression . R_PAR np_rpar

    R_PAR           shift and go to state 248


state 211

    (54) condicional -> IF L_PAR expression np_end np_GOTOF . R_PAR block cond2 np_GOTO_END

    R_PAR           shift and go to state 249


state 212

    (73) expressionB -> OR np_push_operator . expression
    (72) expression -> . logic expressionB
    (81) logic -> . exp logic2
    (89) exp -> . term exp2
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    expression                     shift and go to state 250
    logic                          shift and go to state 116
    exp                            shift and go to state 117
    term                           shift and go to state 118
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 213

    (74) expressionB -> AND np_push_operator . expression
    (72) expression -> . logic expressionB
    (81) logic -> . exp logic2
    (89) exp -> . term exp2
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    expression                     shift and go to state 251
    logic                          shift and go to state 116
    exp                            shift and go to state 117
    term                           shift and go to state 118
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 214

    (82) logic2 -> LESS np_push_operator . exp
    (89) exp -> . term exp2
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    exp                            shift and go to state 252
    term                           shift and go to state 118
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 215

    (83) logic2 -> GREATER np_push_operator . exp
    (89) exp -> . term exp2
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    exp                            shift and go to state 253
    term                           shift and go to state 118
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 216

    (84) logic2 -> LESS_EQ np_push_operator . exp
    (89) exp -> . term exp2
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    exp                            shift and go to state 254
    term                           shift and go to state 118
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 217

    (85) logic2 -> GREATER_EQ np_push_operator . exp
    (89) exp -> . term exp2
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    exp                            shift and go to state 255
    term                           shift and go to state 118
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 218

    (86) logic2 -> EQUIVALENT np_push_operator . exp
    (89) exp -> . term exp2
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    exp                            shift and go to state 256
    term                           shift and go to state 118
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 219

    (87) logic2 -> DIFFERENT np_push_operator . exp
    (89) exp -> . term exp2
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    exp                            shift and go to state 257
    term                           shift and go to state 118
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 220

    (90) exp2 -> PLUS np_push_operator . exp
    (89) exp -> . term exp2
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    exp                            shift and go to state 258
    term                           shift and go to state 118
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 221

    (91) exp2 -> MINUS np_push_operator . exp
    (89) exp -> . term exp2
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    exp                            shift and go to state 259
    term                           shift and go to state 118
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 222

    (94) term2 -> MULT np_push_operator . term
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    term                           shift and go to state 260
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 223

    (95) term2 -> DIV np_push_operator . term
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    term                           shift and go to state 261
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 224

    (96) term2 -> REMAINDER np_push_operator . term
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    term                           shift and go to state 262
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 225

    (99) factorB -> EXP factor .

    MULT            reduce using rule 99 (factorB -> EXP factor .)
    DIV             reduce using rule 99 (factorB -> EXP factor .)
    REMAINDER       reduce using rule 99 (factorB -> EXP factor .)
    PLUS            reduce using rule 99 (factorB -> EXP factor .)
    MINUS           reduce using rule 99 (factorB -> EXP factor .)
    LESS            reduce using rule 99 (factorB -> EXP factor .)
    GREATER         reduce using rule 99 (factorB -> EXP factor .)
    LESS_EQ         reduce using rule 99 (factorB -> EXP factor .)
    GREATER_EQ      reduce using rule 99 (factorB -> EXP factor .)
    EQUIVALENT      reduce using rule 99 (factorB -> EXP factor .)
    DIFFERENT       reduce using rule 99 (factorB -> EXP factor .)
    OR              reduce using rule 99 (factorB -> EXP factor .)
    AND             reduce using rule 99 (factorB -> EXP factor .)
    R_PAR           reduce using rule 99 (factorB -> EXP factor .)
    COMMA           reduce using rule 99 (factorB -> EXP factor .)
    SEMICOLON       reduce using rule 99 (factorB -> EXP factor .)
    R_BRACKET       reduce using rule 99 (factorB -> EXP factor .)
    TO              reduce using rule 99 (factorB -> EXP factor .)
    L_BRACE         reduce using rule 99 (factorB -> EXP factor .)


state 226

    (45) predef_func -> MIN L_PAR vector . R_PAR

    R_PAR           shift and go to state 263


state 227

    (22) vector -> ID . L_BRACKET R_BRACKET

    L_BRACKET       shift and go to state 264


state 228

    (46) predef_func -> MAX L_PAR vector . R_PAR

    R_PAR           shift and go to state 265


state 229

    (47) predef_func -> MEAN L_PAR vector . R_PAR

    R_PAR           shift and go to state 266


state 230

    (48) predef_func -> MEDIAN L_PAR vector . R_PAR

    R_PAR           shift and go to state 267


state 231

    (49) predef_func -> MODE L_PAR vector . R_PAR

    R_PAR           shift and go to state 268


state 232

    (50) predef_func -> PLOT_XY L_PAR vector . COMMA vector R_PAR

    COMMA           shift and go to state 269


state 233

    (51) predef_func -> REGRESSION L_PAR vector . COMMA vector R_PAR

    COMMA           shift and go to state 270


state 234

    (52) predef_func -> VARIANCE L_PAR vector . R_PAR

    R_PAR           shift and go to state 271


state 235

    (53) predef_func -> SUM L_PAR vector . R_PAR

    R_PAR           shift and go to state 272


state 236

    (57) read -> READ L_PAR read2 R_PAR SEMICOLON .

    IF              reduce using rule 57 (read -> READ L_PAR read2 R_PAR SEMICOLON .)
    READ            reduce using rule 57 (read -> READ L_PAR read2 R_PAR SEMICOLON .)
    WRITE           reduce using rule 57 (read -> READ L_PAR read2 R_PAR SEMICOLON .)
    WHILE           reduce using rule 57 (read -> READ L_PAR read2 R_PAR SEMICOLON .)
    FOR             reduce using rule 57 (read -> READ L_PAR read2 R_PAR SEMICOLON .)
    RETURN          reduce using rule 57 (read -> READ L_PAR read2 R_PAR SEMICOLON .)
    ID              reduce using rule 57 (read -> READ L_PAR read2 R_PAR SEMICOLON .)
    R_BRACE         reduce using rule 57 (read -> READ L_PAR read2 R_PAR SEMICOLON .)


state 237

    (59) read2 -> var np_read COMMA . read2
    (58) read2 -> . var np_read
    (59) read2 -> . var np_read COMMA read2
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand

    ID              shift and go to state 102

    var                            shift and go to state 142
    read2                          shift and go to state 273

state 238

    (60) write -> WRITE L_PAR writeB R_PAR SEMICOLON .

    IF              reduce using rule 60 (write -> WRITE L_PAR writeB R_PAR SEMICOLON .)
    READ            reduce using rule 60 (write -> WRITE L_PAR writeB R_PAR SEMICOLON .)
    WRITE           reduce using rule 60 (write -> WRITE L_PAR writeB R_PAR SEMICOLON .)
    WHILE           reduce using rule 60 (write -> WRITE L_PAR writeB R_PAR SEMICOLON .)
    FOR             reduce using rule 60 (write -> WRITE L_PAR writeB R_PAR SEMICOLON .)
    RETURN          reduce using rule 60 (write -> WRITE L_PAR writeB R_PAR SEMICOLON .)
    ID              reduce using rule 60 (write -> WRITE L_PAR writeB R_PAR SEMICOLON .)
    R_BRACE         reduce using rule 60 (write -> WRITE L_PAR writeB R_PAR SEMICOLON .)


state 239

    (61) writeB -> expression np_end np_write . writeC
    (63) writeC -> . COMMA writeB
    (64) writeC -> . empty
    (113) empty -> .

    COMMA           shift and go to state 275
    R_PAR           reduce using rule 113 (empty -> .)

    writeC                         shift and go to state 274
    empty                          shift and go to state 276

state 240

    (62) writeB -> CTE_STRING np_push_cte_str np_write . writeC
    (63) writeC -> . COMMA writeB
    (64) writeC -> . empty
    (113) empty -> .

    COMMA           shift and go to state 275
    R_PAR           reduce using rule 113 (empty -> .)

    writeC                         shift and go to state 277
    empty                          shift and go to state 276

state 241

    (65) loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR . np_end np_GOTOF block np_GOTO_WHILE
    (128) np_end -> .

    L_BRACE         reduce using rule 128 (np_end -> .)

    np_end                         shift and go to state 278

state 242

    (66) loop_range -> FOR var EQUAL np_push_operator exp . np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR
    (131) np_set_VC -> .

    TO              reduce using rule 131 (np_set_VC -> .)

    np_set_VC                      shift and go to state 279

state 243

    (67) return -> RETURN L_PAR np_stop exp np_end . np_set_return R_PAR SEMICOLON
    (127) np_set_return -> .

    R_PAR           reduce using rule 127 (np_set_return -> .)

    np_set_return                  shift and go to state 280

state 244

    (20) var -> ID L_BRACKET np_arr_start exp np_end . np_arr_end R_BRACKET
    (147) np_arr_end -> .

    R_BRACKET       reduce using rule 147 (np_arr_end -> .)

    np_arr_end                     shift and go to state 281

state 245

    (68) func_call -> ID np_ERA L_PAR func_call_arguments R_PAR . np_GOSUB
    (142) np_GOSUB -> .

    SEMICOLON       reduce using rule 142 (np_GOSUB -> .)
    EXP             reduce using rule 142 (np_GOSUB -> .)
    MULT            reduce using rule 142 (np_GOSUB -> .)
    DIV             reduce using rule 142 (np_GOSUB -> .)
    REMAINDER       reduce using rule 142 (np_GOSUB -> .)
    PLUS            reduce using rule 142 (np_GOSUB -> .)
    MINUS           reduce using rule 142 (np_GOSUB -> .)
    LESS            reduce using rule 142 (np_GOSUB -> .)
    GREATER         reduce using rule 142 (np_GOSUB -> .)
    LESS_EQ         reduce using rule 142 (np_GOSUB -> .)
    GREATER_EQ      reduce using rule 142 (np_GOSUB -> .)
    EQUIVALENT      reduce using rule 142 (np_GOSUB -> .)
    DIFFERENT       reduce using rule 142 (np_GOSUB -> .)
    OR              reduce using rule 142 (np_GOSUB -> .)
    AND             reduce using rule 142 (np_GOSUB -> .)
    R_PAR           reduce using rule 142 (np_GOSUB -> .)
    COMMA           reduce using rule 142 (np_GOSUB -> .)
    R_BRACKET       reduce using rule 142 (np_GOSUB -> .)
    TO              reduce using rule 142 (np_GOSUB -> .)
    L_BRACE         reduce using rule 142 (np_GOSUB -> .)

    np_GOSUB                       shift and go to state 282

state 246

    (69) func_call_arguments -> np_stop exp . np_end np_param
    (70) func_call_arguments -> np_stop exp . np_end np_param COMMA func_call_arguments
    (128) np_end -> .

    COMMA           reduce using rule 128 (np_end -> .)
    R_PAR           reduce using rule 128 (np_end -> .)

    np_end                         shift and go to state 283

state 247

    (44) assign -> var oper_assign np_push_operator expression np_end SEMICOLON .

    IF              reduce using rule 44 (assign -> var oper_assign np_push_operator expression np_end SEMICOLON .)
    READ            reduce using rule 44 (assign -> var oper_assign np_push_operator expression np_end SEMICOLON .)
    WRITE           reduce using rule 44 (assign -> var oper_assign np_push_operator expression np_end SEMICOLON .)
    WHILE           reduce using rule 44 (assign -> var oper_assign np_push_operator expression np_end SEMICOLON .)
    FOR             reduce using rule 44 (assign -> var oper_assign np_push_operator expression np_end SEMICOLON .)
    RETURN          reduce using rule 44 (assign -> var oper_assign np_push_operator expression np_end SEMICOLON .)
    ID              reduce using rule 44 (assign -> var oper_assign np_push_operator expression np_end SEMICOLON .)
    R_BRACE         reduce using rule 44 (assign -> var oper_assign np_push_operator expression np_end SEMICOLON .)


state 248

    (101) exponent -> L_PAR np_push_operator expression R_PAR . np_rpar
    (126) np_rpar -> .

    EXP             reduce using rule 126 (np_rpar -> .)
    MULT            reduce using rule 126 (np_rpar -> .)
    DIV             reduce using rule 126 (np_rpar -> .)
    REMAINDER       reduce using rule 126 (np_rpar -> .)
    PLUS            reduce using rule 126 (np_rpar -> .)
    MINUS           reduce using rule 126 (np_rpar -> .)
    LESS            reduce using rule 126 (np_rpar -> .)
    GREATER         reduce using rule 126 (np_rpar -> .)
    LESS_EQ         reduce using rule 126 (np_rpar -> .)
    GREATER_EQ      reduce using rule 126 (np_rpar -> .)
    EQUIVALENT      reduce using rule 126 (np_rpar -> .)
    DIFFERENT       reduce using rule 126 (np_rpar -> .)
    OR              reduce using rule 126 (np_rpar -> .)
    AND             reduce using rule 126 (np_rpar -> .)
    R_PAR           reduce using rule 126 (np_rpar -> .)
    COMMA           reduce using rule 126 (np_rpar -> .)
    SEMICOLON       reduce using rule 126 (np_rpar -> .)
    R_BRACKET       reduce using rule 126 (np_rpar -> .)
    TO              reduce using rule 126 (np_rpar -> .)
    L_BRACE         reduce using rule 126 (np_rpar -> .)

    np_rpar                        shift and go to state 284

state 249

    (54) condicional -> IF L_PAR expression np_end np_GOTOF R_PAR . block cond2 np_GOTO_END
    (25) block -> . L_BRACE blockB R_BRACE

    L_BRACE         shift and go to state 286

    block                          shift and go to state 285

state 250

    (73) expressionB -> OR np_push_operator expression .

    R_PAR           reduce using rule 73 (expressionB -> OR np_push_operator expression .)
    COMMA           reduce using rule 73 (expressionB -> OR np_push_operator expression .)
    SEMICOLON       reduce using rule 73 (expressionB -> OR np_push_operator expression .)


state 251

    (74) expressionB -> AND np_push_operator expression .

    R_PAR           reduce using rule 74 (expressionB -> AND np_push_operator expression .)
    COMMA           reduce using rule 74 (expressionB -> AND np_push_operator expression .)
    SEMICOLON       reduce using rule 74 (expressionB -> AND np_push_operator expression .)


state 252

    (82) logic2 -> LESS np_push_operator exp .

    OR              reduce using rule 82 (logic2 -> LESS np_push_operator exp .)
    AND             reduce using rule 82 (logic2 -> LESS np_push_operator exp .)
    R_PAR           reduce using rule 82 (logic2 -> LESS np_push_operator exp .)
    COMMA           reduce using rule 82 (logic2 -> LESS np_push_operator exp .)
    SEMICOLON       reduce using rule 82 (logic2 -> LESS np_push_operator exp .)


state 253

    (83) logic2 -> GREATER np_push_operator exp .

    OR              reduce using rule 83 (logic2 -> GREATER np_push_operator exp .)
    AND             reduce using rule 83 (logic2 -> GREATER np_push_operator exp .)
    R_PAR           reduce using rule 83 (logic2 -> GREATER np_push_operator exp .)
    COMMA           reduce using rule 83 (logic2 -> GREATER np_push_operator exp .)
    SEMICOLON       reduce using rule 83 (logic2 -> GREATER np_push_operator exp .)


state 254

    (84) logic2 -> LESS_EQ np_push_operator exp .

    OR              reduce using rule 84 (logic2 -> LESS_EQ np_push_operator exp .)
    AND             reduce using rule 84 (logic2 -> LESS_EQ np_push_operator exp .)
    R_PAR           reduce using rule 84 (logic2 -> LESS_EQ np_push_operator exp .)
    COMMA           reduce using rule 84 (logic2 -> LESS_EQ np_push_operator exp .)
    SEMICOLON       reduce using rule 84 (logic2 -> LESS_EQ np_push_operator exp .)


state 255

    (85) logic2 -> GREATER_EQ np_push_operator exp .

    OR              reduce using rule 85 (logic2 -> GREATER_EQ np_push_operator exp .)
    AND             reduce using rule 85 (logic2 -> GREATER_EQ np_push_operator exp .)
    R_PAR           reduce using rule 85 (logic2 -> GREATER_EQ np_push_operator exp .)
    COMMA           reduce using rule 85 (logic2 -> GREATER_EQ np_push_operator exp .)
    SEMICOLON       reduce using rule 85 (logic2 -> GREATER_EQ np_push_operator exp .)


state 256

    (86) logic2 -> EQUIVALENT np_push_operator exp .

    OR              reduce using rule 86 (logic2 -> EQUIVALENT np_push_operator exp .)
    AND             reduce using rule 86 (logic2 -> EQUIVALENT np_push_operator exp .)
    R_PAR           reduce using rule 86 (logic2 -> EQUIVALENT np_push_operator exp .)
    COMMA           reduce using rule 86 (logic2 -> EQUIVALENT np_push_operator exp .)
    SEMICOLON       reduce using rule 86 (logic2 -> EQUIVALENT np_push_operator exp .)


state 257

    (87) logic2 -> DIFFERENT np_push_operator exp .

    OR              reduce using rule 87 (logic2 -> DIFFERENT np_push_operator exp .)
    AND             reduce using rule 87 (logic2 -> DIFFERENT np_push_operator exp .)
    R_PAR           reduce using rule 87 (logic2 -> DIFFERENT np_push_operator exp .)
    COMMA           reduce using rule 87 (logic2 -> DIFFERENT np_push_operator exp .)
    SEMICOLON       reduce using rule 87 (logic2 -> DIFFERENT np_push_operator exp .)


state 258

    (90) exp2 -> PLUS np_push_operator exp .

    LESS            reduce using rule 90 (exp2 -> PLUS np_push_operator exp .)
    GREATER         reduce using rule 90 (exp2 -> PLUS np_push_operator exp .)
    LESS_EQ         reduce using rule 90 (exp2 -> PLUS np_push_operator exp .)
    GREATER_EQ      reduce using rule 90 (exp2 -> PLUS np_push_operator exp .)
    EQUIVALENT      reduce using rule 90 (exp2 -> PLUS np_push_operator exp .)
    DIFFERENT       reduce using rule 90 (exp2 -> PLUS np_push_operator exp .)
    OR              reduce using rule 90 (exp2 -> PLUS np_push_operator exp .)
    AND             reduce using rule 90 (exp2 -> PLUS np_push_operator exp .)
    R_PAR           reduce using rule 90 (exp2 -> PLUS np_push_operator exp .)
    COMMA           reduce using rule 90 (exp2 -> PLUS np_push_operator exp .)
    SEMICOLON       reduce using rule 90 (exp2 -> PLUS np_push_operator exp .)
    R_BRACKET       reduce using rule 90 (exp2 -> PLUS np_push_operator exp .)
    TO              reduce using rule 90 (exp2 -> PLUS np_push_operator exp .)
    L_BRACE         reduce using rule 90 (exp2 -> PLUS np_push_operator exp .)


state 259

    (91) exp2 -> MINUS np_push_operator exp .

    LESS            reduce using rule 91 (exp2 -> MINUS np_push_operator exp .)
    GREATER         reduce using rule 91 (exp2 -> MINUS np_push_operator exp .)
    LESS_EQ         reduce using rule 91 (exp2 -> MINUS np_push_operator exp .)
    GREATER_EQ      reduce using rule 91 (exp2 -> MINUS np_push_operator exp .)
    EQUIVALENT      reduce using rule 91 (exp2 -> MINUS np_push_operator exp .)
    DIFFERENT       reduce using rule 91 (exp2 -> MINUS np_push_operator exp .)
    OR              reduce using rule 91 (exp2 -> MINUS np_push_operator exp .)
    AND             reduce using rule 91 (exp2 -> MINUS np_push_operator exp .)
    R_PAR           reduce using rule 91 (exp2 -> MINUS np_push_operator exp .)
    COMMA           reduce using rule 91 (exp2 -> MINUS np_push_operator exp .)
    SEMICOLON       reduce using rule 91 (exp2 -> MINUS np_push_operator exp .)
    R_BRACKET       reduce using rule 91 (exp2 -> MINUS np_push_operator exp .)
    TO              reduce using rule 91 (exp2 -> MINUS np_push_operator exp .)
    L_BRACE         reduce using rule 91 (exp2 -> MINUS np_push_operator exp .)


state 260

    (94) term2 -> MULT np_push_operator term .

    PLUS            reduce using rule 94 (term2 -> MULT np_push_operator term .)
    MINUS           reduce using rule 94 (term2 -> MULT np_push_operator term .)
    LESS            reduce using rule 94 (term2 -> MULT np_push_operator term .)
    GREATER         reduce using rule 94 (term2 -> MULT np_push_operator term .)
    LESS_EQ         reduce using rule 94 (term2 -> MULT np_push_operator term .)
    GREATER_EQ      reduce using rule 94 (term2 -> MULT np_push_operator term .)
    EQUIVALENT      reduce using rule 94 (term2 -> MULT np_push_operator term .)
    DIFFERENT       reduce using rule 94 (term2 -> MULT np_push_operator term .)
    OR              reduce using rule 94 (term2 -> MULT np_push_operator term .)
    AND             reduce using rule 94 (term2 -> MULT np_push_operator term .)
    R_PAR           reduce using rule 94 (term2 -> MULT np_push_operator term .)
    COMMA           reduce using rule 94 (term2 -> MULT np_push_operator term .)
    SEMICOLON       reduce using rule 94 (term2 -> MULT np_push_operator term .)
    R_BRACKET       reduce using rule 94 (term2 -> MULT np_push_operator term .)
    TO              reduce using rule 94 (term2 -> MULT np_push_operator term .)
    L_BRACE         reduce using rule 94 (term2 -> MULT np_push_operator term .)


state 261

    (95) term2 -> DIV np_push_operator term .

    PLUS            reduce using rule 95 (term2 -> DIV np_push_operator term .)
    MINUS           reduce using rule 95 (term2 -> DIV np_push_operator term .)
    LESS            reduce using rule 95 (term2 -> DIV np_push_operator term .)
    GREATER         reduce using rule 95 (term2 -> DIV np_push_operator term .)
    LESS_EQ         reduce using rule 95 (term2 -> DIV np_push_operator term .)
    GREATER_EQ      reduce using rule 95 (term2 -> DIV np_push_operator term .)
    EQUIVALENT      reduce using rule 95 (term2 -> DIV np_push_operator term .)
    DIFFERENT       reduce using rule 95 (term2 -> DIV np_push_operator term .)
    OR              reduce using rule 95 (term2 -> DIV np_push_operator term .)
    AND             reduce using rule 95 (term2 -> DIV np_push_operator term .)
    R_PAR           reduce using rule 95 (term2 -> DIV np_push_operator term .)
    COMMA           reduce using rule 95 (term2 -> DIV np_push_operator term .)
    SEMICOLON       reduce using rule 95 (term2 -> DIV np_push_operator term .)
    R_BRACKET       reduce using rule 95 (term2 -> DIV np_push_operator term .)
    TO              reduce using rule 95 (term2 -> DIV np_push_operator term .)
    L_BRACE         reduce using rule 95 (term2 -> DIV np_push_operator term .)


state 262

    (96) term2 -> REMAINDER np_push_operator term .

    PLUS            reduce using rule 96 (term2 -> REMAINDER np_push_operator term .)
    MINUS           reduce using rule 96 (term2 -> REMAINDER np_push_operator term .)
    LESS            reduce using rule 96 (term2 -> REMAINDER np_push_operator term .)
    GREATER         reduce using rule 96 (term2 -> REMAINDER np_push_operator term .)
    LESS_EQ         reduce using rule 96 (term2 -> REMAINDER np_push_operator term .)
    GREATER_EQ      reduce using rule 96 (term2 -> REMAINDER np_push_operator term .)
    EQUIVALENT      reduce using rule 96 (term2 -> REMAINDER np_push_operator term .)
    DIFFERENT       reduce using rule 96 (term2 -> REMAINDER np_push_operator term .)
    OR              reduce using rule 96 (term2 -> REMAINDER np_push_operator term .)
    AND             reduce using rule 96 (term2 -> REMAINDER np_push_operator term .)
    R_PAR           reduce using rule 96 (term2 -> REMAINDER np_push_operator term .)
    COMMA           reduce using rule 96 (term2 -> REMAINDER np_push_operator term .)
    SEMICOLON       reduce using rule 96 (term2 -> REMAINDER np_push_operator term .)
    R_BRACKET       reduce using rule 96 (term2 -> REMAINDER np_push_operator term .)
    TO              reduce using rule 96 (term2 -> REMAINDER np_push_operator term .)
    L_BRACE         reduce using rule 96 (term2 -> REMAINDER np_push_operator term .)


state 263

    (45) predef_func -> MIN L_PAR vector R_PAR .

    EXP             reduce using rule 45 (predef_func -> MIN L_PAR vector R_PAR .)
    MULT            reduce using rule 45 (predef_func -> MIN L_PAR vector R_PAR .)
    DIV             reduce using rule 45 (predef_func -> MIN L_PAR vector R_PAR .)
    REMAINDER       reduce using rule 45 (predef_func -> MIN L_PAR vector R_PAR .)
    PLUS            reduce using rule 45 (predef_func -> MIN L_PAR vector R_PAR .)
    MINUS           reduce using rule 45 (predef_func -> MIN L_PAR vector R_PAR .)
    LESS            reduce using rule 45 (predef_func -> MIN L_PAR vector R_PAR .)
    GREATER         reduce using rule 45 (predef_func -> MIN L_PAR vector R_PAR .)
    LESS_EQ         reduce using rule 45 (predef_func -> MIN L_PAR vector R_PAR .)
    GREATER_EQ      reduce using rule 45 (predef_func -> MIN L_PAR vector R_PAR .)
    EQUIVALENT      reduce using rule 45 (predef_func -> MIN L_PAR vector R_PAR .)
    DIFFERENT       reduce using rule 45 (predef_func -> MIN L_PAR vector R_PAR .)
    OR              reduce using rule 45 (predef_func -> MIN L_PAR vector R_PAR .)
    AND             reduce using rule 45 (predef_func -> MIN L_PAR vector R_PAR .)
    R_PAR           reduce using rule 45 (predef_func -> MIN L_PAR vector R_PAR .)
    COMMA           reduce using rule 45 (predef_func -> MIN L_PAR vector R_PAR .)
    SEMICOLON       reduce using rule 45 (predef_func -> MIN L_PAR vector R_PAR .)
    R_BRACKET       reduce using rule 45 (predef_func -> MIN L_PAR vector R_PAR .)
    TO              reduce using rule 45 (predef_func -> MIN L_PAR vector R_PAR .)
    L_BRACE         reduce using rule 45 (predef_func -> MIN L_PAR vector R_PAR .)


state 264

    (22) vector -> ID L_BRACKET . R_BRACKET

    R_BRACKET       shift and go to state 287


state 265

    (46) predef_func -> MAX L_PAR vector R_PAR .

    EXP             reduce using rule 46 (predef_func -> MAX L_PAR vector R_PAR .)
    MULT            reduce using rule 46 (predef_func -> MAX L_PAR vector R_PAR .)
    DIV             reduce using rule 46 (predef_func -> MAX L_PAR vector R_PAR .)
    REMAINDER       reduce using rule 46 (predef_func -> MAX L_PAR vector R_PAR .)
    PLUS            reduce using rule 46 (predef_func -> MAX L_PAR vector R_PAR .)
    MINUS           reduce using rule 46 (predef_func -> MAX L_PAR vector R_PAR .)
    LESS            reduce using rule 46 (predef_func -> MAX L_PAR vector R_PAR .)
    GREATER         reduce using rule 46 (predef_func -> MAX L_PAR vector R_PAR .)
    LESS_EQ         reduce using rule 46 (predef_func -> MAX L_PAR vector R_PAR .)
    GREATER_EQ      reduce using rule 46 (predef_func -> MAX L_PAR vector R_PAR .)
    EQUIVALENT      reduce using rule 46 (predef_func -> MAX L_PAR vector R_PAR .)
    DIFFERENT       reduce using rule 46 (predef_func -> MAX L_PAR vector R_PAR .)
    OR              reduce using rule 46 (predef_func -> MAX L_PAR vector R_PAR .)
    AND             reduce using rule 46 (predef_func -> MAX L_PAR vector R_PAR .)
    R_PAR           reduce using rule 46 (predef_func -> MAX L_PAR vector R_PAR .)
    COMMA           reduce using rule 46 (predef_func -> MAX L_PAR vector R_PAR .)
    SEMICOLON       reduce using rule 46 (predef_func -> MAX L_PAR vector R_PAR .)
    R_BRACKET       reduce using rule 46 (predef_func -> MAX L_PAR vector R_PAR .)
    TO              reduce using rule 46 (predef_func -> MAX L_PAR vector R_PAR .)
    L_BRACE         reduce using rule 46 (predef_func -> MAX L_PAR vector R_PAR .)


state 266

    (47) predef_func -> MEAN L_PAR vector R_PAR .

    EXP             reduce using rule 47 (predef_func -> MEAN L_PAR vector R_PAR .)
    MULT            reduce using rule 47 (predef_func -> MEAN L_PAR vector R_PAR .)
    DIV             reduce using rule 47 (predef_func -> MEAN L_PAR vector R_PAR .)
    REMAINDER       reduce using rule 47 (predef_func -> MEAN L_PAR vector R_PAR .)
    PLUS            reduce using rule 47 (predef_func -> MEAN L_PAR vector R_PAR .)
    MINUS           reduce using rule 47 (predef_func -> MEAN L_PAR vector R_PAR .)
    LESS            reduce using rule 47 (predef_func -> MEAN L_PAR vector R_PAR .)
    GREATER         reduce using rule 47 (predef_func -> MEAN L_PAR vector R_PAR .)
    LESS_EQ         reduce using rule 47 (predef_func -> MEAN L_PAR vector R_PAR .)
    GREATER_EQ      reduce using rule 47 (predef_func -> MEAN L_PAR vector R_PAR .)
    EQUIVALENT      reduce using rule 47 (predef_func -> MEAN L_PAR vector R_PAR .)
    DIFFERENT       reduce using rule 47 (predef_func -> MEAN L_PAR vector R_PAR .)
    OR              reduce using rule 47 (predef_func -> MEAN L_PAR vector R_PAR .)
    AND             reduce using rule 47 (predef_func -> MEAN L_PAR vector R_PAR .)
    R_PAR           reduce using rule 47 (predef_func -> MEAN L_PAR vector R_PAR .)
    COMMA           reduce using rule 47 (predef_func -> MEAN L_PAR vector R_PAR .)
    SEMICOLON       reduce using rule 47 (predef_func -> MEAN L_PAR vector R_PAR .)
    R_BRACKET       reduce using rule 47 (predef_func -> MEAN L_PAR vector R_PAR .)
    TO              reduce using rule 47 (predef_func -> MEAN L_PAR vector R_PAR .)
    L_BRACE         reduce using rule 47 (predef_func -> MEAN L_PAR vector R_PAR .)


state 267

    (48) predef_func -> MEDIAN L_PAR vector R_PAR .

    EXP             reduce using rule 48 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    MULT            reduce using rule 48 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    DIV             reduce using rule 48 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    REMAINDER       reduce using rule 48 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    PLUS            reduce using rule 48 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    MINUS           reduce using rule 48 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    LESS            reduce using rule 48 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    GREATER         reduce using rule 48 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    LESS_EQ         reduce using rule 48 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    GREATER_EQ      reduce using rule 48 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    EQUIVALENT      reduce using rule 48 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    DIFFERENT       reduce using rule 48 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    OR              reduce using rule 48 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    AND             reduce using rule 48 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    R_PAR           reduce using rule 48 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    COMMA           reduce using rule 48 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    SEMICOLON       reduce using rule 48 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    R_BRACKET       reduce using rule 48 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    TO              reduce using rule 48 (predef_func -> MEDIAN L_PAR vector R_PAR .)
    L_BRACE         reduce using rule 48 (predef_func -> MEDIAN L_PAR vector R_PAR .)


state 268

    (49) predef_func -> MODE L_PAR vector R_PAR .

    EXP             reduce using rule 49 (predef_func -> MODE L_PAR vector R_PAR .)
    MULT            reduce using rule 49 (predef_func -> MODE L_PAR vector R_PAR .)
    DIV             reduce using rule 49 (predef_func -> MODE L_PAR vector R_PAR .)
    REMAINDER       reduce using rule 49 (predef_func -> MODE L_PAR vector R_PAR .)
    PLUS            reduce using rule 49 (predef_func -> MODE L_PAR vector R_PAR .)
    MINUS           reduce using rule 49 (predef_func -> MODE L_PAR vector R_PAR .)
    LESS            reduce using rule 49 (predef_func -> MODE L_PAR vector R_PAR .)
    GREATER         reduce using rule 49 (predef_func -> MODE L_PAR vector R_PAR .)
    LESS_EQ         reduce using rule 49 (predef_func -> MODE L_PAR vector R_PAR .)
    GREATER_EQ      reduce using rule 49 (predef_func -> MODE L_PAR vector R_PAR .)
    EQUIVALENT      reduce using rule 49 (predef_func -> MODE L_PAR vector R_PAR .)
    DIFFERENT       reduce using rule 49 (predef_func -> MODE L_PAR vector R_PAR .)
    OR              reduce using rule 49 (predef_func -> MODE L_PAR vector R_PAR .)
    AND             reduce using rule 49 (predef_func -> MODE L_PAR vector R_PAR .)
    R_PAR           reduce using rule 49 (predef_func -> MODE L_PAR vector R_PAR .)
    COMMA           reduce using rule 49 (predef_func -> MODE L_PAR vector R_PAR .)
    SEMICOLON       reduce using rule 49 (predef_func -> MODE L_PAR vector R_PAR .)
    R_BRACKET       reduce using rule 49 (predef_func -> MODE L_PAR vector R_PAR .)
    TO              reduce using rule 49 (predef_func -> MODE L_PAR vector R_PAR .)
    L_BRACE         reduce using rule 49 (predef_func -> MODE L_PAR vector R_PAR .)


state 269

    (50) predef_func -> PLOT_XY L_PAR vector COMMA . vector R_PAR
    (22) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 227

    vector                         shift and go to state 288

state 270

    (51) predef_func -> REGRESSION L_PAR vector COMMA . vector R_PAR
    (22) vector -> . ID L_BRACKET R_BRACKET

    ID              shift and go to state 227

    vector                         shift and go to state 289

state 271

    (52) predef_func -> VARIANCE L_PAR vector R_PAR .

    EXP             reduce using rule 52 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    MULT            reduce using rule 52 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    DIV             reduce using rule 52 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    REMAINDER       reduce using rule 52 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    PLUS            reduce using rule 52 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    MINUS           reduce using rule 52 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    LESS            reduce using rule 52 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    GREATER         reduce using rule 52 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    LESS_EQ         reduce using rule 52 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    GREATER_EQ      reduce using rule 52 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    EQUIVALENT      reduce using rule 52 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    DIFFERENT       reduce using rule 52 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    OR              reduce using rule 52 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    AND             reduce using rule 52 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    R_PAR           reduce using rule 52 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    COMMA           reduce using rule 52 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    SEMICOLON       reduce using rule 52 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    R_BRACKET       reduce using rule 52 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    TO              reduce using rule 52 (predef_func -> VARIANCE L_PAR vector R_PAR .)
    L_BRACE         reduce using rule 52 (predef_func -> VARIANCE L_PAR vector R_PAR .)


state 272

    (53) predef_func -> SUM L_PAR vector R_PAR .

    EXP             reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    MULT            reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    DIV             reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    REMAINDER       reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    PLUS            reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    MINUS           reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    LESS            reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    GREATER         reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    LESS_EQ         reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    GREATER_EQ      reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    EQUIVALENT      reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    DIFFERENT       reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    OR              reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    AND             reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    R_PAR           reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    COMMA           reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    SEMICOLON       reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    R_BRACKET       reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    TO              reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)
    L_BRACE         reduce using rule 53 (predef_func -> SUM L_PAR vector R_PAR .)


state 273

    (59) read2 -> var np_read COMMA read2 .

    R_PAR           reduce using rule 59 (read2 -> var np_read COMMA read2 .)


state 274

    (61) writeB -> expression np_end np_write writeC .

    R_PAR           reduce using rule 61 (writeB -> expression np_end np_write writeC .)


state 275

    (63) writeC -> COMMA . writeB
    (61) writeB -> . expression np_end np_write writeC
    (62) writeB -> . CTE_STRING np_push_cte_str np_write writeC
    (72) expression -> . logic expressionB
    (81) logic -> . exp logic2
    (89) exp -> . term exp2
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    CTE_STRING      shift and go to state 145
    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    writeB                         shift and go to state 290
    expression                     shift and go to state 144
    logic                          shift and go to state 116
    exp                            shift and go to state 117
    term                           shift and go to state 118
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    var                            shift and go to state 124
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 276

    (64) writeC -> empty .

    R_PAR           reduce using rule 64 (writeC -> empty .)


state 277

    (62) writeB -> CTE_STRING np_push_cte_str np_write writeC .

    R_PAR           reduce using rule 62 (writeB -> CTE_STRING np_push_cte_str np_write writeC .)


state 278

    (65) loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end . np_GOTOF block np_GOTO_WHILE
    (134) np_GOTOF -> .

    L_BRACE         reduce using rule 134 (np_GOTOF -> .)

    np_GOTOF                       shift and go to state 291

state 279

    (66) loop_range -> FOR var EQUAL np_push_operator exp np_set_VC . TO exp np_end np_comp_VC_VF block np_GOTO_FOR

    TO              shift and go to state 292


state 280

    (67) return -> RETURN L_PAR np_stop exp np_end np_set_return . R_PAR SEMICOLON

    R_PAR           shift and go to state 293


state 281

    (20) var -> ID L_BRACKET np_arr_start exp np_end np_arr_end . R_BRACKET

    R_BRACKET       shift and go to state 294


state 282

    (68) func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .

    SEMICOLON       reduce using rule 68 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    EXP             reduce using rule 68 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    MULT            reduce using rule 68 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    DIV             reduce using rule 68 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    REMAINDER       reduce using rule 68 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    PLUS            reduce using rule 68 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    MINUS           reduce using rule 68 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    LESS            reduce using rule 68 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    GREATER         reduce using rule 68 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    LESS_EQ         reduce using rule 68 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    GREATER_EQ      reduce using rule 68 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    EQUIVALENT      reduce using rule 68 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    DIFFERENT       reduce using rule 68 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    OR              reduce using rule 68 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    AND             reduce using rule 68 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    R_PAR           reduce using rule 68 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    COMMA           reduce using rule 68 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    R_BRACKET       reduce using rule 68 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    TO              reduce using rule 68 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)
    L_BRACE         reduce using rule 68 (func_call -> ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB .)


state 283

    (69) func_call_arguments -> np_stop exp np_end . np_param
    (70) func_call_arguments -> np_stop exp np_end . np_param COMMA func_call_arguments
    (144) np_param -> .

    COMMA           reduce using rule 144 (np_param -> .)
    R_PAR           reduce using rule 144 (np_param -> .)

    np_param                       shift and go to state 295

state 284

    (101) exponent -> L_PAR np_push_operator expression R_PAR np_rpar .

    EXP             reduce using rule 101 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    MULT            reduce using rule 101 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    DIV             reduce using rule 101 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    REMAINDER       reduce using rule 101 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    PLUS            reduce using rule 101 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    MINUS           reduce using rule 101 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    LESS            reduce using rule 101 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    GREATER         reduce using rule 101 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    LESS_EQ         reduce using rule 101 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    GREATER_EQ      reduce using rule 101 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    EQUIVALENT      reduce using rule 101 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    DIFFERENT       reduce using rule 101 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    OR              reduce using rule 101 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    AND             reduce using rule 101 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    R_PAR           reduce using rule 101 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    COMMA           reduce using rule 101 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    SEMICOLON       reduce using rule 101 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    R_BRACKET       reduce using rule 101 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    TO              reduce using rule 101 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)
    L_BRACE         reduce using rule 101 (exponent -> L_PAR np_push_operator expression R_PAR np_rpar .)


state 285

    (54) condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block . cond2 np_GOTO_END
    (55) cond2 -> . np_GOTO_ELSE ELSE block
    (56) cond2 -> . empty
    (135) np_GOTO_ELSE -> .
    (113) empty -> .

    ELSE            reduce using rule 135 (np_GOTO_ELSE -> .)
    IF              reduce using rule 113 (empty -> .)
    READ            reduce using rule 113 (empty -> .)
    WRITE           reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    FOR             reduce using rule 113 (empty -> .)
    RETURN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    R_BRACE         reduce using rule 113 (empty -> .)

    cond2                          shift and go to state 296
    np_GOTO_ELSE                   shift and go to state 297
    empty                          shift and go to state 298

state 286

    (25) block -> L_BRACE . blockB R_BRACE
    (26) blockB -> . statement blockB
    (27) blockB -> . empty
    (35) statement -> . assign
    (36) statement -> . condicional
    (37) statement -> . read
    (38) statement -> . write
    (39) statement -> . loop_cond
    (40) statement -> . loop_range
    (41) statement -> . return
    (42) statement -> . void_func
    (113) empty -> .
    (44) assign -> . var oper_assign np_push_operator expression np_end SEMICOLON
    (54) condicional -> . IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END
    (57) read -> . READ L_PAR read2 R_PAR SEMICOLON
    (60) write -> . WRITE L_PAR writeB R_PAR SEMICOLON
    (65) loop_cond -> . WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE
    (66) loop_range -> . FOR var EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR
    (67) return -> . RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON
    (43) void_func -> . func_call SEMICOLON
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    R_BRACE         reduce using rule 113 (empty -> .)
    IF              shift and go to state 73
    READ            shift and go to state 74
    WRITE           shift and go to state 75
    WHILE           shift and go to state 76
    FOR             shift and go to state 77
    RETURN          shift and go to state 78
    ID              shift and go to state 80

    blockB                         shift and go to state 61
    statement                      shift and go to state 62
    empty                          shift and go to state 63
    assign                         shift and go to state 64
    condicional                    shift and go to state 65
    read                           shift and go to state 66
    write                          shift and go to state 67
    loop_cond                      shift and go to state 68
    loop_range                     shift and go to state 69
    return                         shift and go to state 70
    void_func                      shift and go to state 71
    var                            shift and go to state 72
    func_call                      shift and go to state 79

state 287

    (22) vector -> ID L_BRACKET R_BRACKET .

    R_PAR           reduce using rule 22 (vector -> ID L_BRACKET R_BRACKET .)
    COMMA           reduce using rule 22 (vector -> ID L_BRACKET R_BRACKET .)


state 288

    (50) predef_func -> PLOT_XY L_PAR vector COMMA vector . R_PAR

    R_PAR           shift and go to state 299


state 289

    (51) predef_func -> REGRESSION L_PAR vector COMMA vector . R_PAR

    R_PAR           shift and go to state 300


state 290

    (63) writeC -> COMMA writeB .

    R_PAR           reduce using rule 63 (writeC -> COMMA writeB .)


state 291

    (65) loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF . block np_GOTO_WHILE
    (25) block -> . L_BRACE blockB R_BRACE

    L_BRACE         shift and go to state 286

    block                          shift and go to state 301

state 292

    (66) loop_range -> FOR var EQUAL np_push_operator exp np_set_VC TO . exp np_end np_comp_VC_VF block np_GOTO_FOR
    (89) exp -> . term exp2
    (93) term -> . factor term2
    (98) factor -> . exponent factorB
    (101) exponent -> . L_PAR np_push_operator expression R_PAR np_rpar
    (102) exponent -> . exponentB
    (103) exponentB -> . MINUS var_cte
    (104) exponentB -> . var_cte
    (105) var_cte -> . var
    (106) var_cte -> . predef_func
    (107) var_cte -> . func_call
    (108) var_cte -> . CTE_INT np_push_cte_int
    (109) var_cte -> . CTE_FLOAT np_push_cte_float
    (110) var_cte -> . CTE_CHAR np_push_cte_char
    (111) var_cte -> . CTE_STRING np_push_cte_str
    (112) var_cte -> . CTE_BOOL np_push_cte_bool
    (20) var -> . ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET
    (21) var -> . ID np_push_operand
    (45) predef_func -> . MIN L_PAR vector R_PAR
    (46) predef_func -> . MAX L_PAR vector R_PAR
    (47) predef_func -> . MEAN L_PAR vector R_PAR
    (48) predef_func -> . MEDIAN L_PAR vector R_PAR
    (49) predef_func -> . MODE L_PAR vector R_PAR
    (50) predef_func -> . PLOT_XY L_PAR vector COMMA vector R_PAR
    (51) predef_func -> . REGRESSION L_PAR vector COMMA vector R_PAR
    (52) predef_func -> . VARIANCE L_PAR vector R_PAR
    (53) predef_func -> . SUM L_PAR vector R_PAR
    (68) func_call -> . ID np_ERA L_PAR func_call_arguments R_PAR np_GOSUB

    L_PAR           shift and go to state 114
    MINUS           shift and go to state 122
    CTE_INT         shift and go to state 127
    CTE_FLOAT       shift and go to state 128
    CTE_CHAR        shift and go to state 129
    CTE_STRING      shift and go to state 130
    CTE_BOOL        shift and go to state 131
    ID              shift and go to state 80
    MIN             shift and go to state 132
    MAX             shift and go to state 133
    MEAN            shift and go to state 134
    MEDIAN          shift and go to state 135
    MODE            shift and go to state 136
    PLOT_XY         shift and go to state 137
    REGRESSION      shift and go to state 138
    VARIANCE        shift and go to state 139
    SUM             shift and go to state 140

    var                            shift and go to state 124
    exp                            shift and go to state 302
    term                           shift and go to state 118
    factor                         shift and go to state 119
    exponent                       shift and go to state 120
    exponentB                      shift and go to state 121
    var_cte                        shift and go to state 123
    predef_func                    shift and go to state 125
    func_call                      shift and go to state 126

state 293

    (67) return -> RETURN L_PAR np_stop exp np_end np_set_return R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 303


state 294

    (20) var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .

    EQUAL           reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    MULT_EQ         reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    DIV_EQ          reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    PLUS_EQ         reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    MINUS_EQ        reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    EXP             reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    MULT            reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    DIV             reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    REMAINDER       reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    PLUS            reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    MINUS           reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    LESS            reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    GREATER         reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    LESS_EQ         reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    GREATER_EQ      reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    EQUIVALENT      reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    DIFFERENT       reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    OR              reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    AND             reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    R_PAR           reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    COMMA           reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    SEMICOLON       reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    R_BRACKET       reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    TO              reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)
    L_BRACE         reduce using rule 20 (var -> ID L_BRACKET np_arr_start exp np_end np_arr_end R_BRACKET .)


state 295

    (69) func_call_arguments -> np_stop exp np_end np_param .
    (70) func_call_arguments -> np_stop exp np_end np_param . COMMA func_call_arguments

    R_PAR           reduce using rule 69 (func_call_arguments -> np_stop exp np_end np_param .)
    COMMA           shift and go to state 304


state 296

    (54) condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block cond2 . np_GOTO_END
    (136) np_GOTO_END -> .

    IF              reduce using rule 136 (np_GOTO_END -> .)
    READ            reduce using rule 136 (np_GOTO_END -> .)
    WRITE           reduce using rule 136 (np_GOTO_END -> .)
    WHILE           reduce using rule 136 (np_GOTO_END -> .)
    FOR             reduce using rule 136 (np_GOTO_END -> .)
    RETURN          reduce using rule 136 (np_GOTO_END -> .)
    ID              reduce using rule 136 (np_GOTO_END -> .)
    R_BRACE         reduce using rule 136 (np_GOTO_END -> .)

    np_GOTO_END                    shift and go to state 305

state 297

    (55) cond2 -> np_GOTO_ELSE . ELSE block

    ELSE            shift and go to state 306


state 298

    (56) cond2 -> empty .

    IF              reduce using rule 56 (cond2 -> empty .)
    READ            reduce using rule 56 (cond2 -> empty .)
    WRITE           reduce using rule 56 (cond2 -> empty .)
    WHILE           reduce using rule 56 (cond2 -> empty .)
    FOR             reduce using rule 56 (cond2 -> empty .)
    RETURN          reduce using rule 56 (cond2 -> empty .)
    ID              reduce using rule 56 (cond2 -> empty .)
    R_BRACE         reduce using rule 56 (cond2 -> empty .)


state 299

    (50) predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .

    EXP             reduce using rule 50 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    MULT            reduce using rule 50 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    DIV             reduce using rule 50 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    REMAINDER       reduce using rule 50 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    PLUS            reduce using rule 50 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    MINUS           reduce using rule 50 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    LESS            reduce using rule 50 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    GREATER         reduce using rule 50 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    LESS_EQ         reduce using rule 50 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    GREATER_EQ      reduce using rule 50 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    EQUIVALENT      reduce using rule 50 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    DIFFERENT       reduce using rule 50 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    OR              reduce using rule 50 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    AND             reduce using rule 50 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    R_PAR           reduce using rule 50 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    COMMA           reduce using rule 50 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    SEMICOLON       reduce using rule 50 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    R_BRACKET       reduce using rule 50 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    TO              reduce using rule 50 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)
    L_BRACE         reduce using rule 50 (predef_func -> PLOT_XY L_PAR vector COMMA vector R_PAR .)


state 300

    (51) predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .

    EXP             reduce using rule 51 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    MULT            reduce using rule 51 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    DIV             reduce using rule 51 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    REMAINDER       reduce using rule 51 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    PLUS            reduce using rule 51 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    MINUS           reduce using rule 51 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    LESS            reduce using rule 51 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    GREATER         reduce using rule 51 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    LESS_EQ         reduce using rule 51 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    GREATER_EQ      reduce using rule 51 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    EQUIVALENT      reduce using rule 51 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    DIFFERENT       reduce using rule 51 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    OR              reduce using rule 51 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    AND             reduce using rule 51 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    R_PAR           reduce using rule 51 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    COMMA           reduce using rule 51 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    SEMICOLON       reduce using rule 51 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    R_BRACKET       reduce using rule 51 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    TO              reduce using rule 51 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)
    L_BRACE         reduce using rule 51 (predef_func -> REGRESSION L_PAR vector COMMA vector R_PAR .)


state 301

    (65) loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block . np_GOTO_WHILE
    (137) np_GOTO_WHILE -> .

    IF              reduce using rule 137 (np_GOTO_WHILE -> .)
    READ            reduce using rule 137 (np_GOTO_WHILE -> .)
    WRITE           reduce using rule 137 (np_GOTO_WHILE -> .)
    WHILE           reduce using rule 137 (np_GOTO_WHILE -> .)
    FOR             reduce using rule 137 (np_GOTO_WHILE -> .)
    RETURN          reduce using rule 137 (np_GOTO_WHILE -> .)
    ID              reduce using rule 137 (np_GOTO_WHILE -> .)
    R_BRACE         reduce using rule 137 (np_GOTO_WHILE -> .)

    np_GOTO_WHILE                  shift and go to state 307

state 302

    (66) loop_range -> FOR var EQUAL np_push_operator exp np_set_VC TO exp . np_end np_comp_VC_VF block np_GOTO_FOR
    (128) np_end -> .

    L_BRACE         reduce using rule 128 (np_end -> .)

    np_end                         shift and go to state 308

state 303

    (67) return -> RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON .

    IF              reduce using rule 67 (return -> RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON .)
    READ            reduce using rule 67 (return -> RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON .)
    WRITE           reduce using rule 67 (return -> RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON .)
    WHILE           reduce using rule 67 (return -> RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON .)
    FOR             reduce using rule 67 (return -> RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON .)
    RETURN          reduce using rule 67 (return -> RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON .)
    ID              reduce using rule 67 (return -> RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON .)
    R_BRACE         reduce using rule 67 (return -> RETURN L_PAR np_stop exp np_end np_set_return R_PAR SEMICOLON .)


state 304

    (70) func_call_arguments -> np_stop exp np_end np_param COMMA . func_call_arguments
    (69) func_call_arguments -> . np_stop exp np_end np_param
    (70) func_call_arguments -> . np_stop exp np_end np_param COMMA func_call_arguments
    (71) func_call_arguments -> . empty
    (148) np_stop -> .
    (113) empty -> .

    L_PAR           reduce using rule 148 (np_stop -> .)
    MINUS           reduce using rule 148 (np_stop -> .)
    CTE_INT         reduce using rule 148 (np_stop -> .)
    CTE_FLOAT       reduce using rule 148 (np_stop -> .)
    CTE_CHAR        reduce using rule 148 (np_stop -> .)
    CTE_STRING      reduce using rule 148 (np_stop -> .)
    CTE_BOOL        reduce using rule 148 (np_stop -> .)
    ID              reduce using rule 148 (np_stop -> .)
    MIN             reduce using rule 148 (np_stop -> .)
    MAX             reduce using rule 148 (np_stop -> .)
    MEAN            reduce using rule 148 (np_stop -> .)
    MEDIAN          reduce using rule 148 (np_stop -> .)
    MODE            reduce using rule 148 (np_stop -> .)
    PLOT_XY         reduce using rule 148 (np_stop -> .)
    REGRESSION      reduce using rule 148 (np_stop -> .)
    VARIANCE        reduce using rule 148 (np_stop -> .)
    SUM             reduce using rule 148 (np_stop -> .)
    R_PAR           reduce using rule 113 (empty -> .)

    np_stop                        shift and go to state 206
    func_call_arguments            shift and go to state 309
    empty                          shift and go to state 207

state 305

    (54) condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END .

    IF              reduce using rule 54 (condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END .)
    READ            reduce using rule 54 (condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END .)
    WRITE           reduce using rule 54 (condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END .)
    WHILE           reduce using rule 54 (condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END .)
    FOR             reduce using rule 54 (condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END .)
    RETURN          reduce using rule 54 (condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END .)
    ID              reduce using rule 54 (condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END .)
    R_BRACE         reduce using rule 54 (condicional -> IF L_PAR expression np_end np_GOTOF R_PAR block cond2 np_GOTO_END .)


state 306

    (55) cond2 -> np_GOTO_ELSE ELSE . block
    (25) block -> . L_BRACE blockB R_BRACE

    L_BRACE         shift and go to state 286

    block                          shift and go to state 310

state 307

    (65) loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE .

    IF              reduce using rule 65 (loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE .)
    READ            reduce using rule 65 (loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE .)
    WRITE           reduce using rule 65 (loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE .)
    WHILE           reduce using rule 65 (loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE .)
    FOR             reduce using rule 65 (loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE .)
    RETURN          reduce using rule 65 (loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE .)
    ID              reduce using rule 65 (loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE .)
    R_BRACE         reduce using rule 65 (loop_cond -> WHILE L_PAR np_CHECKPOINT expression R_PAR np_end np_GOTOF block np_GOTO_WHILE .)


state 308

    (66) loop_range -> FOR var EQUAL np_push_operator exp np_set_VC TO exp np_end . np_comp_VC_VF block np_GOTO_FOR
    (132) np_comp_VC_VF -> .

    L_BRACE         reduce using rule 132 (np_comp_VC_VF -> .)

    np_comp_VC_VF                  shift and go to state 311

state 309

    (70) func_call_arguments -> np_stop exp np_end np_param COMMA func_call_arguments .

    R_PAR           reduce using rule 70 (func_call_arguments -> np_stop exp np_end np_param COMMA func_call_arguments .)


state 310

    (55) cond2 -> np_GOTO_ELSE ELSE block .

    IF              reduce using rule 55 (cond2 -> np_GOTO_ELSE ELSE block .)
    READ            reduce using rule 55 (cond2 -> np_GOTO_ELSE ELSE block .)
    WRITE           reduce using rule 55 (cond2 -> np_GOTO_ELSE ELSE block .)
    WHILE           reduce using rule 55 (cond2 -> np_GOTO_ELSE ELSE block .)
    FOR             reduce using rule 55 (cond2 -> np_GOTO_ELSE ELSE block .)
    RETURN          reduce using rule 55 (cond2 -> np_GOTO_ELSE ELSE block .)
    ID              reduce using rule 55 (cond2 -> np_GOTO_ELSE ELSE block .)
    R_BRACE         reduce using rule 55 (cond2 -> np_GOTO_ELSE ELSE block .)


state 311

    (66) loop_range -> FOR var EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF . block np_GOTO_FOR
    (25) block -> . L_BRACE blockB R_BRACE

    L_BRACE         shift and go to state 286

    block                          shift and go to state 312

state 312

    (66) loop_range -> FOR var EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block . np_GOTO_FOR
    (138) np_GOTO_FOR -> .

    IF              reduce using rule 138 (np_GOTO_FOR -> .)
    READ            reduce using rule 138 (np_GOTO_FOR -> .)
    WRITE           reduce using rule 138 (np_GOTO_FOR -> .)
    WHILE           reduce using rule 138 (np_GOTO_FOR -> .)
    FOR             reduce using rule 138 (np_GOTO_FOR -> .)
    RETURN          reduce using rule 138 (np_GOTO_FOR -> .)
    ID              reduce using rule 138 (np_GOTO_FOR -> .)
    R_BRACE         reduce using rule 138 (np_GOTO_FOR -> .)

    np_GOTO_FOR                    shift and go to state 313

state 313

    (66) loop_range -> FOR var EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR .

    IF              reduce using rule 66 (loop_range -> FOR var EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR .)
    READ            reduce using rule 66 (loop_range -> FOR var EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR .)
    WRITE           reduce using rule 66 (loop_range -> FOR var EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR .)
    WHILE           reduce using rule 66 (loop_range -> FOR var EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR .)
    FOR             reduce using rule 66 (loop_range -> FOR var EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR .)
    RETURN          reduce using rule 66 (loop_range -> FOR var EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR .)
    ID              reduce using rule 66 (loop_range -> FOR var EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR .)
    R_BRACE         reduce using rule 66 (loop_range -> FOR var EQUAL np_push_operator exp np_set_VC TO exp np_end np_comp_VC_VF block np_GOTO_FOR .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 200 resolved using rule (var_cte -> CTE_STRING np_push_cte_str)
WARNING: rejected rule (np_write -> <empty>) in state 200
